use cfgfile;
use uo;
use os;
use util;

include "include/client";
include ":attributes:attributes";
include "include/string";
include "include/objtype";
include "include/canAccess";
include "include/utility";
include ":itemutils:toolWear";
include ":virtue:noto";
include ":damage:damage";
include ":resourcecore:resourceCore";
include ":resourcecore:wood";
include ":itemUtils:itemUtil";

const UACTION_CHOP := 0x0d;
// const FX_POISON_GAS := 0x113a;

program use_axe( mobile, axe )

  if ( !useItem_check( mobile, axe, ITEM_EQUIPPED ) )
    return 0;
  elseif ( GetEquipmentByLayer( mobile, 25 ) )
    SendSysMessage( mobile, "You cannot dig while mounted.", 0x3, 0x22 );
    return 0;
  endif

  var tree := TreeNearby( mobile, axe );

  if ( !tree )
    return;
  endif

  SendSysMessage( mobile, "You begin chopping..." );

  AXE_HarvestResource( mobile, tree, axe );
endprogram

function TreeNearby( me, axe )
  SendSysMessage( me, "Select something to chop." );
  var tree := TargetCoordinates( me );
  if ( !tree )
    SendSysMessage( me, "Cancelled" );
    return 0;
  endif
  var distt := CoordinateDistance( me.x, me.y, tree.x, tree.y );
  if ( distt > 1 )
    if ( !tree.item.container )
      SendSysMessage( me, "That is too far away" );
      return 0;
    endif
  endif
  if ( is_furniture( tree.item.objtype, tree.item ) )
    chopfurniture( me, tree.item );
    return 0;
  elseif ( is_tree( tree.objtype ) )
    return tree;
  else
    use_blade( me, axe, tree.item );
    return 0;
  endif
endfunction

function is_furniture( theobj, thing )
  var miscobjtypes := { 0x17007, 0xA30, 0xA34, 0xA38, 0xFAE, 0x19E40 };
  if ( ( theobj >= 0x9a8 ) && ( theobj <= 0x9ab ) )
    return 1;
  elseif ( ( theobj >= 0xa2a ) && ( theobj <= 0xa2c ) )
    return 1;
  elseif ( ( theobj >= 0xa4c ) && ( theobj <= 0xa53 ) )
    return 1;
  elseif ( ( theobj >= 0xa97 ) && ( theobj <= 0xa9e ) )
    return 1;
  elseif ( ( theobj >= 0xb2c ) && ( theobj <= 0xb40 ) )
    return 1;
  elseif ( ( theobj >= 0xb49 ) && ( theobj <= 0xb90 ) )
    return 1;
  elseif ( ( theobj >= 0xe3c ) && ( theobj <= 0xe43 ) )
    return 1;
  elseif ( ( theobj >= 0xe7c ) && ( theobj <= 0xe80 ) )
    return 1;
  elseif ( ( theobj >= 0xf65 ) && ( theobj <= 0xf77 ) )
    return 1;
  elseif ( theobj in miscobjtypes )
    return 1;
  elseif ( GetObjProperty( thing, "ItemsCreatedSerials" ) )
    return 1;
  else
    return 0;
  endif
endfunction

function is_tree( theobj )
  // NOTE: normal tree log is: 0x1bdd

  var treeconfigfile := ReadConfigFile( ":resourcecore:trees" );
  var tree := FindConfigElem( treeconfigfile, theobj );
  var logtype := GetConfigString( tree, "LogType" );
  var logtypeobj := GetObjtypeByName( logtype );

  // broadcast("target: " + theobj + " tree: " + tree + " logtype: " + logtype + " logtypeobj: " + logtypeobj);

  return logtypeobj;

/*
        if ((theobj >= 0x0c99) and (theobj <= 0x0c9d))     // Small palm
                return 0x1bdd;
//        elseif (theobj == 0x0c9e)                // Small tree
//                return 0x1bdd;
//        elseif ((theobj >= 0x0c9f) and (theobj <= 0x0ca5))   // Plants and flowers
//                return 0x1bdd;
        elseif (theobj == 0x0ca6)              // Ponytail palm
                return 0x1bdd;
//        elseif ((theobj == 0x0ca7) or (theobj == 0x0ca9))        // Plants and flowers
//                return 0x1bdd;
        elseif ((theobj == 0x0ca8) or (theobj == 0x0caa) or (theobj == 0x0cab)) // Banana
                return 0x26302;
//        elseif ((theobj >= 0x0cac) and (theobj <= 0x0cc8))   // Plants and flowers
//                return 0x705a;
        elseif ((theobj >= 0x0cc9) and (theobj <= 0x0cd5)) // Normal tree and leaves
                return 0x705a;
        elseif ((theobj >= 0x0cd6) and (theobj <= 0x0cd9)) // Cedar
                return 0x26304;
        elseif ((theobj >= 0x0cda) and (theobj <= 0x0cdf)) // Oak
                return 0x2630F;
        elseif ((theobj >= 0x0ce0) and (theobj <= 0x0ce5)) // Walnut
                return 0x26318;
        elseif (((theobj >= 0x0ce6) and (theobj <= 0x0ce8)) or ((theobj >= 0x224A) and (theobj <=0x224B))) // Willow
                return 0x26319;
        elseif ((theobj >= 0x0ce9) and (theobj <= 0x0cea)) // Sapling
                return 0x1bdd;
//        elseif ((theobj >= 0x0cf3) and (theobj <= 0x0cf7))   // Fallen log
//                return ;
        elseif (((theobj >= 0x0cf8) and (theobj <= 0x0cf9)) or ((theobj >= 0x0cfa) and (theobj <= 0x0d03)))    // Cypress
                return 0x26307;
        elseif ((theobj >= 0x0d37) and (theobj <= 0x0d38)) // Yucca
                return 0x2631B;
        elseif ((theobj >= 0x0d41) and (theobj <= 0x0d93)) // Big tropical tree and leaves
                return 0x1bdd;
        elseif ((theobj >= 0x0d94) and (theobj <= 0x0d9b)) // Apple
                return 0x26300;
        elseif ((theobj >= 0x246C) and (theobj <= 0x2470))      // Bamboo
                return 0x1bdd;
   elseif ((theobj >= 0x2471) and (theobj <= 0x2477))      // Cherry
                return 0x26305;
        elseif (theobj == 0x0C95)                               // Coconut
                return 0x26306;
        elseif (theobj == 0x0C96)                               // Date
                return 0x26308;
        elseif ((theobj >= 0x2478) and (theobj <= 0x247E))      // Maple
                return 0x2630E;
        elseif (theobj == 0x0C9E)                               // Ohii
                return 0x26310;
        elseif ((theobj >= 0x0d9c) and (theobj <= 0x0da3)) // Peach
                return 0x26311;
        elseif ((theobj >= 0x0da4) and (theobj <= 0x0dab)) // Pear
                return 0x26312;
        elseif ((theobj >= 0x26ED) and (theobj <= 0x26F3))      // Plum
                return 0x26310;
        elseif ((theobj >= 0x0CC9) and (theobj <= 0x0CC9))      // Spider Tree
                return 0x26316;
        elseif ((theobj >= 0x12b6) and (theobj <= 0x12c7)) // Yew tree
                return 0x2631A;
        else
                return 0;
        endif
*/
endfunction

function chopfurniture( me, theobj )
  if ( !can_access( me, theobj ) )
    return;
  endif
  var sign;
  if ( GetObjProperty( theobj, "lockeddown" ) || GetObjProperty( theobj, "secure" ) )
    SendSysMessage( me, "You cannot destroy secure or locked down items." );
    return;
  endif
  if ( theobj.objtype == 0x17007 )
    var houseserial := GetObjProperty( theobj, "houseserial" );
    sign := SystemFindObjectBySerial( houseserial );
    if ( GetObjProperty( sign, "barrelserial" ) == theobj.serial )
      EraseObjProperty( sign, "barrelserial" );
      SendSysMessage( me, "you cannot destroy that while it is locked down." );
      return;
    endif
  endif
  if ( !Accessible( me, theobj ) )
    SendSysMessage( me, "you cant reach that" );
    return;
  endif
  if ( me.multi )
    if ( GetObjProperty( ( me.multi ), "ownerserial" ) != me.serial )
      var house := me.multi;
      foreach thing in ( house.components )
        if ( ( thing.objtype == 0x0bd0 ) || ( thing.objtype == 0x0bd2 ) )
          sign := thing;
          break;
        endif
      endforeach
      var coowner := 0;
      var coownerlist := GetObjProperty( sign, "coownerlist" );
      foreach thing in coownerlist
        if ( thing == me.serial )
          coowner := 1;
          break;
        endif
      endforeach
      if ( !coowner )
        SendSysMessage( me, "this does not belong to you!" );
        return;
      endif
    endif
  endif
  foreach thing in EnumerateItemsInContainer( theobj )
    if ( theobj.container )
      MoveItemToContainer( thing, theobj.container );
    else
      MoveObjectToLocation( thing, theobj.x, theobj.y, theobj.z, theobj.realm,
                            MOVEOBJECT_FORCELOCATION );
    endif
  endforeach
  var created := GetObjProperty( theobj, "ItemsCreatedSerials" );
  if ( created )
    var holder;
    foreach thing in created
      holder := SystemFindObjectBySerial( thing );
      if ( holder )
        DestroyItem( holder );
      endif
    endforeach
  else
    DestroyItem( theobj );
  endif
  PlaySoundEffect( me, 0x13a );
  return;
endfunction

function use_blade( who, blade, use_on )

  if ( !can_access( who, use_on ) )
    return;
  endif

  if ( !ReserveItem( use_on ) )
    return;
  endif

  var checkme := use_on.objtype;

  if ( use_on.npctemplate == "sheep" )
    process_wool( who, blade, use_on );
  elseif ( use_on.objtype == UOBJ_CORPSE )
    ReleaseItem( blade );
    CarveCorpse( who, use_on );
  elseif ( is_fish( checkme ) )
    CarveFish( who, blade, use_on );
  else
    SendSysMessage( who, "I don't know how to use those items together." );
  endif

endfunction

function process_wool( who, blade, sheep )
  if ( sheep.graphic == 207 )
    sheep.graphic := 223;
    CreateItemInContainer( who.backpack, 0x1f125, 3 );
    CheckToolWear( who, blade, TAILORING );
  else
    SendSysMessage( who, "That sheep is not yet ready to be shorn." );
  endif
endfunction

function is_fish( theobj )
  if ( ( theobj >= UOBJ_FISH_START ) && ( theobj <= UOBJ_FISH_END ) )
    return 1;
  elseif ( ( theobj >= UOBJ_SFISH_START ) && ( theobj <= UOBJ_SFISH_END ) )
    return 1;
  else
    return 0;
  endif
endfunction

function CarveFish( who, blade, use_on )
  if ( ( !ReserveItem( use_on ) ) || ( use_on.movable == 0 ) )
    SendSysMessage( who, "You cannot use that." );
    return;
  endif
  var num_steaks := ( 4 * use_on.amount );
  PlaySoundEffect( who, SFX_57 );
  if ( DestroyItem( use_on ) )
    CreateItemInBackpack( who, UOBJ_FISHSTEAK, num_steaks );
    CheckToolWear( who, blade, FISHING );
    SendSysMessage( who, "You carve the fish steaks and put them in your backpack" );
  endif
  sleep( 1 );
endfunction

function CarveCorpse( who, cadaver )
  Detach();
  if ( ( !Accessible( who, cadaver ) ) or ( !CheckLineOfSight( who, cadaver ) ) )
    SendSysMessage( who, "You cannot use that" );
    return;
  endif
  if ( Distance( who, cadaver ) > 2 )
    SendSysMessage( who, "You are not close enough" );
    return;
  endif
  var c_type := cadaver.corpsetype;
  if ( GetObjProperty( cadaver, "cut" ) == "1" )
    SendSysMessage( who, "You cannot get any more from this corpse." );
    foreach thing in EnumerateItemsInContainer( cadaver )
      MoveObjectToLocation( thing, cadaver.x, cadaver.y, cadaver.z, cadaver.realm,
                            MOVEOBJECT_FORCELOCATION );
    endforeach
    DestroyItem( cadaver );
  elseif ( ( c_type == 400 ) || ( c_type == 401 ) )
    var beardlist := { 0x203e, 0x203f, 0x2040, 0x2041, 0x204b, 0x204c, 0x204d };
    var hairlist := { 0x2044, 0x2045, 0x2046, 0x2047, 0x2048, 0x2049,
                      0x204a, 0x203b, 0x203c, 0x203d };
    foreach thing in EnumerateItemsInContainer( cadaver )
      if ( ( thing.objtype in hairlist ) or ( thing.objtype in beardlist ) )
        DestroyItem( thing );
      else
        MoveObjectToLocation( thing, cadaver.x, cadaver.y, cadaver.z,
                              cadaver.realm, MOVEOBJECT_FORCELOCATION );
      endif
    endforeach
    var partsarray := {};
    var part;
    part := CreateItemAtLocation( cadaver.x - 1, cadaver.y, cadaver.z, 0x1da0,
                                  1 );
    partsarray.append( part );
    SetObjProperty( part, "serial", GetObjProperty( cadaver, "serial" ) );
    var aname := cadaver.name;
    aname["A corpse of"] := "";
    part.name := "The head of " + aname;
    part := CreateItemAtLocation( cadaver.x - 1, cadaver.y, cadaver.z, 0x1da1,
                                  1 );
    partsarray.append( part );
    part := CreateItemAtLocation( cadaver.x - 1, cadaver.y + 1, cadaver.z,
                                  0x1da2, 1 );
    partsarray.append( part );
    part := CreateItemAtLocation( cadaver.x + 1, cadaver.y, cadaver.z, 0x1da3,
                                  1 );
    partsarray.append( part );
    part := CreateItemAtLocation( cadaver.x + 1, cadaver.y + 1, cadaver.z,
                                  0x1da4, 1 );
    partsarray.append( part );
    part := CreateItemAtLocation( cadaver.x, cadaver.y, cadaver.z, 0x1d9f, 1 );
    partsarray.append( part );
    var blood := CreateItemAtLocation( cadaver.x, cadaver.y, cadaver.z, 0x122a,
                                       1 );
    blood.movable := 0;
    DestroyItem( cadaver );
    sleep( 40 );
    foreach thing in partsarray
      if ( !thing.container )
        DestroyItem( thing );
      endif
    endforeach
    sleep( 20 );
    DestroyItem( blood );
  else
    if ( c_type == 223 )
      CreateItemInContainer( cadaver, 0x9f1, 2 );
      SendSysMessage( who, "You place the items on the corpse." );
      var theblood := CreateItemAtLocation( cadaver.x, cadaver.y, cadaver.z,
                                            UOBJ_BLOOD, 1 );
      sleep( 30 );
      DestroyItem( cadaver );
      sleep( 30 );
      DestroyItem( theblood );
      return;
    endif
    var conf := ReadConfigFile( ":*:npcdesc" );
    var tmplate := GetObjProperty( cadaver, "npctemplate" );
    if ( !tmplate )
      SendSysMessage( who, "You cut the corpse, but fail to find anything useful.",
                      3, 40 );
      var theblood := CreateItemAtLocation( cadaver.x, cadaver.y, cadaver.z,
                                            UOBJ_BLOOD, 1 );
      sleep( 30 );
      DestroyItem( cadaver );
      sleep( 30 );
      DestroyItem( theblood );
      return;
    else
      SetObjProperty( cadaver, "cut", "1" );
      var corpseitm := conf[tmplate]."corpseitm";
      var corpseamt := conf[tmplate]."corpseamt";
      print( "I: " + corpseitm );
      print( "A: " + corpseamt );
      if ( !corpseitm )
        print( "error" );
        var theblood := CreateItemAtLocation( cadaver.x, cadaver.y, cadaver.z,
                                              UOBJ_BLOOD, 1 );
        sleep( 30 );
        DestroyItem( cadaver );
        sleep( 30 );
        DestroyItem( theblood );
        return;
      endif
      var i := 1;
      corpseitm := SplitWords( corpseitm );
      corpseamt := SplitWords( corpseamt );
      foreach thing in corpseitm
        CreateItemInContainer( cadaver, thing, Cint( corpseamt[i] ) );
        i := i + 1;
      endforeach
      SendSysMessage( who, "You place the items on the corpse." );
      var theblood := CreateItemAtLocation( cadaver.x, cadaver.y, cadaver.z,
                                            UOBJ_BLOOD, 1 );
      sleep( 30 );
      DestroyItem( cadaver );
      sleep( 30 );
      DestroyItem( theblood );
    endif
  endif
endfunction

function AXE_HarvestResource( byref mobile, byref use_on, byref tool )

  var data_elem := 0, last_harvest := 0, quantity := 0, settings := 0,
      resource_name := "", sounds := 0, amount := 0, cfg_file := "",
      item_desc := "";

  data_elem := RC_FindWoodDataElem( Cstr( use_on.x + "_" + use_on.y + "_" + use_on.z
                                        + "_" + use_on.realm ) );
  last_harvest := RC_GetWoodProps( data_elem, "Harvest" );
  quantity := RC_GetWoodProps( data_elem, "Quantity" );
  settings := RC_GetSettingsCfgElem( "WoodSettings" );
  cfg_file := RC_GetTreesCfgElem( use_on.objtype );
  item_desc := GetConfigString( FindConfigElem( ReadConfigFile( ":logs:itemdesc" ),
                                                GetObjtypeByName( cfg_file.LogType ) ),
                                "Desc" );
  resource_name := "wood";

  quantity += Floor( Cint( ReadGameClock() - last_harvest ) / CInt( settings.SecondsPerRegrow ) );
  if ( quantity > CInt( settings.MaxYield ) )
    quantity := CInt( settings.MaxYield );
  endif

  if ( mobile.cmdlevel >= 5 )
    SendSysMessage( mobile, "Quantity: " + quantity + " Itemdesc: " + item_desc );
  endif

  if ( quantity < 1 )
    SendSysMessage( mobile, "There are not enough " + FormatItemDescription( item_desc )
                  + " here to harvest.", 0x3, 0x22 );
    return 0;
  elseif ( CoordinateDistance( mobile.x, mobile.y, use_on.x, use_on.y ) > 2 )
    SendSysMessage( mobile,
                    "You must be closer to harvest any " + FormatItemDescription( item_desc )
                  + "!", 0x3, 0x22 );
    return 0;
  endif

  RC_StartCharacterTracker( mobile, mobile.x, mobile.y, mobile.realm,
                            GetPid() );

  EnableEvents( EVID_OPPONENT_MOVED );

  while ( quantity > 0 )
    sounds := CInt( SplitWords( settings.EffectSounds ).RandomEntry() );

    amount := CInt( CDbl( GetAttributeBaseValue( mobile, LUMBERJACKING ) / 10.0 ) / 20.0 );
    if ( amount < 1 )
      amount := 1;
    elseif ( amount > 10 )
      amount := 10;
    endif

    if ( mobile.cmdlevel >= 5 )
      SendSysMessage( mobile, "Amount 1: " + amount + " Quantity 1: " +
                      quantity );
    endif

    if ( quantity < amount )
      amount := CInt( quantity );
      quantity := 0;
    endif

    if ( mobile.cmdlevel >= 5 )
      SendSysMessage( mobile, "Amount 2: " + amount + " Quantity 2: " +
                      quantity );
    endif

    if ( amount < 1 )
      SendSysMessage( mobile, "There's not enough " + FormatItemDescription( item_desc )
                    + " here to harvest.", 0x3, 0x22 );
      return 0;
    endif

    if ( mobile.cmdlevel >= 5 )
      SendSysMessage( mobile, "Amount 3: " + amount + " Quantity 3: " +
                      quantity );
    endif

    PerformAction( mobile, CInt( settings.EffectAction ) );
    PlaySoundEffectXYZ( use_on.x, use_on.y, use_on.z, sounds, use_on.realm );

    var cs_result := CheckSkill( mobile, LUMBERJACKING, CInt( cfg_file.Difficulty ),
                                 100 );
    var sc_result := SkillCheck( mobile, LUMBERJACKING, CInt( cfg_file.Difficulty ) );

    if ( mobile.cmdlevel >= 5 )
      SendSysMessage( mobile, "CheckSkill result: " + cs_result + "SkillCheck result: "
                    + sc_result );
    endif

    // We dont have a hook in the distro
    //      if( !CheckSkill( mobile, LUMBERJACKING, CInt( cfg_file.Difficulty ), 100 ) )

    // This is what happens when the SkillCheck fails:
    if ( !sc_result )
      if ( amount >= 2 )
        amount /= 2;
      endif
      SendSysMessage( mobile,
                      "You failed to harvest any logs and made parts of the resource unusable." );
      quantity -= amount;

      if ( quantity < 0 )
        quantity := 0;
      endif

      data_elem.SetProp( "Harvest", ReadGameClock() );
      data_elem.SetProp( "Quantity", quantity );
      SleepMS( 1900 );
      continue;
    endif

    SleepMS( 1900 );

    var create_item := CreateItemInBackpack( mobile, cfg_file.LogType, amount );

    if ( mobile.cmdlevel >= 5 )
      SendSysMessage( mobile, "ERROR: " + create_item.ErrorText );
      SendSysMessage( mobile, "X: " + mobile.x + " Y: " + mobile.y + " Z: "
                    + mobile.z + " LT: " + cfg_file.LogType +
                      " #: " + amount + " Realm: " + mobile.realm );
    endif

    if ( create_item )
      SendSysMessage( mobile,
                      "You place " + FormatItemDescription( item_desc, amount )
                    + " in your backpack.", 0x3, 0x42 );
    else

      CreateStackableItemAtLocation( mobile, cfg_file.LogType, amount,
                                     range := 0 );
      SendSysMessage( mobile,
                      "Your backpack is full and the " + FormatItemDescription( item_desc,
                                                                                amount )
                    + " is placed at your feet.", 0x3, 0x32 );

    endif

    quantity -= amount;
    if ( quantity < 0 )
      quantity := 0;
    endif

    if ( quantity == 0 )
      SendSysMessage( mobile,
                      "You have chopped all the " + FormatItemDescription( item_desc ) + ".",
                      0x3, 0x32 );
    endif

    data_elem.SetProp( "Harvest", ReadGameClock() );
    data_elem.SetProp( "Quantity", quantity );

    RC_CheckToolDurability( mobile, tool );

  endwhile

endfunction
