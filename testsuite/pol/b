EScript Compiler v1.17
Copyright (C) 1993-2024 Eric N. Swanson

BREAK 
"use cfgfile; "
BREAK 
"use os; "
BREAK 
"use uo; "
BREAK 
"use util; "
BREAK 
"include "client"; "
BREAK 
"include ":datafile:datafile"; "
BREAK 
"include ":gumps:textConsts"; "
BREAK 
"include "string"; "
BREAK 
"const VERSION := "<basefont color=" + HTML_DARKBLUE + ">V4.2a"; "
BREAK 
"enum TextEntry_Checkboxes "
BREAK 
"ITEMCOLOR := 1000, "
BREAK 
"ITEMRAND, "
BREAK 
"ITEMCREATE, "
BREAK 
"ITEMPOS, "
BREAK 
"ITEMMODIFY, "
BREAK 
"ITEMMMULTICREATE, "
BREAK 
"ITEMMODIFYMANUAL, // Modify menu for later modification "
BREAK 
"MODIFY_Z_START, "
BREAK 
"MODIFY_Z_END, "
BREAK 
"MODIFY_CUSTOM, "
BREAK 
"MODIFY_MARK, "
BREAK 
"MODIFY_X_ENTRY, "
BREAK 
"MODIFY_Y_ENTRY, "
BREAK 
"MODIFY_Z_ENTRY "
BREAK 
"endenum "
BREAK 
"enum Buttons "
BREAK 
"BACKBUTTON := 2000, // Back-Button "
BREAK 
"MODIFY_MARKEDIT, "
BREAK 
"MODIFY_START := 3000, "
BREAK 
"MODIFY_Y_UP := 3005, // ModifyItem-Buttons "
BREAK 
"MODIFY_Y_DOWN, "
BREAK 
"MODIFY_X_UP, "
BREAK 
"MODIFY_X_DOWN, "
BREAK 
"MODIFY_XY_MM, "
BREAK 
"MODIFY_XY_MP, "
BREAK 
"MODIFY_XY_PM, "
BREAK 
"MODIFY_XY_PP, "
BREAK 
"MODIFY_Z_UP, "
BREAK 
"MODIFY_Z_DOWN, "
BREAK 
"MODIFY_DESTROY, "
BREAK 
"MODIFY_COLOR, "
BREAK 
"MODIFY_DUPE, "
BREAK 
"MODIFY_X, "
BREAK 
"MODIFY_Y, "
BREAK 
"MODIFY_Z, "
BREAK 
"MARK_SHOW, "
BREAK 
"MARK_HIDE, "
BREAK 
"MARK_EDIT "
BREAK 
"endenum "
BREAK 
"enum dataPositionsAngaben "
BREAK 
"COLORDATAPOS := 7, "
BREAK 
"ZSTARTPOS := 15, "
BREAK 
"ZENDPOS := 16, "
BREAK 
"XKOORDSPOS := 8, "
BREAK 
"YKOORDSPOS := 9, "
BREAK 
"ZKOORDSPOS := 10, "
BREAK 
"XENTRY := 12, "
BREAK 
"YENTRY, "
BREAK 
"ZENTRY "
BREAK 
"endenum "
BREAK 
"enum Ebenen "
BREAK 
"ROOTLIST := 0, // plane definition "
BREAK 
"FIRSTLIST, "
BREAK 
"SECONDLIST, "
BREAK 
"THIRDLIST, "
BREAK 
"FOURTHLIST, "
BREAK 
"FIFTHLIST, "
BREAK 
"ITEMLIST, "
BREAK 
"ITEMLISTDUMMY "
BREAK 
"endenum "
BREAK 
"enum Cprops "
BREAK 
"CPROP_INIT := "bautoolinit", // CProps to find the items "
BREAK 
"CPROP_ITEMS := "bautoolitems", "
BREAK 
"CPROP_COLOR := "bautoolorigcol" // Original color for markedit "
BREAK 
"endenum "
BREAK 
"const MENUSTART := 4000; "
"// Start value of the lists / item buttons "
BREAK 
"const MAXBUTTON := 7; "
"// Max Buttons in the NavBar "
BREAK 
"const MAXLINEITEM := 4; "
"// How many items side by side in single create "
BREAK 
"const MAXAREASIZE := 50; "
BREAK 
"const ITEMMOVEFLAGS := MOVEOBJECT_FORCELOCATION + MOVEITEM_IGNOREMOVABLE; "
BREAK 
"var cfgrandom := ReadConfigFile( "
""bautoolrandom" ); "
BREAK 
"var cfgeinzel := ReadConfigFile( "
""bautooleinzel" ); "
BREAK 
"var cfgset := ReadConfigFile( "
""bautoolset" ); "
BREAK 
"var datafile := DFOpenDataFile( "
""bautoolcmd", "
"DF_CREATE, "
"DF_KEYTYPE_STRING ); "
BREAK 
"var dataelementMenu := datafile.FindElement( "
""menu" ); "
BREAK 
"var dataelementModify := datafile.FindElement( "
""modify" ); "
BREAK 
"var dataelementElement := datafile.FindElement( "
""elemente" ); "
BREAK 
"var dataelementMark := datafile.FindElement( "
""modifymark" ); "
BREAK 
"var layoutmodify := dataelementModify.getprop( "
""LayoutMenu" ); "
BREAK 
"var datamodify := dataelementModify.getprop( "
""DataMenu" ); "
BREAK 
"var layoutmodify_M := dataelementModify.getprop( "
""LayoutMenuManual" ); "
BREAK 
"var datamodify_M := dataelementModify.getprop( "
""DataMenuManual" ); "
BREAK 
"var layoutmark := dataelementMark.getprop( "
""LayoutMenuMark" ); "
BREAK 
"var datamark := dataelementMark.getprop( "
""DataMenuMark" ); "
BREAK 
"var datafileelement := dataelementElement.getprop( "
""dictionary" ); "
BREAK 
"program bautool( who, param ) "
BREAK 
"if ( "
"who[1] == "Init" ) "
"// Generate datafile via script "
BREAK 
"Init(); "
BREAK 
"return; "
BREAK 
"endif "
BREAK 
"if ( "
"!GetGlobalProperty( "
""BauServer" ) ) "
BREAK 
"if ( "
"who.cmdlevel < 3 ) "
BREAK 
"SendSysMessage( "
"who, "
""You are not authorized to use this command!" ); "
BREAK 
"return; "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"if ( "
"Lower( "
"param ) == "init" ) "
"// Developer can start Init () manually "
BREAK 
"if ( "
"who.cmdlevel == 5 ) "
BREAK 
"cfgrandom := 0; "
"// First remove Ref's so that Unload works properly "
BREAK 
"cfgeinzel := 0; "
BREAK 
"cfgset := 0; "
BREAK 
"UnloadConfigFile( "
""bautoolmenues" ); "
BREAK 
"UnloadConfigFile( "
""bautooleinzel" ); "
BREAK 
"UnloadConfigFile( "
""bautoolrandom" ); "
BREAK 
"UnloadConfigFile( "
""bautoolset" ); "
BREAK 
"cfgrandom := ReadConfigFile( "
"":bautool:bautoolrandom" ); "
BREAK 
"cfgeinzel := ReadConfigFile( "
"":bautool:bautooleinzel" ); "
BREAK 
"cfgset := ReadConfigFile( "
"":bautool:bautoolset" ); "
BREAK 
"SendSysMessage( "
"who, "
""Datafile building..." ); "
BREAK 
"Init(); "
BREAK 
"SendSysMessage( "
"who, "
""Datafile completed" ); "
BREAK 
"return; "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"if ( "
"GetGlobalProperty( "
""bautoolinit" ) ) "
BREAK 
"SendSysMessage( "
"who, "
""Datafile is still being generated, try again later." ); "
BREAK 
"return; "
BREAK 
"endif "
BREAK 
"ShowMenu( "
"who ); "
BREAK 
"endprogram "
BREAK 
"function ShowMenu( "
"who ) "
"// {{{ "
BREAK 
"var data := {}, "
"layout := {}, "
"nr, ebene; "
BREAK 
"var ret, tile := {}; "
BREAK 
"var element := dictionary{}, "
"back := 0; "
BREAK 
"var firstebene, secondebene, thirdebene, fourthebene, fifthebene, itemebene; "
BREAK 
"var color; "
BREAK 
"element := datafileelement; "
BREAK 
"ebene := FIRSTLIST; "
BREAK 
"layout := dataelementMenu.getprop( "
""LayoutMenuBar" ); "
BREAK 
"data := dataelementMenu.getprop( "
""DataMenuBar" ); "
BREAK 
"ret := SendDialogGump( "
"who, "
"layout, "
"data, "
"10, "
"50 ); "
BREAK 
"while ( "
"who.connected ) "
BREAK 
"if ( "
"( ret.keys[ret.keys.size()] "
"> MENUSTART ) || "
"( back ) ) "
BREAK 
"if ( "
"back ) "
"// Simulated buttone printing "
BREAK 
"nr := back; "
BREAK 
"back := 0; "
BREAK 
"else "
BREAK 
"nr := ret.keys[ret.keys.size()] "
"- MENUSTART; "
BREAK 
"endif "
BREAK 
"case "
"( "
"ebene ) "
"// In which display level I am, create a suitable data list "
BREAK 
"ROOTLIST: "
"ebene := FIRSTLIST; "
BREAK 
"layout := dataelementMenu.getprop( "
""LayoutMenuBar" ); "
BREAK 
"data := dataelementMenu.getprop( "
""DataMenuBar" ); "
BREAK 
"FIRSTLIST: "
"ebene := SECONDLIST; "
BREAK 
"if ( "
"TypeOfInt( "
"nr ) == OT_STRING ) "
BREAK 
"firstebene := nr; "
BREAK 
"else "
BREAK 
"firstebene := element.keys()["
"nr]; "
BREAK 
"endif "
BREAK 
"layout := dataelementMenu.getprop( "
""LayoutMain_" + firstebene ); "
BREAK 
"data := dataelementMenu.getprop( "
""DataMain_" + firstebene ); "
BREAK 
"SECONDLIST: "
"ebene := THIRDLIST; "
BREAK 
"if ( "
"TypeOfInt( "
"element[firstebene] ) <> OT_DICTIONARY ) "
BREAK 
"secondebene := nr; "
BREAK 
"tile := BuildItems( "
"layout, "
"data, "
"element[firstebene][nr], "
"firstebene ); "
BREAK 
"else "
BREAK 
"if ( "
"TypeOfInt( "
"nr ) == OT_STRING ) "
BREAK 
"secondebene := nr; "
BREAK 
"else "
BREAK 
"secondebene := element[firstebene].keys()["
"nr]; "
BREAK 
"endif "
BREAK 
"layout := dataelementMenu.getprop( "
""LayoutSub_" + firstebene + "_" + secondebene ); "
BREAK 
"data := dataelementMenu.getprop( "
""DataSub_" + firstebene + "_" + secondebene ); "
BREAK 
"endif "
BREAK 
"THIRDLIST: "
"ebene := FOURTHLIST; "
BREAK 
"if ( "
"TypeOfInt( "
"element[firstebene][secondebene] ) <> OT_DICTIONARY ) "
BREAK 
"thirdebene := nr; "
BREAK 
"tile := BuildItems( "
"layout, "
"data, "
"element[firstebene][secondebene][nr], "
"firstebene, "
"secondebene ); "
BREAK 
"else "
BREAK 
"if ( "
"TypeOfInt( "
"nr ) == OT_STRING ) "
BREAK 
"thirdebene := nr; "
BREAK 
"else "
BREAK 
"thirdebene := element[firstebene][secondebene].keys()["
"nr]; "
BREAK 
"endif "
BREAK 
"layout := dataelementMenu.getprop( "
""LayoutSub_" + firstebene + "_" + secondebene + "_" + thirdebene ); "
BREAK 
"data := dataelementMenu.getprop( "
""DataSub_" + firstebene + "_" + secondebene + "_" + thirdebene ); "
BREAK 
"endif "
BREAK 
"FOURTHLIST: "
"ebene := FIFTHLIST; "
BREAK 
"if ( "
"TypeOfInt( "
"element[firstebene][secondebene][thirdebene] ) <> OT_DICTIONARY ) "
BREAK 
"fourthebene := nr; "
BREAK 
"tile := BuildItems( "
"layout, "
"data, "
"element[firstebene][secondebene][thirdebene][nr], "
"firstebene, "
"secondebene, "
"thirdebene ); "
BREAK 
"else "
BREAK 
"ebene := FIFTHLIST; "
BREAK 
"if ( "
"TypeOfInt( "
"nr ) == OT_STRING ) "
BREAK 
"fourthebene := nr; "
BREAK 
"else "
BREAK 
"fourthebene := element[firstebene][secondebene][thirdebene].keys()["
"nr]; "
BREAK 
"endif "
BREAK 
"layout := dataelementMenu.getprop( "
""LayoutSub_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene ); "
BREAK 
"data := dataelementMenu.getprop( "
""DataSub_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene ); "
BREAK 
"endif "
BREAK 
"FIFTHLIST: "
"ebene := ITEMLIST; "
BREAK 
"if ( "
"TypeOfInt( "
"element[firstebene][secondebene][thirdebene][fourthebene] ) <> OT_DICTIONARY ) "
BREAK 
"fifthebene := nr; "
BREAK 
"tile := BuildItems( "
"layout, "
"data, "
"element[firstebene][secondebene][thirdebene][fourthebene][nr], "
"firstebene, "
"secondebene, "
"thirdebene, "
"fourthebene ); "
BREAK 
"else "
BREAK 
"ebene := ITEMLIST; "
BREAK 
"if ( "
"TypeOfInt( "
"nr ) == OT_STRING ) "
BREAK 
"fifthebene := nr; "
BREAK 
"else "
BREAK 
"fifthebene := element[firstebene][secondebene][thirdebene][fourthebene].keys()["
"nr]; "
BREAK 
"endif "
BREAK 
"layout := dataelementMenu.getprop( "
""LayoutSub_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene ); "
BREAK 
"data := dataelementMenu.getprop( "
""DataSub_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene ); "
BREAK 
"endif "
BREAK 
"ITEMLIST: "
"ITEMLISTDUMMY: "
"ebene := ITEMLISTDUMMY; "
BREAK 
"if ( "
"TypeOfInt( "
"nr ) == OT_STRING ) "
BREAK 
"itemebene := nr; "
BREAK 
"else "
BREAK 
"itemebene := element[firstebene][secondebene][thirdebene][fourthebene][fifthebene][nr]; "
BREAK 
"endif "
BREAK 
"tile := BuildItems( "
"layout, "
"data, "
"element[firstebene][secondebene][thirdebene][fourthebene][fifthebene][nr], "
"firstebene, "
"secondebene, "
"thirdebene, "
"fourthebene, "
"fifthebene, "
"itemebene[1] ); "
BREAK 
"endcase "
BREAK 
"ret := SendDialogGump( "
"who, "
"layout, "
"data, "
"10, "
"50 ); "
BREAK 
"elseif ( "
"ret[BACKBUTTON] ) "
"// Back "
BREAK 
"ebene -= 2; "
"// 2 because one was added beforehand "
BREAK 
"if ( "
"ebene < 0 ) "
BREAK 
"ebene := ROOTLIST; "
BREAK 
"endif "
BREAK 
"case "
"( "
"ebene ) "
BREAK 
"ROOTLIST: "
"back := 1; "
BREAK 
"FIRSTLIST: "
"back := firstebene; "
BREAK 
"SECONDLIST: "
"back := secondebene; "
BREAK 
"THIRDLIST: "
"back := thirdebene; "
BREAK 
"FOURTHLIST: "
"back := fourthebene; "
BREAK 
"FIFTHLIST: "
"back := fifthebene; "
BREAK 
"ITEMLIST: "
"back := itemebene; "
BREAK 
"ITEMLISTDUMMY: "
"back := itemebene; "
BREAK 
"endcase "
BREAK 
"elseif ( "
"ret[ITEMCREATE] ) "
BREAK 
"ebene -= 1; "
BREAK 
"back := nr; "
"// So that there is no final lock loop with Create "
BREAK 
"color := ret[ITEMCOLOR]; "
BREAK 
"color[1, "
"6] := ""; "
BREAK 
"color := CInt( "
"color ); "
BREAK 
"case "
"( "
"tile[1][2] ) "
BREAK 
""Random": "
"CreateRandom( "
"who, "
"ret, "
"tile[2], "
"tile[3], "
"color, "
"tile[1][1] ); "
BREAK 
""Einzel": "
"CreateEinzel( "
"who, "
"ret, "
"tile[2], "
"color ); "
BREAK 
""Set": "
"CreateSet( "
"who, "
"ret, "
"tile[2], "
"color ); "
BREAK 
"default: "
"SendSysMessage( "
"who, "
""error..." ); "
BREAK 
"return; "
BREAK 
"endcase "
BREAK 
"elseif ( "
"ret[ITEMMODIFYMANUAL] ) "
BREAK 
"ModifyItemsManual( "
"who ); "
BREAK 
"back := 1; "
BREAK 
"ebene := ROOTLIST; "
BREAK 
"else "
BREAK 
"return; "
"// Winke "
BREAK 
"endif "
BREAK 
"endwhile "
BREAK 
"endfunction // }}} "
BREAK 
"function BuildItems( "
"byref layout, "
"byref data, "
"byref element, "
"firstebene, "
"secondebene := 0, "
"thirdebene := 0, "
"fourthebene := 0, "
"fifthebene := 0, "
"itemebene := 0 ) "
"// {{{ "
BREAK 
"var tiles := {}; "
BREAK 
"var tiles1 := {}; "
BREAK 
"var splittiles := {}; "
BREAK 
"if ( "
"itemebene ) "
BREAK 
"layout := dataelementMenu.getprop( "
""LayoutItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene + "_" + itemebene ); "
BREAK 
"data := dataelementMenu.getprop( "
""DataItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene + "_" + itemebene ); "
BREAK 
"elseif ( "
"fifthebene ) "
BREAK 
"layout := dataelementMenu.getprop( "
""LayoutItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene ); "
BREAK 
"data := dataelementMenu.getprop( "
""DataItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene ); "
BREAK 
"elseif ( "
"fourthebene ) "
BREAK 
"layout := dataelementMenu.getprop( "
""LayoutItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + element[1] ); "
BREAK 
"data := dataelementMenu.getprop( "
""DataItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + element[1] ); "
BREAK 
"elseif ( "
"thirdebene ) "
BREAK 
"layout := dataelementMenu.getprop( "
""LayoutItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + element[1] ); "
BREAK 
"data := dataelementMenu.getprop( "
""DataItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + element[1] ); "
BREAK 
"elseif ( "
"secondebene ) "
BREAK 
"layout := dataelementMenu.getprop( "
""LayoutItem_" + firstebene + "_" + secondebene + "_" + element[1] ); "
BREAK 
"data := dataelementMenu.getprop( "
""DataItem_" + firstebene + "_" + secondebene + "_" + element[1] ); "
BREAK 
"elseif ( "
"firstebene ) "
BREAK 
"layout := dataelementMenu.getprop( "
""LayoutItem_" + firstebene + "_" + element[1] ); "
BREAK 
"data := dataelementMenu.getprop( "
""DataItem_" + firstebene + "_" + element[1] ); "
BREAK 
"endif "
BREAK 
"case "
"( "
"element[2] ) "
BREAK 
""Random": "
"foreach tile in ( GetConfigStringArray( "
"cfgrandom[element[1]], "
""tile" ) ) "
BREAK 
"splittiles := SplitWords( "
"tile ); "
BREAK 
"tiles.append( "
"splittiles[1] ); "
BREAK 
"if ( "
"splittiles[2] ) "
BREAK 
"tiles1.append( "
"splittiles[2] ); "
BREAK 
"endif "
BREAK 
"endforeach "
BREAK 
""Einzel": "
"foreach tile in ( GetConfigStringArray( "
"cfgeinzel[element[1]], "
""tile" ) ) "
BREAK 
"if ( "
"!tiles ) "
BREAK 
"tiles := { "
"tile }; "
BREAK 
"else "
BREAK 
"tiles.append( "
"tile ); "
BREAK 
"endif "
BREAK 
"endforeach "
BREAK 
""Set": "
"tiles := element[1]; "
BREAK 
"endcase "
BREAK 
"return ( { "
"element, "
"tiles, "
"tiles1 } "
"); "
BREAK 
"endfunction // }}} "
BREAK 
"function CreateRandom( "
"who, "
"byref ret, "
"byref tiles, "
"byref tiles1, "
"byref color, "
"byref element ) "
"// {{{ "
BREAK 
"var tar1, tar2, item, x, y, z, Tarx, Tary, Tarx2, Tary2, itemdef, items := {}, "
"itemserials := {}; "
BREAK 
"SendSysMessage( "
"who, "
""Target first corner" ); "
BREAK 
"tar1 := TargetCoordinates( "
"who ); "
BREAK 
"if ( "
"tar1 ) "
BREAK 
"SendSysMessage( "
"who, "
""Target the second corner" ); "
BREAK 
"tar2 := TargetCoordinates( "
"who ); "
BREAK 
"if ( "
"tar2 ) "
BREAK 
"if ( "
"( tar1.item ) || "
"( tar2.item ) ) "
BREAK 
"if ( "
"( tar1.item.container ) || "
"( tar2.item.container ) ) "
BREAK 
"SendSysMessage( "
"who, "
""cancellation. Item in Container targeted!" ); "
BREAK 
"return; "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"if ( "
"tar1.x >= tar2.x ) "
"// Sorting the area "
BREAK 
"Tarx := tar2.x; "
BREAK 
"Tarx2 := tar1.x; "
BREAK 
"else "
BREAK 
"Tarx := tar1.x; "
BREAK 
"Tarx2 := tar2.x; "
BREAK 
"endif "
BREAK 
"if ( "
"tar1.y >= tar2.y ) "
BREAK 
"Tary := tar2.y; "
BREAK 
"Tary2 := tar1.y; "
BREAK 
"else "
BREAK 
"Tary := tar1.y; "
BREAK 
"Tary2 := tar2.y; "
BREAK 
"endif "
BREAK 
"if ( "
"( ( Tarx2 - Tarx ) > MAXAREASIZE ) || "
"( ( Tary2 - Tary ) > MAXAREASIZE ) ) "
BREAK 
"SendSysMessage( "
"who, "
""Cancellation.  " + MAXAREASIZE + "x" + MAXAREASIZE + " Generate items!" ); "
BREAK 
"return; "
BREAK 
"endif "
BREAK 
"z := ret[ITEMPOS]; "
BREAK 
"z[1, "
"6] := ""; "
BREAK 
"z := CInt( "
"z ); "
BREAK 
"if ( "
"GetConfigString( "
"cfgrandom[element], "
""x" ) ) "
BREAK 
"Tarx2 := Tarx + CInt( "
"GetConfigString( "
"cfgrandom[element], "
""x" ) ) - 1; "
BREAK 
"endif "
BREAK 
"if ( "
"GetConfigString( "
"cfgrandom[element], "
""y" ) ) "
BREAK 
"Tary2 := Tary + CInt( "
"GetConfigString( "
"cfgrandom[element], "
""y" ) ) - 1; "
BREAK 
"endif "
BREAK 
"if ( "
"ret[ITEMRAND] ) "
"// Random items are to be generated "
BREAK 
"for ( "
"x := Tarx; "
"x <= Tarx2; "
"x += 1 ) "
BREAK 
"for ( "
"y := Tary; "
"y <= Tary2; "
"y += 1 ) "
BREAK 
"if ( "
"( x == Tarx ) && "
"( y == Tary ) ) "
"// NW corner "
BREAK 
"itemdef := GetConfigString( "
"cfgrandom[element], "
""nw" ); "
BREAK 
"if ( "
"!itemdef ) "
BREAK 
"SendSysMessage( "
"who, "
""NW corner is missing." ); "
BREAK 
"else "
BREAK 
"itemdef := SplitWords( "
"itemdef ); "
BREAK 
"itemdef := ChooseRandom( "
"itemdef ); "
BREAK 
"itemdef := SplitWords( "
"itemdef, "
""," ); "
BREAK 
"item := CreateItemAtLocation( "
"x, "
"y, "
"tar1.z + CInt( "
"itemdef[2] ) + z, "
"CInt( "
"itemdef[1] ), "
"1, "
"who.realm ); "
BREAK 
"if ( "
"item ) "
BREAK 
"item.color := color; "
BREAK 
"item.movable := 0; "
BREAK 
"items.append( "
"item ); "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Create Error!  " + x + " " + y + " " + ( tar1.z + CInt( "
"itemdef[2] ) + z ) + " " + Hex( "
"itemdef[1] ) + " ErrorText: " + item.errortext ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"itemdef := GetConfigString( "
"cfgrandom[element], "
""nw1" ); "
BREAK 
"if ( "
"( itemdef ) && "
"( itemdef <> {} "
") ) "
BREAK 
"itemdef := SplitWords( "
"itemdef ); "
BREAK 
"itemdef := ChooseRandom( "
"itemdef ); "
BREAK 
"itemdef := SplitWords( "
"itemdef, "
""," ); "
BREAK 
"item := CreateItemAtLocation( "
"x, "
"y, "
"tar1.z + CInt( "
"itemdef[2] ) + z, "
"CInt( "
"itemdef[1] ), "
"1, "
"who.realm ); "
BREAK 
"if ( "
"item ) "
BREAK 
"item.color := color; "
BREAK 
"item.movable := 0; "
BREAK 
"items.append( "
"item ); "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Create error! NW-Corner 2nd item" + x + " " + y + " " + ( tar1.z + CInt( "
"itemdef[2] ) + z ) + " " + Hex( "
"itemdef[1] ) + " ErrorText: " + item.errortext ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"elseif ( "
"( x == Tarx2 ) && "
"( y == Tary ) ) "
"// NE corner "
BREAK 
"itemdef := GetConfigString( "
"cfgrandom[element], "
""no" ); "
BREAK 
"if ( "
"!itemdef ) "
BREAK 
"SendSysMessage( "
"who, "
""NE corner missing." ); "
BREAK 
"else "
BREAK 
"itemdef := SplitWords( "
"itemdef ); "
BREAK 
"itemdef := ChooseRandom( "
"itemdef ); "
BREAK 
"itemdef := SplitWords( "
"itemdef, "
""," ); "
BREAK 
"item := CreateItemAtLocation( "
"x, "
"y, "
"tar1.z + CInt( "
"itemdef[2] ) + z, "
"CInt( "
"itemdef[1] ), "
"1, "
"who.realm ); "
BREAK 
"if ( "
"item ) "
BREAK 
"item.color := color; "
BREAK 
"item.movable := 0; "
BREAK 
"items.append( "
"item ); "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Create error! NE-corner Item " + x + " " + y + " " + ( tar1.z + CInt( "
"itemdef[2] ) + z ) + " " + Hex( "
"itemdef[1] ) + " ErrorText: " + item.errortext ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"itemdef := GetConfigString( "
"cfgrandom[element], "
""no1" ); "
BREAK 
"if ( "
"( itemdef ) && "
"( itemdef <> {} "
") ) "
BREAK 
"itemdef := SplitWords( "
"itemdef ); "
BREAK 
"itemdef := ChooseRandom( "
"itemdef ); "
BREAK 
"itemdef := SplitWords( "
"itemdef, "
""," ); "
BREAK 
"item := CreateItemAtLocation( "
"x, "
"y, "
"tar1.z + CInt( "
"itemdef[2] ) + z, "
"CInt( "
"itemdef[1] ), "
"1, "
"who.realm ); "
BREAK 
"if ( "
"item ) "
BREAK 
"item.color := color; "
BREAK 
"item.movable := 0; "
BREAK 
"items.append( "
"item ); "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Create error! NE-Corner 2nd item " + x + " " + y + " " + ( tar1.z + CInt( "
"itemdef[2] ) + z ) + " " + Hex( "
"itemdef[1] ) + " ErrorText: " + item.errortext ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"elseif ( "
"( x == Tarx2 ) && "
"( y == Tary2 ) ) "
"// SE corner "
BREAK 
"itemdef := GetConfigString( "
"cfgrandom[element], "
""so" ); "
BREAK 
"if ( "
"!itemdef ) "
BREAK 
"SendSysMessage( "
"who, "
""SE-Corner is missing." ); "
BREAK 
"else "
BREAK 
"itemdef := SplitWords( "
"itemdef ); "
BREAK 
"itemdef := ChooseRandom( "
"itemdef ); "
BREAK 
"itemdef := SplitWords( "
"itemdef, "
""," ); "
BREAK 
"item := CreateItemAtLocation( "
"x, "
"y, "
"tar1.z + CInt( "
"itemdef[2] ) + z, "
"CInt( "
"itemdef[1] ), "
"1, "
"who.realm ); "
BREAK 
"if ( "
"item ) "
BREAK 
"item.color := color; "
BREAK 
"item.movable := 0; "
BREAK 
"items.append( "
"item ); "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Create error! SO-Ecke Item " + x + " " + y + " " + ( tar1.z + CInt( "
"itemdef[2] ) + z ) + " " + Hex( "
"itemdef[1] ) + " ErrorText: " + item.errortext ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"itemdef := GetConfigString( "
"cfgrandom[element], "
""so1" ); "
BREAK 
"if ( "
"( itemdef ) && "
"( itemdef <> {} "
") ) "
BREAK 
"itemdef := SplitWords( "
"itemdef ); "
BREAK 
"itemdef := ChooseRandom( "
"itemdef ); "
BREAK 
"itemdef := SplitWords( "
"itemdef, "
""," ); "
BREAK 
"item := CreateItemAtLocation( "
"x, "
"y, "
"tar1.z + CInt( "
"itemdef[2] ) + z, "
"CInt( "
"itemdef[1] ), "
"1, "
"who.realm ); "
BREAK 
"if ( "
"item ) "
BREAK 
"item.color := color; "
BREAK 
"item.movable := 0; "
BREAK 
"items.append( "
"item ); "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Create error! SE-Corner 2nd item " + x + " " + y + " " + ( tar1.z + CInt( "
"itemdef[2] ) + z ) + " " + Hex( "
"itemdef[1] ) + " ErrorText: " + item.errortext ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"elseif ( "
"( x == Tarx ) && "
"( y == Tary2 ) ) "
"// SW corner "
BREAK 
"itemdef := GetConfigString( "
"cfgrandom[element], "
""sw" ); "
BREAK 
"if ( "
"!itemdef ) "
BREAK 
"SendSysMessage( "
"who, "
""SW-Corner is missing." ); "
BREAK 
"else "
BREAK 
"itemdef := SplitWords( "
"itemdef ); "
BREAK 
"itemdef := ChooseRandom( "
"itemdef ); "
BREAK 
"itemdef := SplitWords( "
"itemdef, "
""," ); "
BREAK 
"item := CreateItemAtLocation( "
"x, "
"y, "
"tar1.z + CInt( "
"itemdef[2] ) + z, "
"CInt( "
"itemdef[1] ), "
"1, "
"who.realm ); "
BREAK 
"if ( "
"item ) "
BREAK 
"item.color := color; "
BREAK 
"item.movable := 0; "
BREAK 
"items.append( "
"item ); "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Create error! SW-corner Item " + x + " " + y + " " + ( tar1.z + CInt( "
"itemdef[2] ) + z ) + " " + Hex( "
"itemdef[1] ) + " ErrorText: " + item.errortext ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"itemdef := GetConfigString( "
"cfgrandom[element], "
""sw1" ); "
BREAK 
"if ( "
"( itemdef ) && "
"( itemdef <> {} "
") ) "
BREAK 
"itemdef := SplitWords( "
"itemdef ); "
BREAK 
"itemdef := ChooseRandom( "
"itemdef ); "
BREAK 
"itemdef := SplitWords( "
"itemdef, "
""," ); "
BREAK 
"item := CreateItemAtLocation( "
"x, "
"y, "
"tar1.z + CInt( "
"itemdef[2] ) + z, "
"CInt( "
"itemdef[1] ), "
"1, "
"who.realm ); "
BREAK 
"if ( "
"item ) "
BREAK 
"item.color := color; "
BREAK 
"item.movable := 0; "
BREAK 
"items.append( "
"item ); "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Create error! SW-Corner 2nd item " + x + " " + y + " " + ( tar1.z + CInt( "
"itemdef[2] ) + z ) + " " + Hex( "
"itemdef[1] ) + " ErrorText: " + item.errortext ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"elseif ( "
"y == Tary ) "
"// N page "
BREAK 
"itemdef := GetConfigString( "
"cfgrandom[element], "
""n" ); "
BREAK 
"if ( "
"!itemdef ) "
BREAK 
"SendSysMessage( "
"who, "
""N-Page is missing." ); "
BREAK 
"else "
BREAK 
"itemdef := SplitWords( "
"itemdef ); "
BREAK 
"itemdef := ChooseRandom( "
"itemdef ); "
BREAK 
"itemdef := SplitWords( "
"itemdef, "
""," ); "
BREAK 
"item := CreateItemAtLocation( "
"x, "
"y, "
"tar1.z + CInt( "
"itemdef[2] ) + z, "
"CInt( "
"itemdef[1] ), "
"1, "
"who.realm ); "
BREAK 
"if ( "
"item ) "
BREAK 
"item.color := color; "
BREAK 
"item.movable := 0; "
BREAK 
"items.append( "
"item ); "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Create error! N-Item page " + x + " " + y + " " + ( tar1.z + CInt( "
"itemdef[2] ) + z ) + " " + Hex( "
"itemdef[1] ) + " ErrorText: " + item.errortext ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"itemdef := GetConfigString( "
"cfgrandom[element], "
""n1" ); "
BREAK 
"if ( "
"( itemdef ) && "
"( itemdef <> {} "
") ) "
BREAK 
"itemdef := SplitWords( "
"itemdef ); "
BREAK 
"itemdef := ChooseRandom( "
"itemdef ); "
BREAK 
"itemdef := SplitWords( "
"itemdef, "
""," ); "
BREAK 
"item := CreateItemAtLocation( "
"x, "
"y, "
"tar1.z + CInt( "
"itemdef[2] ) + z, "
"CInt( "
"itemdef[1] ), "
"1, "
"who.realm ); "
BREAK 
"if ( "
"item ) "
BREAK 
"item.color := color; "
BREAK 
"item.movable := 0; "
BREAK 
"items.append( "
"item ); "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Create error! N-Page 2nd item " + x + " " + y + " " + ( tar1.z + CInt( "
"itemdef[2] ) + z ) + " " + Hex( "
"itemdef[1] ) + " ErrorText: " + item.errortext ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"elseif ( "
"x == Tarx2 ) "
"// E side "
BREAK 
"itemdef := GetConfigString( "
"cfgrandom[element], "
""o" ); "
BREAK 
"if ( "
"!itemdef ) "
BREAK 
"SendSysMessage( "
"who, "
""E-side is missing." ); "
BREAK 
"else "
BREAK 
"itemdef := SplitWords( "
"itemdef ); "
BREAK 
"itemdef := ChooseRandom( "
"itemdef ); "
BREAK 
"itemdef := SplitWords( "
"itemdef, "
""," ); "
BREAK 
"item := CreateItemAtLocation( "
"x, "
"y, "
"tar1.z + CInt( "
"itemdef[2] ) + z, "
"CInt( "
"itemdef[1] ), "
"1, "
"who.realm ); "
BREAK 
"if ( "
"item ) "
BREAK 
"item.color := color; "
BREAK 
"item.movable := 0; "
BREAK 
"items.append( "
"item ); "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Create error! E-side item " + x + " " + y + " " + ( tar1.z + CInt( "
"itemdef[2] ) + z ) + " " + Hex( "
"itemdef[1] ) + " ErrorText: " + item.errortext ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"itemdef := GetConfigString( "
"cfgrandom[element], "
""o1" ); "
BREAK 
"if ( "
"( itemdef ) && "
"( itemdef <> {} "
") ) "
BREAK 
"itemdef := SplitWords( "
"itemdef ); "
BREAK 
"itemdef := ChooseRandom( "
"itemdef ); "
BREAK 
"itemdef := SplitWords( "
"itemdef, "
""," ); "
BREAK 
"item := CreateItemAtLocation( "
"x, "
"y, "
"tar1.z + CInt( "
"itemdef[2] ) + z, "
"CInt( "
"itemdef[1] ), "
"1, "
"who.realm ); "
BREAK 
"if ( "
"item ) "
BREAK 
"item.color := color; "
BREAK 
"item.movable := 0; "
BREAK 
"items.append( "
"item ); "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Create error! E-side 2nd item " + x + " " + y + " " + ( tar1.z + CInt( "
"itemdef[2] ) + z ) + " " + Hex( "
"itemdef[1] ) + " ErrorText: " + item.errortext ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"elseif ( "
"y == Tary2 ) "
"// S side "
BREAK 
"itemdef := GetConfigString( "
"cfgrandom[element], "
""s" ); "
BREAK 
"if ( "
"!itemdef ) "
BREAK 
"SendSysMessage( "
"who, "
""S side is missing." ); "
BREAK 
"else "
BREAK 
"itemdef := SplitWords( "
"itemdef ); "
BREAK 
"itemdef := ChooseRandom( "
"itemdef ); "
BREAK 
"itemdef := SplitWords( "
"itemdef, "
""," ); "
BREAK 
"item := CreateItemAtLocation( "
"x, "
"y, "
"tar1.z + CInt( "
"itemdef[2] ) + z, "
"CInt( "
"itemdef[1] ), "
"1, "
"who.realm ); "
BREAK 
"if ( "
"item ) "
BREAK 
"item.color := color; "
BREAK 
"item.movable := 0; "
BREAK 
"items.append( "
"item ); "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Create error! S-Item page " + x + " " + y + " " + ( tar1.z + CInt( "
"itemdef[2] ) + z ) + " " + Hex( "
"itemdef[1] ) + " ErrorText: " + item.errortext ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"itemdef := GetConfigString( "
"cfgrandom[element], "
""s1" ); "
BREAK 
"if ( "
"( itemdef ) && "
"( itemdef <> {} "
") ) "
BREAK 
"itemdef := SplitWords( "
"itemdef ); "
BREAK 
"itemdef := ChooseRandom( "
"itemdef ); "
BREAK 
"itemdef := SplitWords( "
"itemdef, "
""," ); "
BREAK 
"item := CreateItemAtLocation( "
"x, "
"y, "
"tar1.z + CInt( "
"itemdef[2] ) + z, "
"CInt( "
"itemdef[1] ), "
"1, "
"who.realm ); "
BREAK 
"if ( "
"item ) "
BREAK 
"item.color := color; "
BREAK 
"item.movable := 0; "
BREAK 
"items.append( "
"item ); "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Create error! S-side 2nd item " + x + " " + y + " " + ( tar1.z + CInt( "
"itemdef[2] ) + z ) + " " + Hex( "
"itemdef[1] ) + " ErrorText: " + item.errortext ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"elseif ( "
"x == Tarx ) "
"// W page "
BREAK 
"itemdef := GetConfigString( "
"cfgrandom[element], "
""w" ); "
BREAK 
"if ( "
"!itemdef ) "
BREAK 
"SendSysMessage( "
"who, "
""W-Page is missing." ); "
BREAK 
"else "
BREAK 
"itemdef := SplitWords( "
"itemdef ); "
BREAK 
"itemdef := ChooseRandom( "
"itemdef ); "
BREAK 
"itemdef := SplitWords( "
"itemdef, "
""," ); "
BREAK 
"item := CreateItemAtLocation( "
"x, "
"y, "
"tar1.z + CInt( "
"itemdef[2] ) + z, "
"CInt( "
"itemdef[1] ), "
"1, "
"who.realm ); "
BREAK 
"if ( "
"item ) "
BREAK 
"item.color := color; "
BREAK 
"item.movable := 0; "
BREAK 
"items.append( "
"item ); "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Create error! W side item " + x + " " + y + " " + ( tar1.z + CInt( "
"itemdef[2] ) + z ) + " " + Hex( "
"itemdef[1] ) + " ErrorText: " + item.errortext ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"itemdef := GetConfigString( "
"cfgrandom[element], "
""w1" ); "
BREAK 
"if ( "
"( itemdef ) && "
"( itemdef <> {} "
") ) "
BREAK 
"itemdef := SplitWords( "
"itemdef ); "
BREAK 
"itemdef := ChooseRandom( "
"itemdef ); "
BREAK 
"itemdef := SplitWords( "
"itemdef, "
""," ); "
BREAK 
"item := CreateItemAtLocation( "
"x, "
"y, "
"tar1.z + CInt( "
"itemdef[2] ) + z, "
"CInt( "
"itemdef[1] ), "
"1, "
"who.realm ); "
BREAK 
"if ( "
"item ) "
BREAK 
"item.color := color; "
BREAK 
"item.movable := 0; "
BREAK 
"items.append( "
"item ); "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Create error! W-Page 2nd item " + x + " " + y + " " + ( tar1.z + CInt( "
"itemdef[2] ) + z ) + " " + Hex( "
"itemdef[1] ) + " ErrorText: " + item.errortext ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"else // centerpiece "
BREAK 
"itemdef := ChooseRandom( "
"tiles ); "
BREAK 
"if ( "
"!itemdef ) "
BREAK 
"SendSysMessage( "
"who, "
""Middle piece is missing." ); "
BREAK 
"else "
BREAK 
"itemdef := SplitWords( "
"itemdef, "
""," ); "
BREAK 
"item := CreateItemAtLocation( "
"x, "
"y, "
"tar1.z + CInt( "
"itemdef[2] ) + z, "
"CInt( "
"itemdef[1] ), "
"1, "
"who.realm ); "
BREAK 
"if ( "
"item ) "
BREAK 
"item.color := color; "
BREAK 
"item.movable := 0; "
BREAK 
"items.append( "
"item ); "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Create error! Midsection item " + x + " " + y + " " + ( tar1.z + CInt( "
"itemdef[2] ) + z ) + " " + Hex( "
"itemdef[1] ) + " ErrorText: " + item.errortext ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"itemdef := tiles1.randomentry(); "
BREAK 
"if ( "
"( itemdef ) && "
"( itemdef <> {} "
") ) "
BREAK 
"itemdef := SplitWords( "
"itemdef, "
""," ); "
BREAK 
"item := CreateItemAtLocation( "
"x, "
"y, "
"tar1.z + CInt( "
"itemdef[2] ) + z, "
"CInt( "
"itemdef[1] ), "
"1, "
"who.realm ); "
BREAK 
"if ( "
"item ) "
BREAK 
"item.color := color; "
BREAK 
"item.movable := 0; "
BREAK 
"items.append( "
"item ); "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Create error! Middle part 2nd item " + x + " " + y + " " + ( tar1.z + CInt( "
"itemdef[2] ) + z ) + " " + Hex( "
"itemdef[1] ) + " ErrorText: " + item.errortext ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"SleepMS( "
"5 ); "
BREAK 
"endfor "
BREAK 
"endfor "
BREAK 
"else // Boring version without a border "
BREAK 
"for ( "
"x := Tarx; "
"x <= Tarx2; "
"x += 1 ) "
BREAK 
"for ( "
"y := Tary; "
"y <= Tary2; "
"y += 1 ) "
BREAK 
"itemdef := ChooseRandom( "
"tiles ); "
BREAK 
"if ( "
"!itemdef ) "
BREAK 
"SendSysMessage( "
"who, "
""Middle piece is missing." ); "
BREAK 
"else "
BREAK 
"itemdef := SplitWords( "
"itemdef, "
""," ); "
BREAK 
"item := CreateItemAtLocation( "
"x, "
"y, "
"tar1.z + CInt( "
"itemdef[2] ) + z, "
"CInt( "
"itemdef[1] ), "
"1, "
"who.realm ); "
BREAK 
"if ( "
"item ) "
BREAK 
"item.color := color; "
BREAK 
"item.movable := 0; "
BREAK 
"items.append( "
"item ); "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Create error! Item " + x + " " + y + " " + ( tar1.z + CInt( "
"itemdef[2] ) + z ) + " " + Hex( "
"itemdef[1] ) + " ErrorText: " + item.errortext ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"itemdef := tiles1.randomentry(); "
BREAK 
"if ( "
"( itemdef ) && "
"( itemdef <> {} "
") ) "
BREAK 
"itemdef := SplitWords( "
"itemdef, "
""," ); "
BREAK 
"item := CreateItemAtLocation( "
"x, "
"y, "
"tar1.z + CInt( "
"itemdef[2] ) + z, "
"CInt( "
"itemdef[1] ), "
"1, "
"who.realm ); "
BREAK 
"if ( "
"item ) "
BREAK 
"item.color := color; "
BREAK 
"item.movable := 0; "
BREAK 
"items.append( "
"item ); "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Create error! 2nd Item " + x + " " + y + " " + ( tar1.z + CInt( "
"itemdef[2] ) + z ) + " " + Hex( "
"itemdef[1] ) + " ErrorText: " + item.errortext ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"SleepMS( "
"5 ); "
BREAK 
"endfor "
BREAK 
"endfor "
BREAK 
"endif "
BREAK 
"foreach item in ( items ) "
BREAK 
"item.setprop( "
"CPROP_INIT, "
"items[1].serial ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"foreach item in ( items ) "
BREAK 
"itemserials.append( "
"item.serial ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"items[1].setprop( "
"CPROP_ITEMS, "
"itemserials ); "
BREAK 
"if ( "
"ret[ITEMMODIFY] ) "
"// Change position "
BREAK 
"if ( "
"!ModifyItems( "
"who, "
"items ) ) "
BREAK 
"return; "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Abort" ); "
BREAK 
"endif "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Abort" ); "
BREAK 
"endif "
BREAK 
"endfunction // }}} "
BREAK 
"function CreateEinzel( "
"who, "
"byref ret, "
"byref tiles, "
"byref color ) "
"// {{{ "
BREAK 
"var z, itemdef := {}, "
"iTarget, item, items := {}, "
"itemserials := {}; "
BREAK 
"if ( "
"!tiles[ret.keys[2]] ) "
BREAK 
"SendSysMessage( "
"who, "
""No item selected" ); "
BREAK 
"return; "
BREAK 
"endif "
BREAK 
"SendSysMessage( "
"who, "
""Target position" ); "
BREAK 
"z := ret[ITEMPOS]; "
BREAK 
"z[1, "
"6] := ""; "
BREAK 
"z := CInt( "
"z ); "
BREAK 
"itemdef[1] := CInt( "
"SplitWords( "
"tiles[ret.keys[2]], "
""," )[1] ); "
"// Objtype "
BREAK 
"itemdef[2] := CInt( "
"SplitWords( "
"tiles[ret.keys[2]], "
""," )[2] ); "
"// Feste z-Koords "
BREAK 
"iTarget := TargetCoordinates( "
"who ); "
BREAK 
"if ( "
"iTarget.item ) "
BREAK 
"if ( "
"iTarget.item.container ) "
BREAK 
"SendSysMessage( "
"who, "
""cancellation. Item in Container targeted!" ); "
BREAK 
"return; "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"while ( "
"iTarget ) // Endless to ESC "
BREAK 
"item := CreateItemAtLocation( "
"iTarget.x, "
"iTarget.y, "
"iTarget.z + itemdef[2] + z, "
"itemdef[1], "
"1, "
"who.realm ); "
BREAK 
"if ( "
"item ) "
BREAK 
"item.color := color; "
BREAK 
"item.movable := 0; "
BREAK 
"if ( "
"!ret[ITEMMMULTICREATE] ) "
BREAK 
"item.setprop( "
"CPROP_INIT, "
"item.serial ); "
BREAK 
"item.setprop( "
"CPROP_ITEMS, "
"{ "
"item.serial } "
"); "
BREAK 
"if ( "
"ret[ITEMMODIFY] ) "
"// Change position "
BREAK 
"if ( "
"!ModifyItems( "
"who, "
"item ) ) "
BREAK 
"SendSysMessage( "
"who, "
""Abort" ); "
BREAK 
"return; "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"else "
BREAK 
"items.append( "
"item ); "
BREAK 
"endif "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Create error! Item " + iTarget.x + " " + iTarget.y + " " + ( iTarget.z + itemdef[2] + z ) + " " + Hex( "
"tiles[ret.keys[2]] ) + " ErrorText: " + item.errortext ); "
BREAK 
"endif "
BREAK 
"iTarget := TargetCoordinates( "
"who ); "
BREAK 
"endwhile "
BREAK 
"if ( "
"ret[ITEMMMULTICREATE] ) "
BREAK 
"foreach item in ( items ) "
BREAK 
"item.setprop( "
"CPROP_INIT, "
"items[1].serial ); "
BREAK 
"endforeach "
BREAK 
"foreach item in ( items ) "
BREAK 
"itemserials.append( "
"item.serial ); "
BREAK 
"endforeach "
BREAK 
"items[1].setprop( "
"CPROP_ITEMS, "
"itemserials ); "
BREAK 
"if ( "
"ret[ITEMMODIFY] ) "
"// Postion to change "
BREAK 
"ModifyItems( "
"who, "
"items ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"SendSysMessage( "
"who, "
""Abort" ); "
BREAK 
"endfunction // }}} "
BREAK 
"function CreateSet( "
"unused who, "
"byref unused ret, "
"byref unused set, "
"byref unused color ) "
BREAK 
"endfunction "
BREAK 
"function ModifyItemsManual( "
"who ) "
"// {{{ "
BREAK 
"var retmodify, tar, inititem, items := {}, "
"itemserials := {}, "
"color, zstart, zend, temp, i, obj, tempitems := {}; "
BREAK 
"var tar1, tar2, x1, x2, y1, y2, breakflag; "
BREAK 
"var dupe := {}, "
"dupeitem, dupeserials := {}; "
BREAK 
"while ( "
"who.connected ) "
BREAK 
"if ( "
"items <> {} "
") "
BREAK 
"datamodify_M[COLORDATAPOS] := items[1].color; "
BREAK 
"datamodify_M[XKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>" + items[1].x + "</p></basefont>"; "
BREAK 
"datamodify_M[YKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>" + items[1].y + "</p></basefont>"; "
BREAK 
"datamodify_M[ZKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>" + items[1].z + "</p></basefont>"; "
BREAK 
"datamodify_M[XENTRY] := items[1].x; "
BREAK 
"datamodify_M[YENTRY] := items[1].y; "
BREAK 
"datamodify_M[ZENTRY] := items[1].z; "
BREAK 
"else "
BREAK 
"datamodify_M[COLORDATAPOS] := "0"; "
BREAK 
"datamodify_M[XKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>x</p></basefont>"; "
BREAK 
"datamodify_M[YKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>y</p></basefont>"; "
BREAK 
"datamodify_M[ZKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>z</p></basefont>"; "
BREAK 
"datamodify_M[XENTRY] := 0; "
BREAK 
"datamodify_M[YENTRY] := 0; "
BREAK 
"datamodify_M[ZENTRY] := 0; "
BREAK 
"endif "
BREAK 
"retmodify := SendDialogGump( "
"who, "
"layoutmodify_M, "
"datamodify_M, "
"10, "
"50 ); "
BREAK 
"if ( "
"retmodify[MODIFY_START] ) "
BREAK 
"if ( "
"!retmodify[MODIFY_CUSTOM] ) "
"// Search for .bautool items "
BREAK 
"tar := Target( "
"who, "
"TGTOPT_NOCHECK_LOS ); "
BREAK 
"if ( "
"tar ) "
BREAK 
"if ( "
"( !tar.getprop( "
"CPROP_ITEMS ) ) && "
"( tar.getprop( "
"CPROP_INIT ) ) ) "
BREAK 
"inititem := SystemFindObjectBySerial( "
"tar.getprop( "
"CPROP_INIT ) ); "
BREAK 
"if ( "
"inititem ) "
BREAK 
"itemserials := inititem.getprop( "
"CPROP_ITEMS ); "
BREAK 
"items := {}; "
BREAK 
"tempitems := {}; "
BREAK 
"foreach item in ( itemserials ) "
BREAK 
"obj := SystemFindObjectBySerial( "
"item ); "
BREAK 
"if ( "
"obj ) "
BREAK 
"if ( "
"CInt( "
"obj.getprop( "
"CPROP_INIT ) ) == CInt( "
"inititem.serial ) ) "
"// it belongs to the same group "
BREAK 
"items.append( "
"obj ); "
BREAK 
"tempitems.append( "
"obj.serial ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"SleepMS( "
"5 ); "
BREAK 
"endforeach "
BREAK 
"inititem.setprop( "
"CPROP_ITEMS, "
"tempitems ); "
"// save filtered serials "
BREAK 
"if ( "
"( !items ) || "
"( items == {} "
") ) "
BREAK 
"SendSysMessage( "
"who, "
""Items could not be found. " ); "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
"items.size() "
"+ " Items recognized." ); "
BREAK 
"endif "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Init item not found. " ); "
BREAK 
"items := RecoverInitItem( "
"tar ); "
BREAK 
"endif "
BREAK 
"elseif ( "
"tar.getprop( "
"CPROP_ITEMS ) ) "
BREAK 
"itemserials := tar.getprop( "
"CPROP_ITEMS ); "
BREAK 
"items := {}; "
BREAK 
"tempitems := {}; "
BREAK 
"foreach item in ( itemserials ) "
BREAK 
"obj := SystemFindObjectBySerial( "
"item ); "
BREAK 
"if ( "
"obj ) "
BREAK 
"if ( "
"CInt( "
"obj.getprop( "
"CPROP_INIT ) ) == CInt( "
"tar.serial ) ) "
"// it belongs to the same group "
BREAK 
"items.append( "
"obj ); "
BREAK 
"tempitems.append( "
"obj.serial ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"SleepMS( "
"5 ); "
BREAK 
"endforeach "
BREAK 
"tar.setprop( "
"CPROP_ITEMS, "
"tempitems ); "
"// save filtered serials "
BREAK 
"SendSysMessage( "
"who, "
"items.size() "
"+ " Items recognized." ); "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Invalid Item selected." ); "
BREAK 
"endif "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Abort" ); "
BREAK 
"items := {}; "
BREAK 
"endif "
BREAK 
"else // Search for any items "
BREAK 
"zstart := retmodify[MODIFY_Z_START]; "
BREAK 
"zstart[1, "
"6] := ""; "
BREAK 
"zstart := CInt( "
"zstart ); "
BREAK 
"zend := retmodify[MODIFY_Z_END]; "
BREAK 
"zend[1, "
"6] := ""; "
BREAK 
"zend := CInt( "
"zend ); "
BREAK 
"datamodify_M[ZSTARTPOS] := zstart; "
BREAK 
"datamodify_M[ZENDPOS] := zend; "
BREAK 
"SendSysMessage( "
"who, "
""Target the first corner of the area" ); "
BREAK 
"tar1 := TargetCoordinates( "
"who ); "
BREAK 
"if ( "
"tar1 ) "
BREAK 
"SendSysMessage( "
"who, "
""Target the second corner of the area" ); "
BREAK 
"tar2 := TargetCoordinates( "
"who ); "
BREAK 
"if ( "
"tar2 ) "
BREAK 
"if ( "
"tar1.x > tar2.x ) "
"// Sorting the area "
BREAK 
"x1 := tar2.x; "
BREAK 
"x2 := tar1.x; "
BREAK 
"else "
BREAK 
"x1 := tar1.x; "
BREAK 
"x2 := tar2.x; "
BREAK 
"endif "
BREAK 
"if ( "
"tar1.y > tar2.y ) "
BREAK 
"y1 := tar2.y; "
BREAK 
"y2 := tar1.y; "
BREAK 
"else "
BREAK 
"y1 := tar1.y; "
BREAK 
"y2 := tar2.y; "
BREAK 
"endif "
BREAK 
"items := {}; "
BREAK 
"foreach item in ( ListObjectsInBox( "
"x1, "
"y1, "
"zstart, "
"x2, "
"y2, "
"zend, "
"tar2.realm ) ) "
BREAK 
"if ( "
"item.isA( "
"POLCLASS_ITEM ) ) "
BREAK 
"if ( "
"!item.invisible ) "
"// Don't take invisible stuff like spawn runes "
BREAK 
"items.append( "
"item ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"SleepMS( "
"5 ); "
BREAK 
"endforeach "
BREAK 
"if ( "
"items <> {} "
") "
BREAK 
"SendSysMessage( "
"who, "
"items.size() "
"+ " Items recognized." ); "
BREAK 
"if ( "
"retmodify[MODIFY_MARK] ) "
BREAK 
"itemserials := {}; "
BREAK 
"foreach item in ( items ) "
BREAK 
"itemserials.append( "
"item.serial ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"SendSysMessage( "
"who, "
""Choose the original item." ); "
BREAK 
"breakflag := 0; "
BREAK 
"while ( "
"who.connected ) "
BREAK 
"tar := Target( "
"who, "
"TGTOPT_NOCHECK_LOS ); "
BREAK 
"if ( "
"tar ) "
BREAK 
"i := tar.serial in itemserials; "
BREAK 
"if ( "
"i ) "
"// Move the selected item to the first position "
BREAK 
"temp := itemserials[1]; "
BREAK 
"itemserials[i] := temp; "
BREAK 
"itemserials[1] := tar.serial; "
BREAK 
"foreach item in ( items ) "
BREAK 
"item.setprop( "
"CPROP_INIT, "
"tar.serial ); "
BREAK 
"item.eraseprop( "
"CPROP_ITEMS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"tar.setprop( "
"CPROP_ITEMS, "
"itemserials ); "
BREAK 
"break; "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Item is not among those recognized!" ); "
BREAK 
"endif "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Abort" ); "
BREAK 
"breakflag := 1; "
BREAK 
"break; "
BREAK 
"endif "
BREAK 
"endwhile "
BREAK 
"items := {}; "
BREAK 
"if ( "
"!breakflag ) "
BREAK 
"foreach item in ( itemserials ) // Reordering and final check "
BREAK 
"obj := SystemFindObjectBySerial( "
"item ); "
BREAK 
"if ( "
"obj ) "
BREAK 
"items.append( "
"obj ); "
BREAK 
"endif "
BREAK 
"SleepMS( "
"5 ); "
BREAK 
"endforeach "
BREAK 
"SendSysMessage( "
"who, "
"".. and branded." ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""No items recognized." ); "
BREAK 
"endif "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Abort" ); "
BREAK 
"items := {}; "
BREAK 
"endif "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Abort" ); "
BREAK 
"items := {}; "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"else "
BREAK 
"if ( "
"retmodify.keys[retmodify.keys.size()] "
"> MODIFY_START ) "
BREAK 
"if ( "
"items <> {} "
") "
BREAK 
"if ( "
"retmodify[MODIFY_Y_UP] ) "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x, "
"item.y + 1, "
"item.z, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_Y_DOWN] ) "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x, "
"item.y - 1, "
"item.z, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_X_UP] ) "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x + 1, "
"item.y, "
"item.z, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_X_DOWN] ) "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x - 1, "
"item.y, "
"item.z, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_XY_MM] ) "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x - 1, "
"item.y - 1, "
"item.z, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_XY_PM] ) "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x + 1, "
"item.y - 1, "
"item.z, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_XY_MP] ) "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x - 1, "
"item.y + 1, "
"item.z, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_XY_PP] ) "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x + 1, "
"item.y + 1, "
"item.z, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_Z_UP] ) "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x, "
"item.y, "
"item.z + 1, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_Z_DOWN] ) "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x, "
"item.y, "
"item.z - 1, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_DESTROY] ) "
BREAK 
"foreach item in ( items ) "
BREAK 
"DestroyItem( "
"item ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"items := {}; "
BREAK 
"elseif ( "
"retmodify[MODIFY_COLOR] ) "
BREAK 
"color := retmodify[ITEMCOLOR]; "
BREAK 
"color[1, "
"6] := ""; "
BREAK 
"color := CInt( "
"color ); "
BREAK 
"foreach item in ( items ) "
BREAK 
"item.color := color; "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_DUPE] ) "
BREAK 
"dupe := {}; "
BREAK 
"dupeserials := {}; "
BREAK 
"foreach item in ( items ) "
BREAK 
"dupeitem := CreateItemCopyAtLocation( "
"item.x, "
"item.y, "
"item.z, "
"item, "
"item.realm ); "
BREAK 
"if ( "
"dupeitem ) "
BREAK 
"dupe.append( "
"dupeitem ); "
BREAK 
"dupeserials.append( "
"dupeitem.serial ); "
BREAK 
"endif "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"foreach item in ( dupe ) "
BREAK 
"item.setprop( "
"CPROP_INIT, "
"dupeserials[1] ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"dupe[1].setprop( "
"CPROP_ITEMS, "
"dupeserials ); "
BREAK 
"SendSysMessage( "
"who, "
"dupe.size() "
"+ " Items successfully duplicated." ); "
BREAK 
"items := dupe; "
"// Continue working with a copy "
BREAK 
"elseif ( "
"retmodify[MODIFY_X] ) "
BREAK 
"temp := retmodify[MODIFY_X_ENTRY]; "
BREAK 
"temp[1, "
"6] := ""; "
BREAK 
"temp := CInt( "
"temp ) - items[1].x; "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x + temp, "
"item.y, "
"item.z, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_Y] ) "
BREAK 
"temp := retmodify[MODIFY_Y_ENTRY]; "
BREAK 
"temp[1, "
"6] := ""; "
BREAK 
"temp := CInt( "
"temp ) - items[1].y; "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x, "
"item.y + temp, "
"item.z, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_Z] ) "
BREAK 
"temp := retmodify[MODIFY_Z_ENTRY]; "
BREAK 
"temp[1, "
"6] := ""; "
BREAK 
"temp := CInt( "
"temp ) - items[1].z; "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x, "
"item.y, "
"item.z + temp, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"endif "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""No items selected." ); "
BREAK 
"endif "
BREAK 
"elseif ( "
"retmodify[MODIFY_MARKEDIT] ) "
BREAK 
"MarkEdit( "
"who ); "
BREAK 
"else // Gump closed "
BREAK 
"SendSysMessage( "
"who, "
""Abort" ); "
BREAK 
"break; "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"endwhile "
BREAK 
"endfunction // }}} "
BREAK 
"function MarkEdit( "
"who ) "
"// {{{ "
BREAK 
"var ret, tar1, tar2, x1, x2, y1, y2, items := {}, "
"itemref, inititem, itemserials, tempitems, obj, i; "
BREAK 
"while ( "
"who.connected ) "
BREAK 
"ret := SendDialogGump( "
"who, "
"layoutmark, "
"datamark, "
"10, "
"50 ); "
BREAK 
"if ( "
"ret[MARK_SHOW] ) "
BREAK 
"SendSysMessage( "
"who, "
""Target the first corner of the area" ); "
BREAK 
"tar1 := TargetCoordinates( "
"who ); "
BREAK 
"if ( "
"tar1 ) "
BREAK 
"SendSysMessage( "
"who, "
""Target the second corner of the area" ); "
BREAK 
"tar2 := TargetCoordinates( "
"who ); "
BREAK 
"if ( "
"tar2 ) "
BREAK 
"if ( "
"tar1.x > tar2.x ) "
"// Sorting the area "
BREAK 
"x1 := tar2.x; "
BREAK 
"x2 := tar1.x; "
BREAK 
"else "
BREAK 
"x1 := tar1.x; "
BREAK 
"x2 := tar2.x; "
BREAK 
"endif "
BREAK 
"if ( "
"tar1.y > tar2.y ) "
BREAK 
"y1 := tar2.y; "
BREAK 
"y2 := tar1.y; "
BREAK 
"else "
BREAK 
"y1 := tar1.y; "
BREAK 
"y2 := tar2.y; "
BREAK 
"endif "
BREAK 
"items := {}; "
BREAK 
"foreach item in ( ListObjectsInBox( "
"x1, "
"y1, "
"-127, "
"x2, "
"y2, "
"128, "
"tar2.realm ) ) // Items besorgen "
BREAK 
"if ( "
"item.isA( "
"POLCLASS_ITEM ) ) "
BREAK 
"if ( "
"item.getprop( "
"CPROP_ITEMS ) ) "
BREAK 
"items.append( "
"item ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"SleepMS( "
"5 ); "
BREAK 
"endforeach "
BREAK 
"if ( "
"items <> {} "
") "
BREAK 
"foreach item in ( items ) // Coloring by groups "
BREAK 
"foreach slaveitem in ( item.getprop( "
"CPROP_ITEMS ) ) "
BREAK 
"itemref := SystemFindObjectBySerial( "
"slaveitem ); "
BREAK 
"if ( "
"itemref ) "
BREAK 
"if ( "
"itemref.getprop( "
"CPROP_COLOR ).errortext ) "
BREAK 
"itemref.setprop( "
"CPROP_COLOR, "
"itemref.color ); "
BREAK 
"endif "
BREAK 
"itemref.color := _item_iter + 6; "
BREAK 
"endif "
BREAK 
"SleepMS( "
"5 ); "
BREAK 
"endforeach "
BREAK 
"endforeach "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"elseif ( "
"ret[MARK_HIDE] ) "
BREAK 
"SendSysMessage( "
"who, "
""Target the first corner of the area" ); "
BREAK 
"tar1 := TargetCoordinates( "
"who ); "
BREAK 
"if ( "
"tar1 ) "
BREAK 
"SendSysMessage( "
"who, "
""Target the second corner of the area" ); "
BREAK 
"tar2 := TargetCoordinates( "
"who ); "
BREAK 
"if ( "
"tar2 ) "
BREAK 
"if ( "
"tar1.x > tar2.x ) "
"// Sorting the area "
BREAK 
"x1 := tar2.x; "
BREAK 
"x2 := tar1.x; "
BREAK 
"else "
BREAK 
"x1 := tar1.x; "
BREAK 
"x2 := tar2.x; "
BREAK 
"endif "
BREAK 
"if ( "
"tar1.y > tar2.y ) "
BREAK 
"y1 := tar2.y; "
BREAK 
"y2 := tar1.y; "
BREAK 
"else "
BREAK 
"y1 := tar1.y; "
BREAK 
"y2 := tar2.y; "
BREAK 
"endif "
BREAK 
"items := {}; "
BREAK 
"foreach item in ( ListObjectsInBox( "
"x1, "
"y1, "
"-127, "
"x2, "
"y2, "
"128, "
"tar2.realm ) ) // Items besorgen "
BREAK 
"if ( "
"item.isA( "
"POLCLASS_ITEM ) ) "
BREAK 
"if ( "
"item.getprop( "
"CPROP_ITEMS ) ) "
BREAK 
"items.append( "
"item ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"SleepMS( "
"5 ); "
BREAK 
"endforeach "
BREAK 
"if ( "
"items <> {} "
") "
BREAK 
"foreach item in ( items ) // Coloring by groups "
BREAK 
"foreach slaveitem in ( item.getprop( "
"CPROP_ITEMS ) ) "
BREAK 
"itemref := SystemFindObjectBySerial( "
"slaveitem ); "
BREAK 
"if ( "
"itemref ) "
BREAK 
"if ( "
"itemref.getprop( "
"CPROP_COLOR ).errortext ) "
BREAK 
"itemref.setprop( "
"CPROP_COLOR, "
"itemref.color ); "
BREAK 
"endif "
BREAK 
"itemref.color := _item_iter + 6; "
BREAK 
"endif "
BREAK 
"SleepMS( "
"5 ); "
BREAK 
"endforeach "
BREAK 
"endforeach "
BREAK 
"endif "
BREAK 
"foreach item in ( ListObjectsInBox( "
"x1, "
"y1, "
"-128, "
"x2, "
"y2, "
"127, "
"tar2.realm ) ) // Freset work "
BREAK 
"if ( "
"item.isA( "
"POLCLASS_ITEM ) ) "
BREAK 
"if ( "
"( item.getprop( "
"CPROP_ITEMS ) ) && "
"( !item.getprop( "
"CPROP_COLOR ).errortext ) ) "
BREAK 
"foreach slaveitem in ( item.getprop( "
"CPROP_ITEMS ) ) "
BREAK 
"itemref := SystemFindObjectBySerial( "
"slaveitem ); "
BREAK 
"if ( "
"itemref ) "
BREAK 
"if ( "
"!itemref.getprop( "
"CPROP_COLOR ).errortext ) "
BREAK 
"itemref.color := CInt( "
"item.getprop( "
"CPROP_COLOR ) ); "
BREAK 
"itemref.eraseprop( "
"CPROP_COLOR ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"SleepMS( "
"5 ); "
BREAK 
"endforeach "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"SleepMS( "
"5 ); "
BREAK 
"endforeach "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"elseif ( "
"ret[MARK_EDIT] ) "
BREAK 
"SendSysMessage( "
"who, "
""Selects the item group." ); "
BREAK 
"tar1 := Target( "
"who, "
"TGTOPT_NOCHECK_LOS ); "
BREAK 
"items := {}; "
BREAK 
"tempitems := {}; "
BREAK 
"if ( "
"( !tar1.getprop( "
"CPROP_ITEMS ) ) && "
"( tar1.getprop( "
"CPROP_INIT ) ) ) "
BREAK 
"inititem := SystemFindObjectBySerial( "
"tar1.getprop( "
"CPROP_INIT ) ); "
BREAK 
"if ( "
"inititem ) "
BREAK 
"itemserials := inititem.getprop( "
"CPROP_ITEMS ); "
BREAK 
"foreach item in ( itemserials ) "
BREAK 
"obj := SystemFindObjectBySerial( "
"item ); "
BREAK 
"if ( "
"obj ) "
BREAK 
"if ( "
"( CInt( "
"obj.getprop( "
"CPROP_INIT ) ) == CInt( "
"inititem.serial ) ) && "
"( !( obj.serial in tempitems ) ) ) "
"// it belongs to the same group "
BREAK 
"items.append( "
"obj ); "
BREAK 
"tempitems.append( "
"obj.serial ); "
BREAK 
"if ( "
"obj.getprop( "
"CPROP_COLOR ).errortext ) "
BREAK 
"obj.setprop( "
"CPROP_COLOR, "
"obj.color ); "
BREAK 
"endif "
BREAK 
"obj.color := 1281; "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"SleepMS( "
"5 ); "
BREAK 
"endforeach "
BREAK 
"inititem.setprop( "
"CPROP_ITEMS, "
"tempitems ); "
"// save filtered serials "
BREAK 
"if ( "
"( !items ) || "
"( items == {} "
") ) "
BREAK 
"SendSysMessage( "
"who, "
""Items could not be found. " ); "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
"items.size() "
"+ " Items recognized." ); "
BREAK 
"endif "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""Init item not found. " ); "
BREAK 
"items := RecoverInitItem( "
"tar1 ); "
BREAK 
"endif "
BREAK 
"elseif ( "
"tar1.getprop( "
"CPROP_ITEMS ) ) "
BREAK 
"itemserials := tar1.getprop( "
"CPROP_ITEMS ); "
BREAK 
"foreach item in ( itemserials ) "
BREAK 
"obj := SystemFindObjectBySerial( "
"item ); "
BREAK 
"if ( "
"obj ) "
BREAK 
"if ( "
"CInt( "
"obj.getprop( "
"CPROP_INIT ) ) == CInt( "
"tar1.serial ) ) "
"// it belongs to the same group "
BREAK 
"items.append( "
"obj ); "
BREAK 
"tempitems.append( "
"obj.serial ); "
BREAK 
"if ( "
"obj.getprop( "
"CPROP_COLOR ).errortext ) "
BREAK 
"obj.setprop( "
"CPROP_COLOR, "
"obj.color ); "
BREAK 
"endif "
BREAK 
"obj.color := 1281; "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"SleepMS( "
"5 ); "
BREAK 
"endforeach "
BREAK 
"tar1.setprop( "
"CPROP_ITEMS, "
"tempitems ); "
"// save filtered serials "
BREAK 
"SendSysMessage( "
"who, "
"items.size() "
"+ " Items recognized." ); "
BREAK 
"else "
BREAK 
"SendSysMessage( "
"who, "
""No items recognized." ); "
BREAK 
"endif "
BREAK 
"if ( "
"items <> {} "
") "
BREAK 
"while ( "
"who.connected ) "
BREAK 
"SendSysMessage( "
"who, "
""Selects the item to be added / removed." ); "
BREAK 
"tar1 := Target( "
"who, "
"TGTOPT_NOCHECK_LOS ); "
BREAK 
"if ( "
"( !tar1 ) && "
"( !tar1.isA( "
"POLCLASS_ITEM ) ) ) "
BREAK 
"SendSysMessage( "
"who, "
""Abort" ); "
BREAK 
"break; "
BREAK 
"endif "
BREAK 
"i := tar1.serial in tempitems; "
BREAK 
"if ( "
"i ) "
"// Remove from group "
BREAK 
"tempitems.erase( "
"i ); "
BREAK 
"items.erase( "
"i ); "
BREAK 
"tar1.eraseprop( "
"CPROP_INIT ); "
BREAK 
"tar1.eraseprop( "
"CPROP_ITEMS ); "
BREAK 
"if ( "
"!tar1.getprop( "
"CPROP_COLOR ).errortext ) "
BREAK 
"tar1.color := CInt( "
"tar1.getprop( "
"CPROP_COLOR ) ); "
BREAK 
"tar1.eraseprop( "
"CPROP_COLOR ); "
BREAK 
"endif "
BREAK 
"else // Add "
BREAK 
"if ( "
"tar1.getprop( "
"CPROP_COLOR ).errortext ) "
BREAK 
"tar1.setprop( "
"CPROP_COLOR, "
"tar1.color ); "
BREAK 
"endif "
BREAK 
"tar1.color := items[1].color; "
BREAK 
"tempitems.append( "
"tar1.serial ); "
BREAK 
"items.append( "
"tar1 ); "
BREAK 
"endif "
BREAK 
"endwhile "
BREAK 
"foreach item in ( items ) "
BREAK 
"item.setprop( "
"CPROP_INIT, "
"items[1].serial ); "
BREAK 
"item.eraseprop( "
"CPROP_ITEMS ); "
BREAK 
"endforeach "
BREAK 
"items[1].setprop( "
"CPROP_ITEMS, "
"tempitems ); "
BREAK 
"foreach item in ( items ) "
BREAK 
"if ( "
"!item.getprop( "
"CPROP_COLOR ).errortext ) "
BREAK 
"item.color := CInt( "
"item.getprop( "
"CPROP_COLOR ) ); "
BREAK 
"item.eraseprop( "
"CPROP_COLOR ); "
BREAK 
"endif "
BREAK 
"SleepMS( "
"1 ); "
BREAK 
"endforeach "
BREAK 
"endif "
BREAK 
"else "
BREAK 
"if ( "
"x1 ) "
"// If something has been done, reset the color "
BREAK 
"foreach item in ( ListObjectsInBox( "
"x1, "
"y1, "
"-128, "
"x2, "
"y2, "
"127, "
"tar2.realm ) ) // Freset work "
BREAK 
"if ( "
"item.isA( "
"POLCLASS_ITEM ) ) "
BREAK 
"if ( "
"( item.getprop( "
"CPROP_ITEMS ) ) && "
"( !item.getprop( "
"CPROP_COLOR ).errortext ) ) "
BREAK 
"foreach slaveitem in ( item.getprop( "
"CPROP_ITEMS ) ) "
BREAK 
"itemref := SystemFindObjectBySerial( "
"slaveitem ); "
BREAK 
"if ( "
"itemref ) "
BREAK 
"if ( "
"!itemref.getprop( "
"CPROP_COLOR ).errortext ) "
BREAK 
"itemref.color := CInt( "
"item.getprop( "
"CPROP_COLOR ) ); "
BREAK 
"itemref.eraseprop( "
"CPROP_COLOR ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"SleepMS( "
"5 ); "
BREAK 
"endforeach "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"SleepMS( "
"5 ); "
BREAK 
"endforeach "
BREAK 
"endif "
BREAK 
"SendSysMessage( "
"who, "
""Abort" ); "
BREAK 
"return; "
BREAK 
"endif "
BREAK 
"endwhile "
BREAK 
"endfunction // }}} "
BREAK 
"function ModifyItems( "
"who, "
"byref items ) "
"// {{{ "
BREAK 
"var retmodify, color, temp, dupe := {}, "
"dupeitem, dupeserials := {}; "
BREAK 
"if ( "
"TypeOfInt( "
"items ) != OT_ARRAY ) "
BREAK 
"temp := items; "
BREAK 
"items := {}; "
BREAK 
"items.append( "
"temp ); "
BREAK 
"endif "
BREAK 
"while ( "
"who.connected ) "
BREAK 
"datamodify[COLORDATAPOS] := items[1].color; "
BREAK 
"datamodify[XKOORDSPOS] := "<basefont color=" + HTML_WHITE + "><p align=right>" + items[1].x + "</p></basefont>"; "
BREAK 
"datamodify[YKOORDSPOS] := "<basefont color=" + HTML_WHITE + "><p align=right>" + items[1].y + "</p></basefont>"; "
BREAK 
"datamodify[ZKOORDSPOS] := "<basefont color=" + HTML_WHITE + "><p align=right>" + items[1].z + "</p></basefont>"; "
BREAK 
"datamodify[XENTRY] := items[1].x; "
BREAK 
"datamodify[YENTRY] := items[1].y; "
BREAK 
"datamodify[ZENTRY] := items[1].z; "
BREAK 
"retmodify := SendDialogGump( "
"who, "
"layoutmodify, "
"datamodify, "
"10, "
"50 ); "
BREAK 
"if ( "
"retmodify[MODIFY_Y_UP] ) "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x, "
"item.y + 1, "
"item.z, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_Y_DOWN] ) "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x, "
"item.y - 1, "
"item.z, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_X_UP] ) "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x + 1, "
"item.y, "
"item.z, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_X_DOWN] ) "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x - 1, "
"item.y, "
"item.z, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_XY_MM] ) "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x - 1, "
"item.y - 1, "
"item.z, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_XY_PM] ) "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x + 1, "
"item.y - 1, "
"item.z, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_XY_MP] ) "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x - 1, "
"item.y + 1, "
"item.z, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_XY_PP] ) "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x + 1, "
"item.y + 1, "
"item.z, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_Z_UP] ) "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x, "
"item.y, "
"item.z + 1, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_Z_DOWN] ) "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x, "
"item.y, "
"item.z - 1, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_DESTROY] ) "
BREAK 
"foreach item in ( items ) "
BREAK 
"DestroyItem( "
"item ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"break; "
BREAK 
"elseif ( "
"retmodify[MODIFY_COLOR] ) "
BREAK 
"color := retmodify[ITEMCOLOR]; "
BREAK 
"color[1, "
"6] := ""; "
BREAK 
"color := CInt( "
"color ); "
BREAK 
"foreach item in ( items ) "
BREAK 
"item.color := color; "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_DUPE] ) "
BREAK 
"dupe := {}; "
BREAK 
"dupeserials := {}; "
BREAK 
"foreach item in ( items ) "
BREAK 
"dupeitem := CreateItemCopyAtLocation( "
"item.x, "
"item.y, "
"item.z, "
"item, "
"item.realm ); "
BREAK 
"if ( "
"dupeitem ) "
BREAK 
"dupe.append( "
"dupeitem ); "
BREAK 
"dupeserials.append( "
"dupeitem.serial ); "
BREAK 
"endif "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"foreach item in ( dupe ) "
BREAK 
"item.setprop( "
"CPROP_INIT, "
"dupeserials[1] ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"dupe[1].setprop( "
"CPROP_ITEMS, "
"dupeserials ); "
BREAK 
"SendSysMessage( "
"who, "
"dupe.size() "
"+ " Items successfully duplicated." ); "
BREAK 
"items := dupe; "
"// Edit copy further "
BREAK 
"elseif ( "
"retmodify[MODIFY_X] ) "
BREAK 
"temp := retmodify[MODIFY_X_ENTRY]; "
BREAK 
"temp[1, "
"6] := ""; "
BREAK 
"temp := CInt( "
"temp ) - items[1].x; "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x + temp, "
"item.y, "
"item.z, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_Y] ) "
BREAK 
"temp := retmodify[MODIFY_Y_ENTRY]; "
BREAK 
"temp[1, "
"6] := ""; "
BREAK 
"temp := CInt( "
"temp ) - items[1].y; "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x, "
"item.y + temp, "
"item.z, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[MODIFY_Z] ) "
BREAK 
"temp := retmodify[MODIFY_Z_ENTRY]; "
BREAK 
"temp[1, "
"6] := ""; "
BREAK 
"temp := CInt( "
"temp ) - items[1].z; "
BREAK 
"foreach item in ( items ) "
BREAK 
"MoveObjectToLocation( "
"item, "
"item.x, "
"item.y, "
"item.z + temp, "
"item.realm, "
"ITEMMOVEFLAGS ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"elseif ( "
"retmodify[BACKBUTTON] ) "
BREAK 
"break; "
BREAK 
"else "
BREAK 
"return ( 0 ); "
"// Abbruch "
BREAK 
"endif "
BREAK 
"endwhile "
BREAK 
"return ( 1 ); "
BREAK 
"endfunction // }}} "
BREAK 
"function ChooseRandom( "
"byref liste ) "
"// {{{ "
BREAK 
"var verteilung := 0, i; "
BREAK 
"var rand := RandomInt( "
"100 ) + 1; "
BREAK 
"if ( "
"Find( "
"liste[1], "
""%", "
"1 ) ) "
"// Distribution according to Cfg "
BREAK 
"for ( "
"i := 1; "
"i <= liste.size(); "
"i += 1 ) "
BREAK 
"verteilung += CInt( "
"SplitWords( "
"liste[i], "
""%" )[2] ); "
BREAK 
"if ( "
"rand <= verteilung ) "
BREAK 
"return ( SplitWords( "
"liste[i], "
""%" )[1] ); "
BREAK 
"endif "
BREAK 
"endfor "
BREAK 
"else // Gleichverteilt "
BREAK 
"verteilung := CInt( "
"100 / liste.size() "
"); "
BREAK 
"for ( "
"i := 1; "
"i <= liste.size(); "
"i += 1 ) "
BREAK 
"if ( "
"rand <= ( i * verteilung ) ) "
"// within the probability? "
BREAK 
"return ( liste[i] ); "
"// Shoo Shoo "
BREAK 
"endif "
BREAK 
"endfor "
BREAK 
"endif "
BREAK 
"return ( liste.randomentry() "
"); "
"// well then just like that "
BREAK 
"endfunction // }}} "
BREAK 
"function MenuBar( "
"byref layout, "
"byref data, "
"byref datadict ) "
"// {{{ "
BREAK 
"var i, page := 1, y := 66, nextpagebreak := MAXBUTTON + 1; "
BREAK 
"if ( "
"TypeOfInt( "
"datadict ) == OT_DICTIONARY ) "
"// Data in dictionary or array "
BREAK 
"for ( "
"i := 1; "
"i <= datadict.keys()."
"size(); "
"i += 1 ) "
BREAK 
"if ( "
"i == nextpagebreak ) "
BREAK 
"nextpagebreak += MAXBUTTON; "
BREAK 
"y := 66; "
BREAK 
"page += 1; "
BREAK 
"layout.append( "
""button 565 287 5602 5606 0 " + page ); "
BREAK 
"layout.append( "
""page " + page ); "
BREAK 
"layout.append( "
""button 580 287 5600 5604 0 " + ( page - 1 ) ); "
BREAK 
"endif "
BREAK 
"layout.append( "
""button 525 " + ( y ) + " 2440 2440 1 0 " + ( MENUSTART + i ) ); "
BREAK 
"layout.append( "
""htmlgump 525 " + ( y ) + " 166 25 " + data.size() "
"+ " 1 0" ); "
BREAK 
"if ( "
"( cfgrandom[datadict.keys()["
"i]] ) && "
"( cfgrandom[datadict.keys()["
"i]].name ) ) "
BREAK 
"data.append( "
""<basefont color=" + HTML_DARKGRAY + "><center>" + cfgrandom[datadict.keys()["
"i]].name + "</center>" ); "
BREAK 
"elseif ( "
"( cfgeinzel[datadict.keys()["
"i]] ) && "
"( cfgeinzel[datadict.keys()["
"i]].name ) ) "
BREAK 
"data.append( "
""<basefont color=" + HTML_DARKBLUE + "><center>" + cfgeinzel[datadict.keys()["
"i]].name + "</center>" ); "
BREAK 
"elseif ( "
"cfgset[datadict.keys()["
"i]].name ) "
BREAK 
"data.append( "
""<basefont color=" + HTML_DARKBLUE + "><center>" + cfgset[datadict.keys()["
"i]].name + "</center>" ); "
BREAK 
"else "
BREAK 
"data.append( "
""<basefont color=" + HTML_DARKGRAY + "><center>" + datadict.keys()["
"i] + "</center>" ); "
BREAK 
"endif "
BREAK 
"y += 30; "
BREAK 
"endfor "
BREAK 
"else "
BREAK 
"for ( "
"i := 1; "
"i <= datadict.size(); "
"i += 1 ) "
BREAK 
"if ( "
"i == nextpagebreak ) "
BREAK 
"nextpagebreak += MAXBUTTON; "
BREAK 
"y := 66; "
BREAK 
"page += 1; "
BREAK 
"layout.append( "
""button 565 287 5602 5606 0 " + page + " 0" ); "
BREAK 
"layout.append( "
""page " + page ); "
BREAK 
"layout.append( "
""button 580 287 5600 5604 0 " + ( page - 1 ) + " 0" ); "
BREAK 
"endif "
BREAK 
"layout.append( "
""button 525 " + ( y ) + " 2440 2440 1 0 " + ( MENUSTART + i ) ); "
BREAK 
"layout.append( "
""htmlgump 525 " + ( y ) + " 166 25 " + data.size() "
"+ " 1 0" ); "
BREAK 
"if ( "
"TypeOfInt( "
"datadict[i] ) == OT_ARRAY ) "
"// Typebezeichnung im Array "
BREAK 
"if ( "
"( cfgrandom[datadict[i][1]].name ) || "
"( cfgeinzel[datadict[i][1]].name ) || "
"( cfgset[datadict[i][1]].name ) ) "
BREAK 
"case "
"( "
"datadict[i][2] ) "
BREAK 
""Random": "
"data.append( "
""<basefont color=" + HTML_SADDLEBROWN + "><center>" + cfgrandom[datadict[i][1]].name + "</center>" ); "
BREAK 
""Einzel": "
"data.append( "
""<basefont color=" + HTML_SADDLEBROWN + "><center>" + cfgeinzel[datadict[i][1]].name + "</center>" ); "
BREAK 
""Set": "
"data.append( "
""<basefont color=" + HTML_SADDLEBROWN + "><center>" + cfgset[datadict[i][1]].name + "</center>" ); "
BREAK 
"endcase "
BREAK 
"else "
BREAK 
"data.append( "
""<basefont color=" + HTML_SADDLEBROWN + "><center>" + datadict[i][1] + "</center>" ); "
BREAK 
"endif "
BREAK 
"endif "
BREAK 
"y += 30; "
BREAK 
"endfor "
BREAK 
"endif "
BREAK 
"endfunction // }}} "
BREAK 
"function Init() "
"// {{{ "
BREAK 
"var layoutraw := { "
""nodispose", "
""page 0" // "resizepic 500 0 3600 215 390",  // Background "
"// "resizepic 515 15 5054 185 30",  // title"
", "
""resizepic 500 0 9200 215 390", "
""resizepic 515 15 3000 185 30", "
""htmlgump 515 22 185 30 0 0 0" // Title text "
"// "gumppictiled 516 47 183 328 2624", "
"// "resizepic 516 47 83 183 328",   // Posts"
", "
""resizepic 516 47 3000 183 328" // "checkertrans 524 57 168 308","
", "
""htmlgump 610 285 50 20 1 0 0", "
""button 660 280 9726 9728 1 0 " + BACKBUTTON, "
""gumppictiled 525 320 166 2 30002", "
""button 530 330 9721 9724 1 0 " + ITEMMODIFYMANUAL, "
""htmlgump 572 335 100 30 2 0 0", "
""page 1" }; "
BREAK 
"var dataraw := { "
""" // Titel"
", "
""<basefont color=" + HTML_DARKBLUE + ">Back", "
""<basefont color=" + HTML_DARKBLUE + ">Item Modify" }; "
BREAK 
"SysLog( "
"".BAUTOOL Datafile begin" ); "
BREAK 
"SetGlobalProperty( "
""bautoolinit", "
"1 ); "
BREAK 
"var dataelement, layout := {}, "
"data := {}, "
"layoutp := {}; "
BREAK 
"var element := dictionary{}; "
BREAK 
"var cfgmenu := ReadConfigFile( "
""bautoolmenues" ); "
BREAK 
"DFPurgeFile( "
"datafile ); "
BREAK 
"dataelement := datafile.CreateElement( "
""menu" ); "
BREAK 
"foreach key in ( GetConfigStringArray( "
"cfgmenu["Rootlist"], "
""sublist" ) ) // 1. level "
BREAK 
"element[key] := dictionary{}; "
BREAK 
"if ( "
"cfgmenu[key].list ) "
"// Items "
BREAK 
"foreach itemlist in ( GetConfigStringArray( "
"cfgmenu[key], "
""list" ) ) "
BREAK 
"element[key][itemlist] := array{}; "
BREAK 
"foreach itemkey in ( GetConfigStringKeys( "
"cfgrandom ) ) // Insert possible random "
BREAK 
"if ( "
"cfgrandom[itemkey].list == itemlist ) "
BREAK 
"element[key][itemlist].append( "
"{ "
"itemkey, "
""Random", "
"cfgrandom[itemkey].name } "
"); "
BREAK 
"endif "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"foreach itemkey in ( GetConfigStringKeys( "
"cfgeinzel ) ) // Insert possible single "
BREAK 
"if ( "
"cfgeinzel[itemkey].list == itemlist ) "
BREAK 
"element[key][itemlist].append( "
"{ "
"itemkey, "
""Einzel", "
"cfgeinzel[itemkey].name } "
"); "
BREAK 
"endif "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"foreach itemkey in ( GetConfigStringKeys( "
"cfgset ) ) // Insert possible sets "
BREAK 
"if ( "
"cfgset[itemkey].list == itemlist ) "
BREAK 
"element[key][itemlist].append( "
"{ "
"itemkey, "
""Set", "
"cfgset[itemkey].name } "
"); "
BREAK 
"endif "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"element[key][itemlist] := SortArrayABC( "
"element[key][itemlist], "
"1, "
"3 ); "
BREAK 
"endforeach "
BREAK 
"endif "
BREAK 
"if ( "
"cfgmenu[key].sublist ) "
BREAK 
"foreach sub1key in ( GetConfigStringArray( "
"cfgmenu[key], "
""sublist" ) ) // 2. level "
BREAK 
"element[key][sub1key] := dictionary{}; "
BREAK 
"if ( "
"cfgmenu[sub1key].list ) "
"// Items "
BREAK 
"foreach itemlist in ( GetConfigStringArray( "
"cfgmenu[sub1key], "
""list" ) ) "
BREAK 
"element[key][sub1key][itemlist] := array{}; "
BREAK 
"foreach itemkey in ( GetConfigStringKeys( "
"cfgrandom ) ) // Insert possible random "
BREAK 
"if ( "
"cfgrandom[itemkey].list == itemlist ) "
BREAK 
"element[key][sub1key][itemlist].append( "
"{ "
"itemkey, "
""Random", "
"cfgrandom[itemkey].name } "
"); "
BREAK 
"endif "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"foreach itemkey in ( GetConfigStringKeys( "
"cfgeinzel ) ) // Insert possible single "
BREAK 
"if ( "
"cfgeinzel[itemkey].list == itemlist ) "
BREAK 
"element[key][sub1key][itemlist].append( "
"{ "
"itemkey, "
""Einzel", "
"cfgeinzel[itemkey].name } "
"); "
BREAK 
"endif "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"foreach itemkey in ( GetConfigStringKeys( "
"cfgset ) ) // Insert possible sets "
BREAK 
"if ( "
"cfgset[itemkey].list == itemlist ) "
BREAK 
"element[key][sub1key][itemlist].append( "
"{ "
"itemkey, "
""Set", "
"cfgset[itemkey].name } "
"); "
BREAK 
"endif "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"element[key][sub1key][itemlist] := SortArrayABC( "
"element[key][sub1key][itemlist], "
"1, "
"3 ); "
BREAK 
"endforeach "
BREAK 
"endif "
BREAK 
"if ( "
"cfgmenu[sub1key].sublist ) "
BREAK 
"foreach sub2key in ( GetConfigStringArray( "
"cfgmenu[sub1key], "
""sublist" ) ) // 3. level "
BREAK 
"element[key][sub1key][sub2key] := dictionary{}; "
BREAK 
"if ( "
"cfgmenu[sub2key].list ) "
"// Items "
BREAK 
"foreach itemlist in ( GetConfigStringArray( "
"cfgmenu[sub2key], "
""list" ) ) "
BREAK 
"element[key][sub1key][sub2key][itemlist] := array{}; "
BREAK 
"foreach itemkey in ( GetConfigStringKeys( "
"cfgrandom ) ) // Insert possible random "
BREAK 
"if ( "
"cfgrandom[itemkey].list == itemlist ) "
BREAK 
"element[key][sub1key][sub2key][itemlist].append( "
"{ "
"itemkey, "
""Random", "
"cfgrandom[itemkey].name } "
"); "
BREAK 
"endif "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"foreach itemkey in ( GetConfigStringKeys( "
"cfgeinzel ) ) // Insert possible single "
BREAK 
"if ( "
"cfgeinzel[itemkey].list == itemlist ) "
BREAK 
"element[key][sub1key][sub2key][itemlist].append( "
"{ "
"itemkey, "
""Einzel", "
"cfgeinzel[itemkey].name } "
"); "
BREAK 
"endif "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"foreach itemkey in ( GetConfigStringKeys( "
"cfgset ) ) // Insert possible sets "
BREAK 
"if ( "
"cfgset[itemkey].list == itemlist ) "
BREAK 
"element[key][sub1key][sub2key][itemlist].append( "
"{ "
"itemkey, "
""Set", "
"cfgset[itemkey].name } "
"); "
BREAK 
"endif "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"element[key][sub1key][sub2key][itemlist] := SortArrayABC( "
"element[key][sub1key][sub2key][itemlist], "
"1, "
"3 ); "
BREAK 
"endforeach "
BREAK 
"endif "
BREAK 
"if ( "
"cfgmenu[sub2key].sublist ) "
BREAK 
"foreach sub3key in ( GetConfigStringArray( "
"cfgmenu[sub2key], "
""sublist" ) ) // 4. level "
BREAK 
"element[key][sub1key][sub2key][sub3key] := dictionary{}; "
BREAK 
"if ( "
"cfgmenu[sub3key].list ) "
"// Items "
BREAK 
"foreach itemlist in ( GetConfigStringArray( "
"cfgmenu[sub3key], "
""list" ) ) "
BREAK 
"element[key][sub1key][sub2key][sub3key][itemlist] := array{}; "
BREAK 
"foreach itemkey in ( GetConfigStringKeys( "
"cfgrandom ) ) // Insert possible random "
BREAK 
"if ( "
"cfgrandom[itemkey].list == itemlist ) "
BREAK 
"element[key][sub1key][sub2key][sub3key][itemlist].append( "
"{ "
"itemkey, "
""Random", "
"cfgrandom[itemkey].name } "
"); "
BREAK 
"endif "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"foreach itemkey in ( GetConfigStringKeys( "
"cfgeinzel ) ) // Insert possible single "
BREAK 
"if ( "
"cfgeinzel[itemkey].list == itemlist ) "
BREAK 
"element[key][sub1key][sub2key][sub3key][itemlist].append( "
"{ "
"itemkey, "
""Einzel", "
"cfgeinzel[itemkey].name } "
"); "
BREAK 
"endif "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"foreach itemkey in ( GetConfigStringKeys( "
"cfgset ) ) // Insert possible sets "
BREAK 
"if ( "
"cfgset[itemkey].list == itemlist ) "
BREAK 
"element[key][sub1key][sub2key][sub3key][itemlist].append( "
"{ "
"itemkey, "
""Set", "
"cfgset[itemkey].name } "
"); "
BREAK 
"endif "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"element[key][sub1key][sub2key][sub3key][itemlist] := SortArrayABC( "
"element[key][sub1key][sub2key][sub3key][itemlist], "
"1, "
"3 ); "
BREAK 
"endforeach "
BREAK 
"endif "
BREAK 
"endforeach "
BREAK 
"endif "
BREAK 
"endforeach "
BREAK 
"endif "
BREAK 
"endforeach "
BREAK 
"endif "
BREAK 
"endforeach "
BREAK 
"layout := layoutraw; "
BREAK 
"data := dataraw; "
BREAK 
"MenuBar( "
"layout, "
"data, "
"element ); "
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>BauTool " + VERSION + "</center>"; "
"// Titel "
BREAK 
"dataelement.setprop( "
""LayoutMenuBar", "
"layout ); "
BREAK 
"dataelement.setprop( "
""DataMenuBar", "
"data ); "
BREAK 
"foreach ebene1 in ( element ) // 1. level "
BREAK 
"layout := layoutraw; "
BREAK 
"data := dataraw; "
BREAK 
"MenuBar( "
"layout, "
"data, "
"ebene1 ); "
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene1_iter + "</center>"; "
"// Titel "
BREAK 
"dataelement.setprop( "
""LayoutMain_" + _ebene1_iter, "
"layout ); "
BREAK 
"dataelement.setprop( "
""DataMain_" + _ebene1_iter, "
"data ); "
BREAK 
"foreach ebene2 in ( ebene1 ) // 2.level "
BREAK 
"layout := layoutraw; "
BREAK 
"data := dataraw; "
BREAK 
"MenuBar( "
"layout, "
"data, "
"ebene2 ); "
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene2_iter + "</center>"; "
"// Titel "
BREAK 
"dataelement.setprop( "
""LayoutSub_" + _ebene1_iter + "_" + _ebene2_iter, "
"layout ); "
BREAK 
"dataelement.setprop( "
""DataSub_" + _ebene1_iter + "_" + _ebene2_iter, "
"data ); "
BREAK 
"if ( "
"TypeOfInt( "
"ebene2 ) <> OT_DICTIONARY ) "
"// Items "
BREAK 
"foreach item in ( ebene2 ) "
BREAK 
"InitItems( "
"data, "
"layout, "
"item, "
"_ebene2_iter, "
"layoutraw, "
"dataraw ); "
BREAK 
"dataelement.setprop( "
""LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + item[1], "
"layout ); "
BREAK 
"dataelement.setprop( "
""DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + item[1], "
"data ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"else "
BREAK 
"foreach ebene3 in ( ebene2 ) // 3.level "
BREAK 
"layout := layoutraw; "
BREAK 
"data := dataraw; "
BREAK 
"MenuBar( "
"layout, "
"data, "
"ebene3 ); "
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene3_iter + "</center>"; "
"// Titel "
BREAK 
"dataelement.setprop( "
""LayoutSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter, "
"layout ); "
BREAK 
"dataelement.setprop( "
""DataSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter, "
"data ); "
BREAK 
"if ( "
"TypeOfInt( "
"ebene3 ) <> OT_DICTIONARY ) "
"// Items "
BREAK 
"foreach item in ( ebene3 ) "
BREAK 
"InitItems( "
"data, "
"layout, "
"item, "
"_ebene3_iter, "
"layoutraw, "
"dataraw ); "
BREAK 
"dataelement.setprop( "
""LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + item[1], "
"layout ); "
BREAK 
"dataelement.setprop( "
""DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + item[1], "
"data ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"else "
BREAK 
"foreach ebene4 in ( ebene3 ) // 4.level "
BREAK 
"layout := layoutraw; "
BREAK 
"data := dataraw; "
BREAK 
"MenuBar( "
"layout, "
"data, "
"ebene4 ); "
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene4_iter + "</center>"; "
"// Titel "
BREAK 
"dataelement.setprop( "
""LayoutSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter, "
"layout ); "
BREAK 
"dataelement.setprop( "
""DataSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter, "
"data ); "
BREAK 
"if ( "
"TypeOfInt( "
"ebene4 ) <> OT_DICTIONARY ) "
"// Items "
BREAK 
"foreach item in ( ebene4 ) "
BREAK 
"InitItems( "
"data, "
"layout, "
"item, "
"_ebene4_iter, "
"layoutraw, "
"dataraw ); "
BREAK 
"dataelement.setprop( "
""LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + item[1], "
"layout ); "
BREAK 
"dataelement.setprop( "
""DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + item[1], "
"data ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"else "
BREAK 
"foreach ebene5 in ( ebene4 ) // 5.level "
BREAK 
"layout := layoutraw; "
BREAK 
"data := dataraw; "
BREAK 
"MenuBar( "
"layout, "
"data, "
"ebene5 ); "
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene5_iter + "</center>"; "
"// Titel "
BREAK 
"dataelement.setprop( "
""LayoutSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter, "
"layout ); "
BREAK 
"dataelement.setprop( "
""DataSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter, "
"data ); "
BREAK 
"if ( "
"TypeOfInt( "
"ebene5 ) <> OT_DICTIONARY ) "
"// Items "
BREAK 
"foreach item in ( ebene5 ) "
BREAK 
"InitItems( "
"data, "
"layout, "
"item, "
"_ebene5_iter, "
"layoutraw, "
"dataraw ); "
BREAK 
"dataelement.setprop( "
""LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter + "_" + item[1], "
"layout ); "
BREAK 
"dataelement.setprop( "
""DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter + "_" + item[1], "
"data ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"else "
BREAK 
"foreach ebene6 in ( ebene5 ) // 6.level "
BREAK 
"InitItems( "
"data, "
"layout, "
"ebene6, "
"_ebene6_iter, "
"layoutraw, "
"dataraw ); "
BREAK 
"dataelement.setprop( "
""LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter + "_" + _ebene6_iter, "
"layout ); "
BREAK 
"dataelement.setprop( "
""DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter + "_" + _ebene6_iter, "
"data ); "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"endif "
BREAK 
"endforeach "
BREAK 
"endif "
BREAK 
"endforeach "
BREAK 
"endif "
BREAK 
"endforeach "
BREAK 
"endif "
BREAK 
"endforeach "
BREAK 
"endforeach "
BREAK 
"dataelement := datafile.CreateElement( "
""modify" ); "
BREAK 
"layout := { "
""nodispose", "
""page 0", "
""resizepic 500 0 3600 215 280" // Background"
", "
""resizepic 515 15 5054 185 30" // title"
", "
""htmlgump 515 22 185 30 0 0 0" // Title text"
", "
""resizepic 515 47 83 185 218" // Posts"
", "
""checkertrans 523 57 170 198", "
""htmlgump 610 225 50 20 1 0 0" // Continue"
", "
""htmlgump 555 79 50 20 2 0 0" // X/Y"
", "
""htmlgump 624 79 50 20 3 0 0" // Z"
", "
""button 660 220 9721 9724 1 0 " + BACKBUTTON, "
""button 560 60 5600 5604 1 0 " + MODIFY_Y_DOWN, "
""button 560 100 5602 5606 1 0 " + MODIFY_Y_UP, "
""button 530 80 5603 5607 1 0 " + MODIFY_X_DOWN, "
""button 590 80 5601 5605 1 0 " + MODIFY_X_UP, "
""button 534 60 22406 22407 1 0 " + MODIFY_XY_MM, "
""button 583 60 22401 22400 1 0 " + MODIFY_XY_PM, "
""button 534 100 22403 22402 1 0 " + MODIFY_XY_MP, "
""button 583 100 22404 22405 1 0 " + MODIFY_XY_PP, "
""button 620 60 5600 5604 1 0 " + MODIFY_Z_UP, "
""button 620 100 5602 5606 1 0 " + MODIFY_Z_DOWN, "
""htmlgump 570 165 50 20 4 0 0", "
""button 530 160 9727 9728 1 0 " + MODIFY_DESTROY, "
""htmlgump 570 200 50 30 10 0 0", "
""button 530 195 9727 9728 1 0 " + MODIFY_DUPE, "
""htmlgump 570 130 50 30 5 0 0", "
""resizepic 610 125 2620 58 30", "
""textentry 616 130 40 20 1000 " + ITEMCOLOR + " 6", "
""button 530 125 9727 9728 1 0 " + MODIFY_COLOR, "
""htmlgump 630 60 50 20 7 0 0" // x / y / z Coord Specification of the first item"
", "
""tooltip 3000561" // Coords.:"
", "
""htmlgump 630 80 50 20 8 0 0", "
""tooltip 3000561", "
""htmlgump 630 100 50 20 9 0 0", "
""tooltip 3000561", "
""button 681 64 2103 2104 0 2 0", "
""button 681 84 2103 2104 0 3 0", "
""button 681 104 2103 2104 0 4 0" }; "
BREAK 
"data := { "
""<basefont size=8 color=" + HTML_DARKGREEN + "><center>Modify Position</center>" // title"
", "
""<basefont color=" + HTML_DARKBLUE + ">Continue", "
""<basefont color=" + HTML_DARKBLUE + ">X/Y", "
""<basefont color=" + HTML_DARKBLUE + ">Z", "
""<basefont color=" + HTML_DARKBLUE + ">Destroy", "
""<basefont color=" + HTML_DARKBLUE + ">Color", "
""0", "
""<basefont color=" + HTML_DARKBLUE + "><p align=right>x</p></basefont>", "
""<basefont color=" + HTML_DARKBLUE + "><p align=right>y</p></basefont>", "
""<basefont color=" + HTML_DARKBLUE + "><p align=right>z</p></basefont>", "
""<basefont color=" + HTML_DARKBLUE + ">Dupe", "
""0", "
""0", "
""0" }; "
BREAK 
"layoutp := { "
""page 2", "
""resizepic 720 40 3600 100 60", "
""resizepic 735 55 2620 48 30", "
""textentrylimited 741 60 30 20 1000 " + MODIFY_X_ENTRY + " 11 4", "
""button 790 63 2103 2104 1 0 " + MODIFY_X, "
""page 3", "
""resizepic 720 60 3600 100 60", "
""resizepic 735 75 2620 48 30", "
""textentrylimited 741 80 30 20 1000 " + MODIFY_Y_ENTRY + " 12 4", "
""button 790 83 2103 2104 1 0 " + MODIFY_Y, "
""page 4", "
""resizepic 720 80 3600 100 60", "
""resizepic 735 95 2620 48 30", "
""textentrylimited 741 100 30 20 1000 " + MODIFY_Z_ENTRY + " 13 4", "
""button 790 103 2103 2104 1 0 " + MODIFY_Z }; "
BREAK 
"dataelement.setprop( "
""LayoutMenu", "
"layout + layoutp ); "
BREAK 
"dataelement.setprop( "
""DataMenu", "
"data ); "
BREAK 
"layout[3] := "resizepic 500 0 3600 215 440"; "
"// Background expand "
BREAK 
"layout[6] := "resizepic 516 47 83 183 377"; "
BREAK 
"layout[7] := "checkertrans 524 57 168 358"; "
BREAK 
"layout.erase( "
"8 ); "
"// Next ButtonText "
BREAK 
"layout.erase( "
"10 ); "
"// Next button "
BREAK 
"layout.append( "
""gumppictiled 525 235 165 2 30002" ); "
BREAK 
"layout.append( "
""htmlgump 595 255 100 20 1 0 0" ); "
BREAK 
"layout.append( "
""button 560 250 9721 9724 1 0 " + MODIFY_START ); "
BREAK 
"data[2] := "<basefont color=" + HTML_DARKBLUE + ">Choose Items"; "
BREAK 
"layout.append( "
""resizepic 530 285 2620 48 30" ); "
BREAK 
"layout.append( "
""textentry 536 290 30 20 1000 " + MODIFY_Z_START + " 14" ); "
BREAK 
"data.append( "
""-20" ); "
BREAK 
"layout.append( "
""resizepic 635 285 2620 48 30" ); "
BREAK 
"layout.append( "
""textentry 641 290 30 20 1000 " + MODIFY_Z_END + " 15" ); "
BREAK 
"data.append( "
""20" ); "
BREAK 
"layout.append( "
""htmlgump 585 290 50 20 16 0 0" ); "
BREAK 
"data.append( "
""<basefont color=" + HTML_DARKBLUE + ">Z-Range" ); "
BREAK 
"layout.append( "
""checkbox 530 320 9720 9723 0 " + MODIFY_CUSTOM ); "
BREAK 
"layout.append( "
""htmlgump 565 325 50 20 17 0 0" ); "
BREAK 
"data.append( "
""<basefont color=" + HTML_DARKBLUE + ">Custom" ); "
BREAK 
"layout.append( "
""checkbox 616 320 9720 9723 0 " + MODIFY_MARK ); "
BREAK 
"layout.append( "
""htmlgump 651 325 50 20 18 0 0" ); "
BREAK 
"data.append( "
""<basefont color=" + HTML_DARKBLUE + ">Mark" ); "
BREAK 
"layout.append( "
""gumppictiled 525 360 165 2 30002" ); "
BREAK 
"layout.append( "
""button 530 375 9721 9724 1 0 " + MODIFY_MARKEDIT ); "
BREAK 
"layout.append( "
""htmlgump 570 380 100 20 19 0 0" ); "
BREAK 
"data.append( "
""<basefont color=" + HTML_DARKBLUE + ">Mark Edit" ); "
BREAK 
"dataelement.setprop( "
""LayoutMenuManual", "
"layout + layoutp ); "
BREAK 
"dataelement.setprop( "
""DataMenuManual", "
"data ); "
BREAK 
"dataelement := datafile.CreateElement( "
""modifymark" ); "
BREAK 
"layout := { "
""nodispose", "
""page 0", "
""resizepic 500 0 3600 215 213" // Background"
", "
""resizepic 515 15 5054 185 30" // title"
", "
""htmlgump 515 22 185 30 0 0 0" // Title text"
", "
""resizepic 515 47 83 185 150" // Posts-20"
", "
""checkertrans 523 57 170 130", "
""button 530 70 9721 9724 1 0 " + MARK_SHOW, "
""htmlgump 570 75 50 20 1 0 0", "
""button 530 105 9721 9724 1 0 " + MARK_HIDE, "
""htmlgump 570 110 50 20 2 0 0", "
""button 530 140 9721 9724 1 0 " + MARK_EDIT, "
""htmlgump 570 145 50 20 3 0 0" }; "
BREAK 
"data := { "
""<basefont size=8 color=" + HTML_DARKGRAY + "><center>Mark Edit</center>", "
""<basefont color=" + HTML_DARKBLUE + ">Show", "
""<basefont color=" + HTML_DARKBLUE + ">Hide", "
""<basefont color=" + HTML_DARKBLUE + ">Edit" }; "
BREAK 
"dataelement.setprop( "
""LayoutMenuMark", "
"layout ); "
BREAK 
"dataelement.setprop( "
""DataMenuMark", "
"data ); "
BREAK 
"dataelement := datafile.CreateElement( "
""elemente" ); "
BREAK 
"dataelement.setprop( "
""dictionary", "
"element ); "
BREAK 
"EraseGlobalProperty( "
""bautoolinit" ); "
BREAK 
"SysLog( "
"".BAUTOOL Datafile completed" ); "
BREAK 
"endfunction // }}} "
BREAK 
"function InitItems( "
"byref data, "
"byref layout, "
"byref element, "
"name := 0, "
"layoutraw, "
"dataraw ) "
"// {{{ "
BREAK 
"var tile, nextpagebreak, nextlinebreak, x, y, page, m, itemdesc; "
BREAK 
"case "
"( "
"element[2] ) "
BREAK 
""Random": "
"// Random "
"layout := layoutraw; "
BREAK 
"data := dataraw; "
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + name + "</center>"; "
"// TESTTESTTEST "
BREAK 
"layout := layout + { "
""page 0", "
""resizepic 70 0 3600 404 170", "
""resizepic 85 15 5054 374 30", "
""htmlgump 85 22 374 30 " + data.size() "
"+ " 0 0", "
""resizepic 85 47 83 374 108", "
""checkertrans 93 57 359 88" }; "
BREAK 
"data.append( "
""<basefont size=5><center>" + cfgrandom[element[1]].name + "</center>" ); "
BREAK 
"tile := GetConfigStringArray( "
"cfgrandom[element[1]], "
""tile" )[1]; "
BREAK 
"layout.append( "
""tilepic 95 60 " + CInt( "
"SplitWords( "
"tile, "
""," )[1] ) ); "
BREAK 
"layout.append( "
""htmlgump 160 70 50 30 " + data.size() "
"+ " 0 0" ); "
BREAK 
"data.append( "
""<basefont color=" + HTML_DARKBLUE + ">Color" ); "
BREAK 
"layout.append( "
""resizepic 200 65 2620 48 30" ); "
BREAK 
"layout.append( "
""textentry 206 70 30 20 1000 " + ITEMCOLOR + " " + data.size() "
"); "
BREAK 
"data.append( "
""0" ); "
BREAK 
"if ( "
"( GetConfigString( "
"cfgrandom[element[1]], "
""n" ) ) // Option necessary for edge parts? "
"|| "
"( GetConfigString( "
"cfgrandom[element[1]], "
""s" ) ) || "
"( GetConfigString( "
"cfgrandom[element[1]], "
""e" ) ) || "
"( GetConfigString( "
"cfgrandom[element[1]], "
""w" ) ) ) "
BREAK 
"layout.append( "
""htmlgump 360 60 50 40 " + data.size() "
"+ " 0 0" ); "
BREAK 
"data.append( "
""<basefont color=" + HTML_DARKBLUE + ">Produce Random Tiles" ); "
BREAK 
"layout.append( "
""checkbox 420 65 9720 9723 0 " + ITEMRAND ); "
BREAK 
"endif "
BREAK 
"layout.append( "
""htmlgump 260 70 50 30 " + data.size() "
"+ " 0 0" ); "
BREAK 
"data.append( "
""<basefont color=" + HTML_DARKBLUE + ">z-Coord" ); "
BREAK 
"layout.append( "
""resizepic 310 65 2620 38 30" ); "
BREAK 
"layout.append( "
""textentry 316 70 20 20 1000 " + ITEMPOS + " " + data.size() "
"); "
BREAK 
"data.append( "
""0" ); "
BREAK 
"layout.append( "
""checkbox 420 110 9720 9723 1 " + ITEMMODIFY ); "
BREAK 
"layout.append( "
""htmlgump 360 105 50 40 " + data.size() "
"+ " 0 0" ); "
BREAK 
"data.append( "
""<basefont color=" + HTML_DARKBLUE + ">Modify Position" ); "
BREAK 
"layout.append( "
""button 103 116 9721 9724 1 0 " + ITEMCREATE ); "
BREAK 
"layout.append( "
""htmlgump 140 121 50 30 " + data.size() "
"+ " 0 0" ); "
BREAK 
"data.append( "
""<basefont color=" + HTML_DARKBLUE + ">Create" ); "
BREAK 
""Einzel": "
"itemdesc := ReadConfigFile( "
"":*:itemdesc" ); "
"// Reading of all Itemdesc's for name determination "
BREAK 
"layout := layoutraw; "
BREAK 
"data := dataraw; "
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + name + "</center>"; "
BREAK 
"layout := layout + { "
""page 0", "
""resizepic 70 0 3600 425 400", "
""resizepic 85 15 5054 395 30", "
""htmlgump 85 22 395 30 " + data.size() "
"+ " 0 0", "
""resizepic 85 47 83 395 343" }; "
BREAK 
"data.append( "
""<basefont size=5><center>" + cfgeinzel[element[1]].name + "</center>" ); "
BREAK 
"layout.append( "
""htmlgump 530 70 50 30 " + data.size() "
"+ " 0 0" ); "
BREAK 
"data.append( "
""<basefont color=" + HTML_DARKBLUE + ">Color" ); "
BREAK 
"layout.append( "
""resizepic 570 65 2620 48 30" ); "
BREAK 
"layout.append( "
""textentry 576 70 30 20 1000 " + ITEMCOLOR + " " + data.size() "
"); "
BREAK 
"data.append( "
""0" ); "
BREAK 
"layout.append( "
""htmlgump 530 110 50 30 " + data.size() "
"+ " 0 0" ); "
BREAK 
"data.append( "
""<basefont color=" + HTML_DARKBLUE + ">z-Coord" ); "
BREAK 
"layout.append( "
""resizepic 580 105 2620 38 30" ); "
BREAK 
"layout.append( "
""textentry 586 110 20 20 1000 " + ITEMPOS + " " + data.size() "
"); "
BREAK 
"data.append( "
""0" ); "
BREAK 
"layout.append( "
""checkbox 530 150 9720 9723 1 " + ITEMMODIFY ); "
BREAK 
"layout.append( "
""htmlgump 572 155 100 30 " + data.size() "
"+ " 0 0" ); "
BREAK 
"data.append( "
""<basefont color=" + HTML_DARKBLUE + ">Modify Position" ); "
BREAK 
"layout.append( "
""checkbox 530 185 9720 9723 0 " + ITEMMMULTICREATE ); "
BREAK 
"layout.append( "
""htmlgump 572 190 100 30 " + data.size() "
"+ " 0 0" ); "
BREAK 
"data.append( "
""<basefont color=" + HTML_DARKBLUE + ">Mark All" ); "
BREAK 
"layout.append( "
""button 570 225 9721 9724 1 0 " + ITEMCREATE ); "
BREAK 
"layout.append( "
""htmlgump 612 230 50 30 " + data.size() "
"+ " 0 0" ); "
BREAK 
"data.append( "
""<basefont color=" + HTML_DARKBLUE + ">Create" ); "
BREAK 
"tile := {}; "
BREAK 
"foreach tiles in ( GetConfigStringArray( "
"cfgeinzel[element[1]], "
""tile" ) ) "
BREAK 
"if ( "
"!tile ) "
BREAK 
"tile := { "
"tiles }; "
BREAK 
"else "
BREAK 
"tile.append( "
"tiles ); "
BREAK 
"endif "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endforeach "
BREAK 
"nextpagebreak := MAXLINEITEM * 2 + 1; "
BREAK 
"nextlinebreak := MAXLINEITEM + 1; "
BREAK 
"x := 100; "
BREAK 
"y := 60; "
BREAK 
"page := 1; "
BREAK 
"layout.append( "
""page 1" ); "
BREAK 
"for ( "
"m := 1; "
"m <= tile.size(); "
"m += 1 ) "
BREAK 
"if ( "
"m == nextpagebreak ) "
BREAK 
"nextpagebreak += MAXLINEITEM * 2; "
BREAK 
"nextlinebreak += MAXLINEITEM; "
BREAK 
"x := 100; "
BREAK 
"y := 60; "
BREAK 
"if ( "
"page > 1 ) "
BREAK 
"layout.append( "
""button 250 360 5603 5607 0 " + ( page - 1 ) + " 0" ); "
BREAK 
"endif "
BREAK 
"page += 1; "
BREAK 
"layout.append( "
""button 280 360 5601 5605 0 " + page + " 0" ); "
BREAK 
"layout.append( "
""page " + page ); "
BREAK 
"endif "
BREAK 
"if ( "
"m == nextlinebreak ) "
BREAK 
"y := 210; "
BREAK 
"x := 100; "
BREAK 
"nextlinebreak += MAXLINEITEM; "
BREAK 
"endif "
BREAK 
"layout.append( "
""radio " + ( x ) + " " + ( y + 35 ) + " 9720 9723 0 " + m ); "
BREAK 
"layout.append( "
""tilepic " + ( x + 35 ) + " " + ( y + 35 ) + " " + CInt( "
"SplitWords( "
"tile[m], "
""," )[1] ) ); "
BREAK 
"if ( "
"itemdesc[Hex( "
"tile[m] )].desc ) "
"// Insert name .desc or CliLoc entry "
BREAK 
"layout.append( "
""htmlgump " + ( x + 5 ) + " " + ( y ) + " 90 40 " + data.size() "
"+ " 0 0" ); "
BREAK 
"data.append( "
""<basefont color=" + HTML_GRAY + ">" + itemdesc[Hex( "
"tile[m] )].desc ); "
BREAK 
"else "
BREAK 
"layout.append( "
""xmfhtmlgumpcolor " + ( x + 5 ) + " " + ( y ) + " 90 40 " + ( 1020000 + CInt( "
"tile[m] ) ) + " 0 0 " + XMFCOLOR_GRAY2 ); "
BREAK 
"endif "
BREAK 
"x += 90; "
BREAK 
"SleepMS( "
"2 ); "
BREAK 
"endfor "
BREAK 
"if ( "
"page > 1 ) "
BREAK 
"layout.append( "
""button 250 360 5603 5607 0 " + ( page - 1 ) + " 0" ); "
BREAK 
"endif "
BREAK 
""Set": "
"layout := layoutraw; "
BREAK 
"data := dataraw; "
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + name + "</center>"; "
BREAK 
"layout.append( "
""htmlgump 515 60 185 30 " + data.size() "
"+ " 0 0" ); "
BREAK 
"data.append( "
""<basefont size=5 color=" + HTML_DARKGRAY + "><center>" + cfgset[element[1]].name + "</center>" ); "
BREAK 
"layout.append( "
""htmlgump 530 100 50 30 " + data.size() "
"+ " 0 0" ); "
BREAK 
"data.append( "
""<basefont color=" + HTML_DARKBLUE + ">Color" ); "
BREAK 
"layout.append( "
""resizepic 570 95 2620 48 30" ); "
BREAK 
"layout.append( "
""textentry 576 100 30 20 1000 " + ITEMCOLOR + " " + data.size() "
"); "
BREAK 
"data.append( "
""0" ); "
BREAK 
"layout.append( "
""htmlgump 530 140 50 30 " + data.size() "
"+ " 0 0" ); "
BREAK 
"data.append( "
""<basefont color=" + HTML_DARKBLUE + ">z-Coord" ); "
BREAK 
"layout.append( "
""resizepic 580 135 2620 38 30" ); "
BREAK 
"layout.append( "
""textentry 586 140 20 20 1000 " + ITEMPOS + " " + data.size() "
"); "
BREAK 
"data.append( "
""0" ); "
BREAK 
"layout.append( "
""checkbox 530 180 9720 9723 1 " + ITEMMODIFY ); "
BREAK 
"layout.append( "
""htmlgump 572 185 100 30 " + data.size() "
"+ " 0 0" ); "
BREAK 
"data.append( "
""<basefont color=" + HTML_DARKBLUE + ">Modify Position" ); "
BREAK 
"layout.append( "
""checkbox 530 215 9720 9723 0 " + ITEMMMULTICREATE ); "
BREAK 
"layout.append( "
""htmlgump 572 220 100 30 " + data.size() "
"+ " 0 0" ); "
BREAK 
"data.append( "
""<basefont color=" + HTML_DARKBLUE + ">Mark All" ); "
BREAK 
"layout.append( "
""button 570 255 9721 9724 1 0 " + ITEMCREATE ); "
BREAK 
"layout.append( "
""htmlgump 612 260 50 30 " + data.size() "
"+ " 0 0" ); "
BREAK 
"data.append( "
""<basefont color=" + HTML_DARKBLUE + ">Create" ); "
BREAK 
"endcase "
BREAK 
"endfunction // }}} "
BREAK 
"function RecoverInitItem( "
"newinit ) "
"// {{{ "
BREAK 
"var oldinit := newinit.getprop( "
"CPROP_INIT ); "
BREAK 
"var found := array{ "
"newinit }; "
BREAK 
"var serials := array{ "
"newinit.serial }; "
BREAK 
"foreach item in ( ListItemsNearLocation( "
"newinit.x, "
"newinit.y, "
"LIST_IGNORE_Z, "
"MAXAREASIZE, "
"newinit.realm ) ) "
BREAK 
"SleepMs( "
"2 ); "
BREAK 
"if ( "
"item.serial == newinit.serial ) "
BREAK 
"continue; "
BREAK 
"endif "
BREAK 
"if ( "
"item.getprop( "
"CPROP_INIT ) == oldinit ) "
BREAK 
"found.append( "
"item ); "
BREAK 
"serials.append( "
"item.serial ); "
BREAK 
"item.setprop( "
"CPROP_INIT, "
"newinit.serial ); "
BREAK 
"endif "
BREAK 
"endforeach "
BREAK 
"newinit.setprop( "
"CPROP_INIT, "
"newinit.serial ); "
BREAK 
"newinit.setprop( "
"CPROP_ITEMS, "
"serials ); "
BREAK 
"return found; "
BREAK 
"endfunction // }}} "
// /////////////////////////////////////////////////////////////////////////
// bautool - bequemes Erzeugen und Verändern von Items und Itemgruppen
// 
// Author: Turley
// eMail : michi.at.www@gmx.de

// Konfigurationsdateien
// - Menustruktur
// - bautoolmenues.cfg
// - Erstellt Rechtecke mit Tiles (Zufällig oder nur einen)
// - bautoolrandom.cfg
// - Erstellt einzelne Items
// - bautooleinzel.cfg
// - Erstellt Sets
// - bautoolset.cfg

// /////////////////////////////////////////////////////////////////////////
// ToDo:
// Zufallsding
// - Auswahlliste wie Random/Einzel/Sets
// - Wählt aus plus Wahrscheinlichkeiten
// - Wenn fertig zusammengestellt Eck-Koords angeben und
// createn, immer auf Maphöhe

use cfgfile; 
use os; 
use uo; 
use util; 

include "client"; 
include ":datafile:datafile"; 
include ":gumps:textConsts"; 
// Include "include/itemnpc";
// Include "include/msgs";
// Include "include/server";
// Include "include/set";
include "string"; 

const VERSION := "<basefont color=" + HTML_DARKBLUE + ">V4.2a"; 

enum TextEntry_Checkboxes 
  ITEMCOLOR := 1000, 
  ITEMRAND, 
  ITEMCREATE, 
  ITEMPOS, 
  ITEMMODIFY, 
  ITEMMMULTICREATE, 
  ITEMMODIFYMANUAL, // Modify menu for later modification 
  MODIFY_Z_START, 
  MODIFY_Z_END, 
  MODIFY_CUSTOM, 
  MODIFY_MARK, 
  MODIFY_X_ENTRY, 
  MODIFY_Y_ENTRY, 
  MODIFY_Z_ENTRY 
endenum 

enum Buttons 
  BACKBUTTON := 2000, // Back-Button 
  MODIFY_MARKEDIT, 
  MODIFY_START := 3000, 
  MODIFY_Y_UP := 3005, // ModifyItem-Buttons 
  MODIFY_Y_DOWN, 
  MODIFY_X_UP, 
  MODIFY_X_DOWN, 
  MODIFY_XY_MM, 
  MODIFY_XY_MP, 
  MODIFY_XY_PM, 
  MODIFY_XY_PP, 
  MODIFY_Z_UP, 
  MODIFY_Z_DOWN, 
  MODIFY_DESTROY, 
  MODIFY_COLOR, 
  MODIFY_DUPE, 
  MODIFY_X, 
  MODIFY_Y, 
  MODIFY_Z, 
  MARK_SHOW, 
  MARK_HIDE, 
  MARK_EDIT 
endenum 

enum dataPositionsAngaben 
  COLORDATAPOS := 7, 
  ZSTARTPOS := 15, 
  ZENDPOS := 16, 
  XKOORDSPOS := 8, 
  YKOORDSPOS := 9, 
  ZKOORDSPOS := 10, 
  XENTRY := 12, 
  YENTRY, 
  ZENTRY 
endenum 

enum Ebenen 
  ROOTLIST := 0, // plane definition 
  FIRSTLIST, 
  SECONDLIST, 
  THIRDLIST, 
  FOURTHLIST, 
  FIFTHLIST, 
  ITEMLIST, 
  ITEMLISTDUMMY 
endenum 

enum Cprops 
  CPROP_INIT := "bautoolinit", // CProps to find the items 
  CPROP_ITEMS := "bautoolitems", 
  CPROP_COLOR := "bautoolorigcol" // Original color for markedit 
endenum 

const MENUSTART := 4000; // Start value of the lists / item buttons 

const MAXBUTTON := 7; // Max Buttons in the NavBar 
const MAXLINEITEM := 4; // How many items side by side in single create 

const MAXAREASIZE := 50; 

const ITEMMOVEFLAGS := MOVEOBJECT_FORCELOCATION + MOVEITEM_IGNOREMOVABLE; 

// Load everything you need
var cfgrandom := ReadConfigFile( "bautoolrandom" ); 
var cfgeinzel := ReadConfigFile( "bautooleinzel" ); 
var cfgset := ReadConfigFile( "bautoolset" ); 
var datafile := DFOpenDataFile( "bautoolcmd", DF_CREATE, DF_KEYTYPE_STRING ); 
var dataelementMenu := datafile.FindElement( "menu" ); 
var dataelementModify := datafile.FindElement( "modify" ); 
var dataelementElement := datafile.FindElement( "elemente" ); 
var dataelementMark := datafile.FindElement( "modifymark" ); 
var layoutmodify := dataelementModify.getprop( "LayoutMenu" ); 
var datamodify := dataelementModify.getprop( "DataMenu" ); 
var layoutmodify_M := dataelementModify.getprop( "LayoutMenuManual" ); 
var datamodify_M := dataelementModify.getprop( "DataMenuManual" ); 
var layoutmark := dataelementMark.getprop( "LayoutMenuMark" ); 
var datamark := dataelementMark.getprop( "DataMenuMark" ); 
var datafileelement := dataelementElement.getprop( "dictionary" ); 

program bautool( who, param ) 
  if ( who[1] == "Init" ) // Generate datafile via script 
    Init(); 
    return; 
  endif 

  if ( !GetGlobalProperty( "BauServer" ) ) 
    if ( who.cmdlevel < 3 ) 
      SendSysMessage( who, "You are not authorized to use this command!" ); 
      return; 
    endif 
  endif 

  if ( Lower( param ) == "init" ) // Developer can start Init () manually 
    if ( who.cmdlevel == 5 ) 
      cfgrandom := 0; // First remove Ref's so that Unload works properly 
      cfgeinzel := 0; 
      cfgset := 0; 
      UnloadConfigFile( "bautoolmenues" ); 
      UnloadConfigFile( "bautooleinzel" ); 
      UnloadConfigFile( "bautoolrandom" ); 
      UnloadConfigFile( "bautoolset" ); 
      cfgrandom := ReadConfigFile( ":bautool:bautoolrandom" ); 
      cfgeinzel := ReadConfigFile( ":bautool:bautooleinzel" ); 
      cfgset := ReadConfigFile( ":bautool:bautoolset" ); 
      SendSysMessage( who, "Datafile building..." ); 
      Init(); 
      SendSysMessage( who, "Datafile completed" ); 
      return; 
    endif 
  endif 

  if ( GetGlobalProperty( "bautoolinit" ) ) 
    SendSysMessage( who, "Datafile is still being generated, try again later." ); 
    return; 
  endif 

  ShowMenu( who ); 

endprogram 

// /////////////////////////////////
// ShowMenu - Actual main part
// /////////////////////////////////

function ShowMenu( who ) // {{{ 
  var data := {}, layout := {}, nr, ebene; 
  var ret, tile := {}; 
  var element := dictionary{}, back := 0; 
  var firstebene, secondebene, thirdebene, fourthebene, fifthebene, itemebene; 
  var color; 

  element := datafileelement; 

  // Now it can start
  ebene := FIRSTLIST; 
  layout := dataelementMenu.getprop( "LayoutMenuBar" ); 
  data := dataelementMenu.getprop( "DataMenuBar" ); 

  ret := SendDialogGump( who, layout, data, 10, 50 ); 

  while ( who.connected ) 
    if ( ( ret.keys[ret.keys.size()] > MENUSTART ) || ( back ) ) 
      if ( back ) // Simulated buttone printing 
        nr := back; 
        back := 0; 
      else 
        nr := ret.keys[ret.keys.size()] - MENUSTART; 
      endif 
      case ( ebene ) // In which display level I am, create a suitable data list 
        ROOTLIST: ebene := FIRSTLIST; 
        layout := dataelementMenu.getprop( "LayoutMenuBar" ); 
        data := dataelementMenu.getprop( "DataMenuBar" ); 

        FIRSTLIST: ebene := SECONDLIST; 
        if ( TypeOfInt( nr ) == OT_STRING ) 
          firstebene := nr; 
        else 
          firstebene := element.keys()[nr]; 
        endif 
        layout := dataelementMenu.getprop( "LayoutMain_" + firstebene ); 
        data := dataelementMenu.getprop( "DataMain_" + firstebene ); 

        SECONDLIST: ebene := THIRDLIST; 
        if ( TypeOfInt( element[firstebene] ) <> OT_DICTIONARY ) 
          secondebene := nr; 
          tile := BuildItems( layout, data, element[firstebene][nr], firstebene ); 
        else 
          if ( TypeOfInt( nr ) == OT_STRING ) 
            secondebene := nr; 
          else 
            secondebene := element[firstebene].keys()[nr]; 
          endif 
          layout := dataelementMenu.getprop( "LayoutSub_" + firstebene + "_" + secondebene ); 
          data := dataelementMenu.getprop( "DataSub_" + firstebene + "_" + secondebene ); 
        endif 

        THIRDLIST: ebene := FOURTHLIST; 
        if ( TypeOfInt( element[firstebene][secondebene] ) <> OT_DICTIONARY ) 
          thirdebene := nr; 
          tile := BuildItems( layout, data, element[firstebene][secondebene][nr], 
                              firstebene, secondebene ); 
        else 
          if ( TypeOfInt( nr ) == OT_STRING ) 
            thirdebene := nr; 
          else 
            thirdebene := element[firstebene][secondebene].keys()[nr]; 
          endif 
          layout := dataelementMenu.getprop( "LayoutSub_" + firstebene + "_" + secondebene + "_" + thirdebene ); 
          data := dataelementMenu.getprop( "DataSub_" + firstebene + "_" + secondebene + "_" + thirdebene ); 
        endif 

        FOURTHLIST: ebene := FIFTHLIST; 
        if ( TypeOfInt( element[firstebene][secondebene][thirdebene] ) <> OT_DICTIONARY ) 
          fourthebene := nr; 
          tile := BuildItems( layout, data, element[firstebene][secondebene][thirdebene][nr], 
                              firstebene, secondebene, thirdebene ); 
        else 
          ebene := FIFTHLIST; 
          if ( TypeOfInt( nr ) == OT_STRING ) 
            fourthebene := nr; 
          else 
            fourthebene := element[firstebene][secondebene][thirdebene].keys()[nr]; 
          endif 
          layout := dataelementMenu.getprop( "LayoutSub_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene ); 
          data := dataelementMenu.getprop( "DataSub_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene ); 
        endif 

        FIFTHLIST: ebene := ITEMLIST; 
        if ( TypeOfInt( element[firstebene][secondebene][thirdebene][fourthebene] ) <> OT_DICTIONARY ) 
          fifthebene := nr; 
          tile := BuildItems( layout, data, element[firstebene][secondebene][thirdebene][fourthebene][nr], 
                              firstebene, secondebene, thirdebene, fourthebene ); 
        else 
          ebene := ITEMLIST; 
          if ( TypeOfInt( nr ) == OT_STRING ) 
            fifthebene := nr; 
          else 
            fifthebene := element[firstebene][secondebene][thirdebene][fourthebene].keys()[
                                                                                           nr]; 
          endif 
          layout := dataelementMenu.getprop( "LayoutSub_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene ); 
          data := dataelementMenu.getprop( "DataSub_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene ); 
        endif 

        ITEMLIST: ITEMLISTDUMMY: ebene := ITEMLISTDUMMY; 
        if ( TypeOfInt( nr ) == OT_STRING ) 
          itemebene := nr; 
        else 
          itemebene := element[firstebene][secondebene][thirdebene][fourthebene][fifthebene][nr]; 
        endif 
        tile := BuildItems( layout, data, element[firstebene][secondebene][thirdebene][fourthebene][fifthebene][nr], 
                            firstebene, secondebene, thirdebene, fourthebene, fifthebene, 
                            itemebene[1] ); 

      endcase 
      ret := SendDialogGump( who, layout, data, 10, 50 ); 

    elseif ( ret[BACKBUTTON] ) // Back 
      ebene -= 2; // 2 because one was added beforehand 
      if ( ebene < 0 ) 
        ebene := ROOTLIST; 
      endif 
      case ( ebene ) 
        ROOTLIST: back := 1; 
        FIRSTLIST: back := firstebene; 
        SECONDLIST: back := secondebene; 
        THIRDLIST: back := thirdebene; 
        FOURTHLIST: back := fourthebene; 
        FIFTHLIST: back := fifthebene; 
        ITEMLIST: back := itemebene; 
        ITEMLISTDUMMY: back := itemebene; 
      endcase 

    // The Interesting Junk Item Creation
    elseif ( ret[ITEMCREATE] ) 
      ebene -= 1; 
      back := nr; // So that there is no final lock loop with Create 
      color := ret[ITEMCOLOR]; 
      color[1, 6] := ""; 
      color := CInt( color ); 
      case ( tile[1][2] ) 
        "Random": CreateRandom( who, ret, tile[2], tile[3], color, tile[1][1] ); 
        "Einzel": CreateEinzel( who, ret, tile[2], color ); 
        "Set": CreateSet( who, ret, tile[2], color ); 
        default: SendSysMessage( who, "error..." ); 
        return; 
      endcase 

    // Manual ItemModify
    elseif ( ret[ITEMMODIFYMANUAL] ) 
      ModifyItemsManual( who ); 
      back := 1; 
      ebene := ROOTLIST; 
    else 
      return; // Winke 
    endif 
  endwhile 
endfunction // }}} 

// /////////////////////////////////
// BuildItems - get layout / data +
// special stuff from Itemcreategumps
// /////////////////////////////////

function BuildItems( byref layout, byref data, byref element, firstebene, secondebene := 0, 
                     thirdebene := 0, fourthebene := 0, fifthebene := 0, itemebene := 0 ) 
                     // {{{ 
  var tiles := {}; 
  var tiles1 := {}; 
  var splittiles := {}; 

  if ( itemebene ) 
    layout := dataelementMenu.getprop( "LayoutItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene + "_" + itemebene ); 
    data := dataelementMenu.getprop( "DataItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene + "_" + itemebene ); 
  elseif ( fifthebene ) 
    layout := dataelementMenu.getprop( "LayoutItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene ); 
    data := dataelementMenu.getprop( "DataItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene ); 
  elseif ( fourthebene ) 
    layout := dataelementMenu.getprop( "LayoutItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + element[1] ); 
    data := dataelementMenu.getprop( "DataItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + element[1] ); 
  elseif ( thirdebene ) 
    layout := dataelementMenu.getprop( "LayoutItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + element[1] ); 
    data := dataelementMenu.getprop( "DataItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + element[1] ); 
  elseif ( secondebene ) 
    layout := dataelementMenu.getprop( "LayoutItem_" + firstebene + "_" + secondebene + "_" + element[1] ); 
    data := dataelementMenu.getprop( "DataItem_" + firstebene + "_" + secondebene + "_" + element[1] ); 
  elseif ( firstebene ) 
    layout := dataelementMenu.getprop( "LayoutItem_" + firstebene + "_" + element[1] ); 
    data := dataelementMenu.getprop( "DataItem_" + firstebene + "_" + element[1] ); 
  endif 

  // Build an array of items
  case ( element[2] ) 
    "Random": foreach tile in ( GetConfigStringArray( cfgrandom[element[1]], "tile" ) ) 
      splittiles := SplitWords( tile ); 
      tiles.append( splittiles[1] ); 
      if ( splittiles[2] ) 
        tiles1.append( splittiles[2] ); 
      endif 
    endforeach 

    "Einzel": foreach tile in ( GetConfigStringArray( cfgeinzel[element[1]], "tile" ) ) 
      if ( !tiles ) 
        tiles := { tile }; 
      else 
        tiles.append( tile ); 
      endif 
    endforeach 

    "Set": tiles := element[1]; 

  endcase 
  return ( { element, tiles, tiles1 } ); 
endfunction // }}} 

// /////////////////////////////////
// CreateRandom - ...
// /////////////////////////////////

function CreateRandom( who, byref ret, byref tiles, byref tiles1, byref color, byref element ) 
                       // {{{ 
  var tar1, tar2, item, x, y, z, Tarx, Tary, Tarx2, Tary2, itemdef, items := {}, 
                                                                                 itemserials := {}; 

  SendSysMessage( who, "Target first corner" ); 
  tar1 := TargetCoordinates( who ); 
  if ( tar1 ) 
    SendSysMessage( who, "Target the second corner" ); 
    tar2 := TargetCoordinates( who ); 
    if ( tar2 ) 
      if ( ( tar1.item ) || ( tar2.item ) ) 
        if ( ( tar1.item.container ) || ( tar2.item.container ) ) 
          SendSysMessage( who, "cancellation. Item in Container targeted!" ); 
          return; 
        endif 
      endif 
      if ( tar1.x >= tar2.x ) // Sorting the area 
        Tarx := tar2.x; 
        Tarx2 := tar1.x; 
      else 
        Tarx := tar1.x; 
        Tarx2 := tar2.x; 
      endif 
      if ( tar1.y >= tar2.y ) 
        Tary := tar2.y; 
        Tary2 := tar1.y; 
      else 
        Tary := tar1.y; 
        Tary2 := tar2.y; 
      endif 
      if ( ( ( Tarx2 - Tarx ) > MAXAREASIZE ) || ( ( Tary2 - Tary ) > MAXAREASIZE ) ) 
        SendSysMessage( who, "Cancellation.  " + MAXAREASIZE + "x" + MAXAREASIZE + " Generate items!" ); 
        return; 
      endif 
      z := ret[ITEMPOS]; 
      z[1, 6] := ""; 
      z := CInt( z ); 
      // Begrenzte Ausdehnung?
      if ( GetConfigString( cfgrandom[element], "x" ) ) 
        Tarx2 := Tarx + CInt( GetConfigString( cfgrandom[element], "x" ) ) - 1; 
      endif 
      if ( GetConfigString( cfgrandom[element], "y" ) ) 
        Tary2 := Tary + CInt( GetConfigString( cfgrandom[element], "y" ) ) - 1; 
      endif 
      if ( ret[ITEMRAND] ) // Random items are to be generated 
        for ( x := Tarx; x <= Tarx2; x += 1 ) 
          for ( y := Tary; y <= Tary2; y += 1 ) 
            if ( ( x == Tarx ) && ( y == Tary ) ) // NW corner 
              itemdef := GetConfigString( cfgrandom[element], "nw" ); 
              if ( !itemdef ) 
                SendSysMessage( who, "NW corner is missing." ); 
              else 
                itemdef := SplitWords( itemdef ); 
                itemdef := ChooseRandom( itemdef ); 
                itemdef := SplitWords( itemdef, "," ); 
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, 
                                              CInt( itemdef[1] ), 1, who.realm ); 
                if ( item ) 
                  item.color := color; 
                  item.movable := 0; 
                  items.append( item ); 
                else 
                  SendSysMessage( who, "Create Error!  " + x + " " + y + " " + ( tar1.z + CInt( 
                                  itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); 
                endif 
              endif 
              // Create second item
              itemdef := GetConfigString( cfgrandom[element], "nw1" ); 
              if ( ( itemdef ) && ( itemdef <> {} ) ) 
                itemdef := SplitWords( itemdef ); 
                itemdef := ChooseRandom( itemdef ); 
                itemdef := SplitWords( itemdef, "," ); 
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, 
                                              CInt( itemdef[1] ), 1, who.realm ); 
                if ( item ) 
                  item.color := color; 
                  item.movable := 0; 
                  items.append( item ); 
                else 
                  SendSysMessage( who, "Create error! NW-Corner 2nd item" + x + " " + y + " " + ( tar1.z + CInt( 
                                  itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); 
                endif 
              endif 
            elseif ( ( x == Tarx2 ) && ( y == Tary ) ) // NE corner 
              itemdef := GetConfigString( cfgrandom[element], "no" ); 
              if ( !itemdef ) 
                SendSysMessage( who, "NE corner missing." ); 
              else 
                itemdef := SplitWords( itemdef ); 
                itemdef := ChooseRandom( itemdef ); 
                itemdef := SplitWords( itemdef, "," ); 
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, 
                                              CInt( itemdef[1] ), 1, who.realm ); 
                if ( item ) 
                  item.color := color; 
                  item.movable := 0; 
                  items.append( item ); 
                else 
                  SendSysMessage( who, "Create error! NE-corner Item " + x + " " + y + " " + ( tar1.z + CInt( 
                                  itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); 
                endif 
              endif 
              // Create second item
              itemdef := GetConfigString( cfgrandom[element], "no1" ); 
              if ( ( itemdef ) && ( itemdef <> {} ) ) 
                itemdef := SplitWords( itemdef ); 
                itemdef := ChooseRandom( itemdef ); 
                itemdef := SplitWords( itemdef, "," ); 
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, 
                                              CInt( itemdef[1] ), 1, who.realm ); 
                if ( item ) 
                  item.color := color; 
                  item.movable := 0; 
                  items.append( item ); 
                else 
                  SendSysMessage( who, "Create error! NE-Corner 2nd item " + x + " " + y + " " + ( tar1.z + CInt( 
                                  itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); 
                endif 
              endif 
            elseif ( ( x == Tarx2 ) && ( y == Tary2 ) ) // SE corner 
              itemdef := GetConfigString( cfgrandom[element], "so" ); 
              if ( !itemdef ) 
                SendSysMessage( who, "SE-Corner is missing." ); 
              else 
                itemdef := SplitWords( itemdef ); 
                itemdef := ChooseRandom( itemdef ); 
                itemdef := SplitWords( itemdef, "," ); 
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, 
                                              CInt( itemdef[1] ), 1, who.realm ); 
                if ( item ) 
                  item.color := color; 
                  item.movable := 0; 
                  items.append( item ); 
                else 
                  SendSysMessage( who, "Create error! SO-Ecke Item " + x + " " + y + " " + ( tar1.z + CInt( 
                                  itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); 
                endif 
              endif 
              // Create second item
              itemdef := GetConfigString( cfgrandom[element], "so1" ); 
              if ( ( itemdef ) && ( itemdef <> {} ) ) 
                itemdef := SplitWords( itemdef ); 
                itemdef := ChooseRandom( itemdef ); 
                itemdef := SplitWords( itemdef, "," ); 
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, 
                                              CInt( itemdef[1] ), 1, who.realm ); 
                if ( item ) 
                  item.color := color; 
                  item.movable := 0; 
                  items.append( item ); 
                else 
                  SendSysMessage( who, "Create error! SE-Corner 2nd item " + x + " " + y + " " + ( tar1.z + CInt( 
                                  itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); 
                endif 
              endif 
            elseif ( ( x == Tarx ) && ( y == Tary2 ) ) // SW corner 
              itemdef := GetConfigString( cfgrandom[element], "sw" ); 
              if ( !itemdef ) 
                SendSysMessage( who, "SW-Corner is missing." ); 
              else 
                itemdef := SplitWords( itemdef ); 
                itemdef := ChooseRandom( itemdef ); 
                itemdef := SplitWords( itemdef, "," ); 
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, 
                                              CInt( itemdef[1] ), 1, who.realm ); 
                if ( item ) 
                  item.color := color; 
                  item.movable := 0; 
                  items.append( item ); 
                else 
                  SendSysMessage( who, "Create error! SW-corner Item " + x + " " + y + " " + ( tar1.z + CInt( 
                                  itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); 
                endif 
              endif 
              // Create second item
              itemdef := GetConfigString( cfgrandom[element], "sw1" ); 
              if ( ( itemdef ) && ( itemdef <> {} ) ) 
                itemdef := SplitWords( itemdef ); 
                itemdef := ChooseRandom( itemdef ); 
                itemdef := SplitWords( itemdef, "," ); 
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, 
                                              CInt( itemdef[1] ), 1, who.realm ); 
                if ( item ) 
                  item.color := color; 
                  item.movable := 0; 
                  items.append( item ); 
                else 
                  SendSysMessage( who, "Create error! SW-Corner 2nd item " + x + " " + y + " " + ( tar1.z + CInt( 
                                  itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); 
                endif 
              endif 
            elseif ( y == Tary ) // N page 
              itemdef := GetConfigString( cfgrandom[element], "n" ); 
              if ( !itemdef ) 
                SendSysMessage( who, "N-Page is missing." ); 
              else 
                itemdef := SplitWords( itemdef ); 
                itemdef := ChooseRandom( itemdef ); 
                itemdef := SplitWords( itemdef, "," ); 
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, 
                                              CInt( itemdef[1] ), 1, who.realm ); 
                if ( item ) 
                  item.color := color; 
                  item.movable := 0; 
                  items.append( item ); 
                else 
                  SendSysMessage( who, "Create error! N-Item page " + x + " " + y + " " + ( tar1.z + CInt( 
                                  itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); 
                endif 
              endif 
              // Create second item
              itemdef := GetConfigString( cfgrandom[element], "n1" ); 
              if ( ( itemdef ) && ( itemdef <> {} ) ) 
                itemdef := SplitWords( itemdef ); 
                itemdef := ChooseRandom( itemdef ); 
                itemdef := SplitWords( itemdef, "," ); 
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, 
                                              CInt( itemdef[1] ), 1, who.realm ); 
                if ( item ) 
                  item.color := color; 
                  item.movable := 0; 
                  items.append( item ); 
                else 
                  SendSysMessage( who, "Create error! N-Page 2nd item " + x + " " + y + " " + ( tar1.z + CInt( 
                                  itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); 
                endif 
              endif 
            elseif ( x == Tarx2 ) // E side 
              itemdef := GetConfigString( cfgrandom[element], "o" ); 
              if ( !itemdef ) 
                SendSysMessage( who, "E-side is missing." ); 
              else 
                itemdef := SplitWords( itemdef ); 
                itemdef := ChooseRandom( itemdef ); 
                itemdef := SplitWords( itemdef, "," ); 
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, 
                                              CInt( itemdef[1] ), 1, who.realm ); 
                if ( item ) 
                  item.color := color; 
                  item.movable := 0; 
                  items.append( item ); 
                else 
                  SendSysMessage( who, "Create error! E-side item " + x + " " + y + " " + ( tar1.z + CInt( 
                                  itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); 
                endif 
              endif 
              // Create second item
              itemdef := GetConfigString( cfgrandom[element], "o1" ); 
              if ( ( itemdef ) && ( itemdef <> {} ) ) 
                itemdef := SplitWords( itemdef ); 
                itemdef := ChooseRandom( itemdef ); 
                itemdef := SplitWords( itemdef, "," ); 
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, 
                                              CInt( itemdef[1] ), 1, who.realm ); 
                if ( item ) 
                  item.color := color; 
                  item.movable := 0; 
                  items.append( item ); 
                else 
                  SendSysMessage( who, "Create error! E-side 2nd item " + x + " " + y + " " + ( tar1.z + CInt( 
                                  itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); 
                endif 
              endif 
            elseif ( y == Tary2 ) // S side 
              itemdef := GetConfigString( cfgrandom[element], "s" ); 
              if ( !itemdef ) 
                SendSysMessage( who, "S side is missing." ); 
              else 
                itemdef := SplitWords( itemdef ); 
                itemdef := ChooseRandom( itemdef ); 
                itemdef := SplitWords( itemdef, "," ); 
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, 
                                              CInt( itemdef[1] ), 1, who.realm ); 
                if ( item ) 
                  item.color := color; 
                  item.movable := 0; 
                  items.append( item ); 
                else 
                  SendSysMessage( who, "Create error! S-Item page " + x + " " + y + " " + ( tar1.z + CInt( 
                                  itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); 
                endif 
              endif 
              // Create second item
              itemdef := GetConfigString( cfgrandom[element], "s1" ); 
              if ( ( itemdef ) && ( itemdef <> {} ) ) 
                itemdef := SplitWords( itemdef ); 
                itemdef := ChooseRandom( itemdef ); 
                itemdef := SplitWords( itemdef, "," ); 
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, 
                                              CInt( itemdef[1] ), 1, who.realm ); 
                if ( item ) 
                  item.color := color; 
                  item.movable := 0; 
                  items.append( item ); 
                else 
                  SendSysMessage( who, "Create error! S-side 2nd item " + x + " " + y + " " + ( tar1.z + CInt( 
                                  itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); 
                endif 
              endif 
            elseif ( x == Tarx ) // W page 
              itemdef := GetConfigString( cfgrandom[element], "w" ); 
              if ( !itemdef ) 
                SendSysMessage( who, "W-Page is missing." ); 
              else 
                itemdef := SplitWords( itemdef ); 
                itemdef := ChooseRandom( itemdef ); 
                itemdef := SplitWords( itemdef, "," ); 
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, 
                                              CInt( itemdef[1] ), 1, who.realm ); 
                if ( item ) 
                  item.color := color; 
                  item.movable := 0; 
                  items.append( item ); 
                else 
                  SendSysMessage( who, "Create error! W side item " + x + " " + y + " " + ( tar1.z + CInt( 
                                  itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); 
                endif 
              endif 
              // Create second item
              itemdef := GetConfigString( cfgrandom[element], "w1" ); 
              if ( ( itemdef ) && ( itemdef <> {} ) ) 
                itemdef := SplitWords( itemdef ); 
                itemdef := ChooseRandom( itemdef ); 
                itemdef := SplitWords( itemdef, "," ); 
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, 
                                              CInt( itemdef[1] ), 1, who.realm ); 
                if ( item ) 
                  item.color := color; 
                  item.movable := 0; 
                  items.append( item ); 
                else 
                  SendSysMessage( who, "Create error! W-Page 2nd item " + x + " " + y + " " + ( tar1.z + CInt( 
                                  itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); 
                endif 
              endif 
            else // centerpiece 
              itemdef := ChooseRandom( tiles ); 
              if ( !itemdef ) 
                SendSysMessage( who, "Middle piece is missing." ); 
              else 
                itemdef := SplitWords( itemdef, "," ); 
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, 
                                              CInt( itemdef[1] ), 1, who.realm ); 
                if ( item ) 
                  item.color := color; 
                  item.movable := 0; 
                  items.append( item ); 
                else 
                  SendSysMessage( who, "Create error! Midsection item " + x + " " + y + " " + ( tar1.z + CInt( 
                                  itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); 
                endif 
              endif 
              // Create second item
              itemdef := tiles1.randomentry(); 
              if ( ( itemdef ) && ( itemdef <> {} ) ) 
                itemdef := SplitWords( itemdef, "," ); 
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, 
                                              CInt( itemdef[1] ), 1, who.realm ); 
                if ( item ) 
                  item.color := color; 
                  item.movable := 0; 
                  items.append( item ); 
                else 
                  SendSysMessage( who, "Create error! Middle part 2nd item " + x + " " + y + " " + ( tar1.z + CInt( 
                                  itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); 
                endif 
              endif 
            endif 
            SleepMS( 5 ); 
          endfor 
        endfor 

      else // Boring version without a border 
        for ( x := Tarx; x <= Tarx2; x += 1 ) 
          for ( y := Tary; y <= Tary2; y += 1 ) 
            itemdef := ChooseRandom( tiles ); 
            if ( !itemdef ) 
              SendSysMessage( who, "Middle piece is missing." ); 
            else 
              itemdef := SplitWords( itemdef, "," ); 
              item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, 
                                            CInt( itemdef[1] ), 1, who.realm ); 
              if ( item ) 
                item.color := color; 
                item.movable := 0; 
                items.append( item ); 
              else 
                SendSysMessage( who, "Create error! Item " + x + " " + y + " " + ( tar1.z + CInt( 
                                itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); 
              endif 
            endif 
            // Create second item
            itemdef := tiles1.randomentry(); 
            if ( ( itemdef ) && ( itemdef <> {} ) ) 
              itemdef := SplitWords( itemdef, "," ); 
              item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, 
                                            CInt( itemdef[1] ), 1, who.realm ); 
              if ( item ) 
                item.color := color; 
                item.movable := 0; 
                items.append( item ); 
              else 
                SendSysMessage( who, "Create error! 2nd Item " + x + " " + y + " " + ( tar1.z + CInt( 
                                itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); 
              endif 
            endif 
            SleepMS( 5 ); 
          endfor 
        endfor 

      endif 
      // Save item series
      foreach item in ( items ) 
        item.setprop( CPROP_INIT, items[1].serial ); 
        SleepMS( 2 ); 
      endforeach 
      foreach item in ( items ) 
        itemserials.append( item.serial ); 
        SleepMS( 2 ); 
      endforeach 
      items[1].setprop( CPROP_ITEMS, itemserials ); 

      if ( ret[ITEMMODIFY] ) // Change position 
        if ( !ModifyItems( who, items ) ) 
          return; 
        endif 
      endif 
    else 
      SendSysMessage( who, "Abort" ); 
    endif 
  else 
    SendSysMessage( who, "Abort" ); 
  endif 
endfunction // }}} 

// /////////////////////////////////
// Create singles - ...
// /////////////////////////////////

function CreateEinzel( who, byref ret, byref tiles, byref color ) // {{{ 
  var z, itemdef := {}, iTarget, item, items := {}, itemserials := {}; 

  if ( !tiles[ret.keys[2]] ) 
    SendSysMessage( who, "No item selected" ); 
    return; 
  endif 
  SendSysMessage( who, "Target position" ); 
  z := ret[ITEMPOS]; 
  z[1, 6] := ""; 
  z := CInt( z ); 
  itemdef[1] := CInt( SplitWords( tiles[ret.keys[2]], "," )[1] ); // Objtype 
  itemdef[2] := CInt( SplitWords( tiles[ret.keys[2]], "," )[2] ); // Feste z-Koords 
  iTarget := TargetCoordinates( who ); 
  if ( iTarget.item ) 
    if ( iTarget.item.container ) 
      SendSysMessage( who, "cancellation. Item in Container targeted!" ); 
      return; 
    endif 
  endif 
  while ( iTarget ) // Endless to ESC 
    item := CreateItemAtLocation( iTarget.x, iTarget.y, iTarget.z + itemdef[2] + z, 
                                  itemdef[1], 1, who.realm ); 
    if ( item ) 
      item.color := color; 
      item.movable := 0; 
      // Save item series
      if ( !ret[ITEMMMULTICREATE] ) 
        item.setprop( CPROP_INIT, item.serial ); 
        item.setprop( CPROP_ITEMS, { item.serial } ); 
        if ( ret[ITEMMODIFY] ) // Change position 
          if ( !ModifyItems( who, item ) ) 
            SendSysMessage( who, "Abort" ); 
            return; 
          endif 
        endif 
      else 
        items.append( item ); 
      endif 
    else 
      SendSysMessage( who, "Create error! Item " + iTarget.x + " " + iTarget.y + " " + ( iTarget.z + itemdef[2] + z ) + " " + Hex( 
                      tiles[ret.keys[2]] ) + " ErrorText: " + item.errortext ); 
    endif 
    iTarget := TargetCoordinates( who ); 
  endwhile 
  if ( ret[ITEMMMULTICREATE] ) 
    // Itemserials to save
    foreach item in ( items ) 
      item.setprop( CPROP_INIT, items[1].serial ); 
    endforeach 
    foreach item in ( items ) 
      itemserials.append( item.serial ); 
    endforeach 
    items[1].setprop( CPROP_ITEMS, itemserials ); 
    if ( ret[ITEMMODIFY] ) // Postion to change 
      ModifyItems( who, items ); 
    endif 
  endif 
  SendSysMessage( who, "Abort" ); 
endfunction // }}} 

// /////////////////////////////////
// CreateSet - ...
// /////////////////////////////////

function CreateSet( unused who, byref unused ret, byref unused set, byref unused color ) 
/* Var iTarget, items, itemserials:={}, wholeitems:={};
  Var z:=ret[ITEMPOS];
  z[1,6]:="";
  z:=CInt(z);

  iTarget:=TargetCoordinates(who);
  If (iTarget.item)
    If (iTarget.item.container)
      SendSysMessage(who,"cancellation. Item in Container targeted!");
      Return;
    EndIf
  EndIf
  While (iTarget)  // Endless to ESC
    iTarget.z:=iTarget.z+z;
    items:=MakeSet(iTarget, set, 1)[2];
    If (items)
      If (color)
        ForEach item in items
          item.color:=color;
          SleepMS(2);
        EndForEach
      EndIf
      If (!ret[ITEMMMULTICREATE])
        // Save item series
        itemserials:={};
        ForEach item in items
          item.setprop(CPROP_INIT,items[1].serial);
          SleepMS(2);
        EndForEach
        ForEach item in items
          itemserials.append(item.serial);
          SleepMS(2);
        EndForEach
        items[1].setprop(CPROP_ITEMS,itemserials);

        If (ret[ITEMMODIFY])  // Change position
          If (!ModifyItems(who,items))
            Return;
          EndIf
        EndIf
      Else
        ForEach item in items
          wholeitems.append(item);
          SleepMS(2);
        EndForEach
      EndIf
    Else
      SendSysMessage(who,"Something went wrong.");
      Return;
    EndIf
    iTarget:=TargetCoordinates(who);
  EndWhile
  If (ret[ITEMMMULTICREATE])
    // Save item series
    ForEach item in wholeitems
      item.setprop(CPROP_INIT,wholeitems[1].serial);
      SleepMS(2);
    EndForEach
    ForEach item in wholeitems
      itemserials.append(item.serial);
      SleepMS(2);
    EndForEach
    wholeitems[1].setprop(CPROP_ITEMS,itemserials);
    If (ret[ITEMMODIFY])  // Change position
      ModifyItems(who,items);
    EndIf
  EndIf
  SendSysMessage(who, "Abort"); */
endfunction 

// /////////////////////////////////
// ModifyItemsManual - ...
// /////////////////////////////////

function ModifyItemsManual( who ) // {{{ 
  var retmodify, tar, inititem, items := {}, itemserials := {}, color, zstart, zend, temp, i, obj, tempitems := {}; 
  var tar1, tar2, x1, x2, y1, y2, breakflag; 
  var dupe := {}, dupeitem, dupeserials := {}; 

  while ( who.connected ) 
    if ( items <> {} ) 
      datamodify_M[COLORDATAPOS] := items[1].color; 
      datamodify_M[XKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>" + items[1].x + "</p></basefont>"; 
      datamodify_M[YKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>" + items[1].y + "</p></basefont>"; 
      datamodify_M[ZKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>" + items[1].z + "</p></basefont>"; 
      datamodify_M[XENTRY] := items[1].x; 
      datamodify_M[YENTRY] := items[1].y; 
      datamodify_M[ZENTRY] := items[1].z; 
    else 
      datamodify_M[COLORDATAPOS] := "0"; 
      datamodify_M[XKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>x</p></basefont>"; 
      datamodify_M[YKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>y</p></basefont>"; 
      datamodify_M[ZKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>z</p></basefont>"; 
      datamodify_M[XENTRY] := 0; 
      datamodify_M[YENTRY] := 0; 
      datamodify_M[ZENTRY] := 0; 
    endif 
    retmodify := SendDialogGump( who, layoutmodify_M, datamodify_M, 10, 50 ); 
    if ( retmodify[MODIFY_START] ) 
      if ( !retmodify[MODIFY_CUSTOM] ) // Search for .bautool items 
        tar := Target( who, TGTOPT_NOCHECK_LOS ); 
        if ( tar ) 
          if ( ( !tar.getprop( CPROP_ITEMS ) ) && ( tar.getprop( CPROP_INIT ) ) ) 
            inititem := SystemFindObjectBySerial( tar.getprop( CPROP_INIT ) ); 
            if ( inititem ) 
              itemserials := inititem.getprop( CPROP_ITEMS ); 
              items := {}; 
              tempitems := {}; 
              foreach item in ( itemserials ) 
                obj := SystemFindObjectBySerial( item ); 
                if ( obj ) 
                  if ( CInt( obj.getprop( CPROP_INIT ) ) == CInt( inititem.serial ) ) 
                       // it belongs to the same group 
                    items.append( obj ); 
                    tempitems.append( obj.serial ); 
                  endif 
                endif 
                SleepMS( 5 ); 
              endforeach 
              inititem.setprop( CPROP_ITEMS, tempitems ); // save filtered serials 
              if ( ( !items ) || ( items == {} ) ) 
                SendSysMessage( who, "Items could not be found. " ); 
              else 
                SendSysMessage( who, items.size() + " Items recognized." ); 
              endif 
            else 
              SendSysMessage( who, "Init item not found. " ); 
              items := RecoverInitItem( tar ); 
            // items:={};
            endif 
          elseif ( tar.getprop( CPROP_ITEMS ) ) 
            itemserials := tar.getprop( CPROP_ITEMS ); 
            items := {}; 
            tempitems := {}; 
            foreach item in ( itemserials ) 
              obj := SystemFindObjectBySerial( item ); 
              if ( obj ) 
                if ( CInt( obj.getprop( CPROP_INIT ) ) == CInt( tar.serial ) ) // it belongs to the same group 
                  items.append( obj ); 
                  tempitems.append( obj.serial ); 
                endif 
              endif 
              SleepMS( 5 ); 
            endforeach 
            tar.setprop( CPROP_ITEMS, tempitems ); // save filtered serials 
            SendSysMessage( who, items.size() + " Items recognized." ); 
          else 
            SendSysMessage( who, "Invalid Item selected." ); 
          endif 
        else 
          SendSysMessage( who, "Abort" ); 
          items := {}; 
        endif 
      else // Search for any items 
        zstart := retmodify[MODIFY_Z_START]; 
        zstart[1, 6] := ""; 
        zstart := CInt( zstart ); 
        zend := retmodify[MODIFY_Z_END]; 
        zend[1, 6] := ""; 
        zend := CInt( zend ); 
        datamodify_M[ZSTARTPOS] := zstart; 
        datamodify_M[ZENDPOS] := zend; 
        SendSysMessage( who, "Target the first corner of the area" ); 
        tar1 := TargetCoordinates( who ); 
        if ( tar1 ) 
          SendSysMessage( who, "Target the second corner of the area" ); 
          tar2 := TargetCoordinates( who ); 
          if ( tar2 ) 
            if ( tar1.x > tar2.x ) // Sorting the area 
              x1 := tar2.x; 
              x2 := tar1.x; 
            else 
              x1 := tar1.x; 
              x2 := tar2.x; 
            endif 
            if ( tar1.y > tar2.y ) 
              y1 := tar2.y; 
              y2 := tar1.y; 
            else 
              y1 := tar1.y; 
              y2 := tar2.y; 
            endif 
            items := {}; 
            foreach item in ( ListObjectsInBox( x1, y1, zstart, x2, y2, zend, tar2.realm ) ) 
              if ( item.isA( POLCLASS_ITEM ) ) 
                if ( !item.invisible ) // Don't take invisible stuff like spawn runes 
                  items.append( item ); 
                endif 
              endif 
              SleepMS( 5 ); 
            endforeach 
            if ( items <> {} ) 
              SendSysMessage( who, items.size() + " Items recognized." ); 
              if ( retmodify[MODIFY_MARK] ) 
                // Save item series
                itemserials := {}; 
                foreach item in ( items ) 
                  itemserials.append( item.serial ); 
                  SleepMS( 2 ); 
                endforeach 
                SendSysMessage( who, "Choose the original item." ); 
                breakflag := 0; 
                while ( who.connected ) 
                  tar := Target( who, TGTOPT_NOCHECK_LOS ); 
                  if ( tar ) 
                    i := tar.serial in itemserials; 
                    if ( i ) // Move the selected item to the first position 
                      temp := itemserials[1]; 
                      itemserials[i] := temp; 
                      itemserials[1] := tar.serial; 
                      foreach item in ( items ) 
                        item.setprop( CPROP_INIT, tar.serial ); 
                        item.eraseprop( CPROP_ITEMS ); 
                        SleepMS( 2 ); 
                      endforeach 
                      tar.setprop( CPROP_ITEMS, itemserials ); 
                      break; 
                    else 
                      SendSysMessage( who, "Item is not among those recognized!" ); 
                    endif 
                  else 
                    SendSysMessage( who, "Abort" ); 
                    breakflag := 1; 
                    break; 
                  endif 
                endwhile 
                items := {}; 
                if ( !breakflag ) 
                  foreach item in ( itemserials ) // Reordering and final check 
                    obj := SystemFindObjectBySerial( item ); 
                    if ( obj ) 
                      items.append( obj ); 
                    endif 
                    SleepMS( 5 ); 
                  endforeach 
                  SendSysMessage( who, ".. and branded." ); 
                endif 
              endif 
            else 
              SendSysMessage( who, "No items recognized." ); 
            endif 
          else 
            SendSysMessage( who, "Abort" ); 
            items := {}; 
          endif 
        else 
          SendSysMessage( who, "Abort" ); 
          items := {}; 
        endif 
      endif 
    else 
      if ( retmodify.keys[retmodify.keys.size()] > MODIFY_START ) 
        if ( items <> {} ) 
          if ( retmodify[MODIFY_Y_UP] ) 
            foreach item in ( items ) 
              MoveObjectToLocation( item, item.x, item.y + 1, item.z, item.realm, 
                                    ITEMMOVEFLAGS ); 
              SleepMS( 2 ); 
            endforeach 
          elseif ( retmodify[MODIFY_Y_DOWN] ) 
            foreach item in ( items ) 
              MoveObjectToLocation( item, item.x, item.y - 1, item.z, item.realm, 
                                    ITEMMOVEFLAGS ); 
              SleepMS( 2 ); 
            endforeach 
          elseif ( retmodify[MODIFY_X_UP] ) 
            foreach item in ( items ) 
              MoveObjectToLocation( item, item.x + 1, item.y, item.z, item.realm, 
                                    ITEMMOVEFLAGS ); 
              SleepMS( 2 ); 
            endforeach 
          elseif ( retmodify[MODIFY_X_DOWN] ) 
            foreach item in ( items ) 
              MoveObjectToLocation( item, item.x - 1, item.y, item.z, item.realm, 
                                    ITEMMOVEFLAGS ); 
              SleepMS( 2 ); 
            endforeach 
          elseif ( retmodify[MODIFY_XY_MM] ) 
            foreach item in ( items ) 
              MoveObjectToLocation( item, item.x - 1, item.y - 1, item.z, item.realm, 
                                    ITEMMOVEFLAGS ); 
              SleepMS( 2 ); 
            endforeach 
          elseif ( retmodify[MODIFY_XY_PM] ) 
            foreach item in ( items ) 
              MoveObjectToLocation( item, item.x + 1, item.y - 1, item.z, item.realm, 
                                    ITEMMOVEFLAGS ); 
              SleepMS( 2 ); 
            endforeach 
          elseif ( retmodify[MODIFY_XY_MP] ) 
            foreach item in ( items ) 
              MoveObjectToLocation( item, item.x - 1, item.y + 1, item.z, item.realm, 
                                    ITEMMOVEFLAGS ); 
              SleepMS( 2 ); 
            endforeach 
          elseif ( retmodify[MODIFY_XY_PP] ) 
            foreach item in ( items ) 
              MoveObjectToLocation( item, item.x + 1, item.y + 1, item.z, item.realm, 
                                    ITEMMOVEFLAGS ); 
              SleepMS( 2 ); 
            endforeach 
          elseif ( retmodify[MODIFY_Z_UP] ) 
            foreach item in ( items ) 
              MoveObjectToLocation( item, item.x, item.y, item.z + 1, item.realm, 
                                    ITEMMOVEFLAGS ); 
              SleepMS( 2 ); 
            endforeach 
          elseif ( retmodify[MODIFY_Z_DOWN] ) 
            foreach item in ( items ) 
              MoveObjectToLocation( item, item.x, item.y, item.z - 1, item.realm, 
                                    ITEMMOVEFLAGS ); 
              SleepMS( 2 ); 
            endforeach 
          elseif ( retmodify[MODIFY_DESTROY] ) 
            foreach item in ( items ) 
              DestroyItem( item ); 
              SleepMS( 2 ); 
            endforeach 
            items := {}; 
          elseif ( retmodify[MODIFY_COLOR] ) 
            color := retmodify[ITEMCOLOR]; 
            color[1, 6] := ""; 
            color := CInt( color ); 
            foreach item in ( items ) 
              item.color := color; 
              SleepMS( 2 ); 
            endforeach 
          elseif ( retmodify[MODIFY_DUPE] ) 
            dupe := {}; 
            dupeserials := {}; 
            foreach item in ( items ) 
              dupeitem := CreateItemCopyAtLocation( item.x, item.y, item.z, item, 
                                                    item.realm ); 
              if ( dupeitem ) 
                dupe.append( dupeitem ); 
                dupeserials.append( dupeitem.serial ); 
              endif 
              SleepMS( 2 ); 
            endforeach 
            foreach item in ( dupe ) 
              item.setprop( CPROP_INIT, dupeserials[1] ); 
              SleepMS( 2 ); 
            endforeach 
            dupe[1].setprop( CPROP_ITEMS, dupeserials ); 
            SendSysMessage( who, dupe.size() + " Items successfully duplicated." ); 
            items := dupe; // Continue working with a copy 
          elseif ( retmodify[MODIFY_X] ) 
            temp := retmodify[MODIFY_X_ENTRY]; 
            temp[1, 6] := ""; 
            temp := CInt( temp ) - items[1].x; 
            foreach item in ( items ) 
              MoveObjectToLocation( item, item.x + temp, item.y, item.z, item.realm, 
                                    ITEMMOVEFLAGS ); 
              SleepMS( 2 ); 
            endforeach 
          elseif ( retmodify[MODIFY_Y] ) 
            temp := retmodify[MODIFY_Y_ENTRY]; 
            temp[1, 6] := ""; 
            temp := CInt( temp ) - items[1].y; 
            foreach item in ( items ) 
              MoveObjectToLocation( item, item.x, item.y + temp, item.z, item.realm, 
                                    ITEMMOVEFLAGS ); 
              SleepMS( 2 ); 
            endforeach 
          elseif ( retmodify[MODIFY_Z] ) 
            temp := retmodify[MODIFY_Z_ENTRY]; 
            temp[1, 6] := ""; 
            temp := CInt( temp ) - items[1].z; 
            foreach item in ( items ) 
              MoveObjectToLocation( item, item.x, item.y, item.z + temp, item.realm, 
                                    ITEMMOVEFLAGS ); 
              SleepMS( 2 ); 
            endforeach 
          endif 
        else 
          SendSysMessage( who, "No items selected." ); 
        endif 
      elseif ( retmodify[MODIFY_MARKEDIT] ) 
        MarkEdit( who ); 
      else // Gump closed 
        SendSysMessage( who, "Abort" ); 
        break; 
      endif 
    endif 
  endwhile 
endfunction // }}} 

// /////////////////////////////////
// MarkEdit - Possibility to change the groups
// /////////////////////////////////

function MarkEdit( who ) // {{{ 
  var ret, tar1, tar2, x1, x2, y1, y2, items := {}, itemref, inititem, itemserials, tempitems, obj, i; 

  while ( who.connected ) 
    ret := SendDialogGump( who, layoutmark, datamark, 10, 50 ); 

    if ( ret[MARK_SHOW] ) 
      SendSysMessage( who, "Target the first corner of the area" ); 
      tar1 := TargetCoordinates( who ); 
      if ( tar1 ) 
        SendSysMessage( who, "Target the second corner of the area" ); 
        tar2 := TargetCoordinates( who ); 
        if ( tar2 ) 
          if ( tar1.x > tar2.x ) // Sorting the area 
            x1 := tar2.x; 
            x2 := tar1.x; 
          else 
            x1 := tar1.x; 
            x2 := tar2.x; 
          endif 
          if ( tar1.y > tar2.y ) 
            y1 := tar2.y; 
            y2 := tar1.y; 
          else 
            y1 := tar1.y; 
            y2 := tar2.y; 
          endif 
          items := {}; 
          foreach item in ( ListObjectsInBox( x1, y1, -127, x2, y2, 128, tar2.realm ) ) // Items besorgen 
            if ( item.isA( POLCLASS_ITEM ) ) 
              if ( item.getprop( CPROP_ITEMS ) ) 
                items.append( item ); 
              endif 
            endif 
            SleepMS( 5 ); 
          endforeach 
          if ( items <> {} ) 
            foreach item in ( items ) // Coloring by groups 
              foreach slaveitem in ( item.getprop( CPROP_ITEMS ) ) 
                itemref := SystemFindObjectBySerial( slaveitem ); 
                if ( itemref ) 
                  if ( itemref.getprop( CPROP_COLOR ).errortext ) 
                    itemref.setprop( CPROP_COLOR, itemref.color ); 
                  endif 
                  itemref.color := _item_iter + 6; 
                endif 
                SleepMS( 5 ); 
              endforeach 
            endforeach 
          endif 
        endif 
      endif 

    elseif ( ret[MARK_HIDE] ) 
      SendSysMessage( who, "Target the first corner of the area" ); 
      tar1 := TargetCoordinates( who ); 
      if ( tar1 ) 
        SendSysMessage( who, "Target the second corner of the area" ); 
        tar2 := TargetCoordinates( who ); 
        if ( tar2 ) 
          if ( tar1.x > tar2.x ) // Sorting the area 
            x1 := tar2.x; 
            x2 := tar1.x; 
          else 
            x1 := tar1.x; 
            x2 := tar2.x; 
          endif 
          if ( tar1.y > tar2.y ) 
            y1 := tar2.y; 
            y2 := tar1.y; 
          else 
            y1 := tar1.y; 
            y2 := tar2.y; 
          endif 
          items := {}; 
          foreach item in ( ListObjectsInBox( x1, y1, -127, x2, y2, 128, tar2.realm ) ) // Items besorgen 
            if ( item.isA( POLCLASS_ITEM ) ) 
              if ( item.getprop( CPROP_ITEMS ) ) 
                items.append( item ); 
              endif 
            endif 
            SleepMS( 5 ); 
          endforeach 
          if ( items <> {} ) 
            foreach item in ( items ) // Coloring by groups 
              foreach slaveitem in ( item.getprop( CPROP_ITEMS ) ) 
                itemref := SystemFindObjectBySerial( slaveitem ); 
                if ( itemref ) 
                  if ( itemref.getprop( CPROP_COLOR ).errortext ) 
                    itemref.setprop( CPROP_COLOR, itemref.color ); 
                  endif 
                  itemref.color := _item_iter + 6; 
                endif 
                SleepMS( 5 ); 
              endforeach 
            endforeach 
          endif 

          foreach item in ( ListObjectsInBox( x1, y1, -128, x2, y2, 127, tar2.realm ) ) // Freset work 
            if ( item.isA( POLCLASS_ITEM ) ) 
              if ( ( item.getprop( CPROP_ITEMS ) ) && ( !item.getprop( CPROP_COLOR ).errortext ) ) 
                foreach slaveitem in ( item.getprop( CPROP_ITEMS ) ) 
                  itemref := SystemFindObjectBySerial( slaveitem ); 
                  if ( itemref ) 
                    if ( !itemref.getprop( CPROP_COLOR ).errortext ) 
                      itemref.color := CInt( item.getprop( CPROP_COLOR ) ); 
                      itemref.eraseprop( CPROP_COLOR ); 
                    endif 
                  endif 
                  SleepMS( 5 ); 
                endforeach 
              endif 
            endif 
            SleepMS( 5 ); 
          endforeach 
        endif 
      endif 

    elseif ( ret[MARK_EDIT] ) 
      SendSysMessage( who, "Selects the item group." ); 
      tar1 := Target( who, TGTOPT_NOCHECK_LOS ); 
      items := {}; 
      tempitems := {}; 
      if ( ( !tar1.getprop( CPROP_ITEMS ) ) && ( tar1.getprop( CPROP_INIT ) ) ) 
        inititem := SystemFindObjectBySerial( tar1.getprop( CPROP_INIT ) ); 
        if ( inititem ) 
          itemserials := inititem.getprop( CPROP_ITEMS ); 
          foreach item in ( itemserials ) 
            obj := SystemFindObjectBySerial( item ); 
            if ( obj ) 
              if ( ( CInt( obj.getprop( CPROP_INIT ) ) == CInt( inititem.serial ) ) && 
                   ( !( obj.serial in tempitems ) ) ) // it belongs to the same group 
                items.append( obj ); 
                tempitems.append( obj.serial ); 
                if ( obj.getprop( CPROP_COLOR ).errortext ) 
                  obj.setprop( CPROP_COLOR, obj.color ); 
                endif 
                obj.color := 1281; 
              endif 
            endif 
            SleepMS( 5 ); 
          endforeach 
          inititem.setprop( CPROP_ITEMS, tempitems ); // save filtered serials 
          if ( ( !items ) || ( items == {} ) ) 
            SendSysMessage( who, "Items could not be found. " ); 
          else 
            SendSysMessage( who, items.size() + " Items recognized." ); 
          endif 
        else 
          SendSysMessage( who, "Init item not found. " ); 
          items := RecoverInitItem( tar1 ); 
        // items:={};
        endif 
      elseif ( tar1.getprop( CPROP_ITEMS ) ) 
        itemserials := tar1.getprop( CPROP_ITEMS ); 
        foreach item in ( itemserials ) 
          obj := SystemFindObjectBySerial( item ); 
          if ( obj ) 
            if ( CInt( obj.getprop( CPROP_INIT ) ) == CInt( tar1.serial ) ) // it belongs to the same group 
              items.append( obj ); 
              tempitems.append( obj.serial ); 
              if ( obj.getprop( CPROP_COLOR ).errortext ) 
                obj.setprop( CPROP_COLOR, obj.color ); 
              endif 
              obj.color := 1281; 
            endif 
          endif 
          SleepMS( 5 ); 
        endforeach 
        tar1.setprop( CPROP_ITEMS, tempitems ); // save filtered serials 
        SendSysMessage( who, items.size() + " Items recognized." ); 
      else 
        SendSysMessage( who, "No items recognized." ); 
      endif 
      if ( items <> {} ) 
        while ( who.connected ) 
          SendSysMessage( who, "Selects the item to be added / removed." ); 
          tar1 := Target( who, TGTOPT_NOCHECK_LOS ); 
          if ( ( !tar1 ) && ( !tar1.isA( POLCLASS_ITEM ) ) ) 
            SendSysMessage( who, "Abort" ); 
            break; 
          endif 
          i := tar1.serial in tempitems; 
          if ( i ) // Remove from group 
            tempitems.erase( i ); 
            items.erase( i ); 
            tar1.eraseprop( CPROP_INIT ); 
            tar1.eraseprop( CPROP_ITEMS ); 
            if ( !tar1.getprop( CPROP_COLOR ).errortext ) 
              tar1.color := CInt( tar1.getprop( CPROP_COLOR ) ); 
              tar1.eraseprop( CPROP_COLOR ); 
            endif 
          else // Add 
            if ( tar1.getprop( CPROP_COLOR ).errortext ) 
              tar1.setprop( CPROP_COLOR, tar1.color ); 
            endif 
            tar1.color := items[1].color; 
            tempitems.append( tar1.serial ); 
            items.append( tar1 ); 
          endif 
        endwhile 

        foreach item in ( items ) 
          item.setprop( CPROP_INIT, items[1].serial ); 
          item.eraseprop( CPROP_ITEMS ); 
        endforeach 
        items[1].setprop( CPROP_ITEMS, tempitems ); 
        foreach item in ( items ) 
          if ( !item.getprop( CPROP_COLOR ).errortext ) 
            item.color := CInt( item.getprop( CPROP_COLOR ) ); 
            item.eraseprop( CPROP_COLOR ); 
          endif 
          SleepMS( 1 ); 
        endforeach 
      endif 
    else 
      if ( x1 ) // If something has been done, reset the color 
        foreach item in ( ListObjectsInBox( x1, y1, -128, x2, y2, 127, tar2.realm ) ) // Freset work 
          if ( item.isA( POLCLASS_ITEM ) ) 
            if ( ( item.getprop( CPROP_ITEMS ) ) && ( !item.getprop( CPROP_COLOR ).errortext ) ) 
              foreach slaveitem in ( item.getprop( CPROP_ITEMS ) ) 
                itemref := SystemFindObjectBySerial( slaveitem ); 
                if ( itemref ) 
                  if ( !itemref.getprop( CPROP_COLOR ).errortext ) 
                    itemref.color := CInt( item.getprop( CPROP_COLOR ) ); 
                    itemref.eraseprop( CPROP_COLOR ); 
                  endif 
                endif 
                SleepMS( 5 ); 
              endforeach 
            endif 
          endif 
          SleepMS( 5 ); 
        endforeach 
      endif 
      SendSysMessage( who, "Abort" ); 
      return; 
    endif 
  endwhile 
endfunction // }}} 

// /////////////////////////////////
// ModifyItems - Position / color change after creation
// /////////////////////////////////

function ModifyItems( who, byref items ) // {{{ 
  var retmodify, color, temp, dupe := {}, dupeitem, dupeserials := {}; 

  if ( TypeOfInt( items ) != OT_ARRAY ) 
    temp := items; 
    items := {}; 
    items.append( temp ); 
  endif 
  while ( who.connected ) 
    datamodify[COLORDATAPOS] := items[1].color; 
    datamodify[XKOORDSPOS] := "<basefont color=" + HTML_WHITE + "><p align=right>" + items[1].x + "</p></basefont>"; 
    datamodify[YKOORDSPOS] := "<basefont color=" + HTML_WHITE + "><p align=right>" + items[1].y + "</p></basefont>"; 
    datamodify[ZKOORDSPOS] := "<basefont color=" + HTML_WHITE + "><p align=right>" + items[1].z + "</p></basefont>"; 
    datamodify[XENTRY] := items[1].x; 
    datamodify[YENTRY] := items[1].y; 
    datamodify[ZENTRY] := items[1].z; 
    retmodify := SendDialogGump( who, layoutmodify, datamodify, 10, 50 ); 
    if ( retmodify[MODIFY_Y_UP] ) 
      foreach item in ( items ) 
        MoveObjectToLocation( item, item.x, item.y + 1, item.z, item.realm, ITEMMOVEFLAGS ); 
        SleepMS( 2 ); 
      endforeach 
    elseif ( retmodify[MODIFY_Y_DOWN] ) 
      foreach item in ( items ) 
        MoveObjectToLocation( item, item.x, item.y - 1, item.z, item.realm, ITEMMOVEFLAGS ); 
        SleepMS( 2 ); 
      endforeach 
    elseif ( retmodify[MODIFY_X_UP] ) 
      foreach item in ( items ) 
        MoveObjectToLocation( item, item.x + 1, item.y, item.z, item.realm, ITEMMOVEFLAGS ); 
        SleepMS( 2 ); 
      endforeach 
    elseif ( retmodify[MODIFY_X_DOWN] ) 
      foreach item in ( items ) 
        MoveObjectToLocation( item, item.x - 1, item.y, item.z, item.realm, ITEMMOVEFLAGS ); 
        SleepMS( 2 ); 
      endforeach 
    elseif ( retmodify[MODIFY_XY_MM] ) 
      foreach item in ( items ) 
        MoveObjectToLocation( item, item.x - 1, item.y - 1, item.z, item.realm, ITEMMOVEFLAGS ); 
        SleepMS( 2 ); 
      endforeach 
    elseif ( retmodify[MODIFY_XY_PM] ) 
      foreach item in ( items ) 
        MoveObjectToLocation( item, item.x + 1, item.y - 1, item.z, item.realm, ITEMMOVEFLAGS ); 
        SleepMS( 2 ); 
      endforeach 
    elseif ( retmodify[MODIFY_XY_MP] ) 
      foreach item in ( items ) 
        MoveObjectToLocation( item, item.x - 1, item.y + 1, item.z, item.realm, ITEMMOVEFLAGS ); 
        SleepMS( 2 ); 
      endforeach 
    elseif ( retmodify[MODIFY_XY_PP] ) 
      foreach item in ( items ) 
        MoveObjectToLocation( item, item.x + 1, item.y + 1, item.z, item.realm, ITEMMOVEFLAGS ); 
        SleepMS( 2 ); 
      endforeach 
    elseif ( retmodify[MODIFY_Z_UP] ) 
      foreach item in ( items ) 
        MoveObjectToLocation( item, item.x, item.y, item.z + 1, item.realm, ITEMMOVEFLAGS ); 
        SleepMS( 2 ); 
      endforeach 
    elseif ( retmodify[MODIFY_Z_DOWN] ) 
      foreach item in ( items ) 
        MoveObjectToLocation( item, item.x, item.y, item.z - 1, item.realm, ITEMMOVEFLAGS ); 
        SleepMS( 2 ); 
      endforeach 
    elseif ( retmodify[MODIFY_DESTROY] ) 
      foreach item in ( items ) 
        DestroyItem( item ); 
        SleepMS( 2 ); 
      endforeach 
      break; 
    elseif ( retmodify[MODIFY_COLOR] ) 
      color := retmodify[ITEMCOLOR]; 
      color[1, 6] := ""; 
      color := CInt( color ); 
      foreach item in ( items ) 
        item.color := color; 
        SleepMS( 2 ); 
      endforeach 
    elseif ( retmodify[MODIFY_DUPE] ) 
      dupe := {}; 
      dupeserials := {}; 
      foreach item in ( items ) 
        dupeitem := CreateItemCopyAtLocation( item.x, item.y, item.z, item, item.realm ); 
        if ( dupeitem ) 
          dupe.append( dupeitem ); 
          dupeserials.append( dupeitem.serial ); 
        endif 
        SleepMS( 2 ); 
      endforeach 
      foreach item in ( dupe ) 
        item.setprop( CPROP_INIT, dupeserials[1] ); 
        SleepMS( 2 ); 
      endforeach 
      dupe[1].setprop( CPROP_ITEMS, dupeserials ); 
      SendSysMessage( who, dupe.size() + " Items successfully duplicated." ); 
      items := dupe; // Edit copy further 
    elseif ( retmodify[MODIFY_X] ) 
      temp := retmodify[MODIFY_X_ENTRY]; 
      temp[1, 6] := ""; 
      temp := CInt( temp ) - items[1].x; 
      foreach item in ( items ) 
        MoveObjectToLocation( item, item.x + temp, item.y, item.z, item.realm, ITEMMOVEFLAGS ); 
        SleepMS( 2 ); 
      endforeach 
    elseif ( retmodify[MODIFY_Y] ) 
      temp := retmodify[MODIFY_Y_ENTRY]; 
      temp[1, 6] := ""; 
      temp := CInt( temp ) - items[1].y; 
      foreach item in ( items ) 
        MoveObjectToLocation( item, item.x, item.y + temp, item.z, item.realm, ITEMMOVEFLAGS ); 
        SleepMS( 2 ); 
      endforeach 
    elseif ( retmodify[MODIFY_Z] ) 
      temp := retmodify[MODIFY_Z_ENTRY]; 
      temp[1, 6] := ""; 
      temp := CInt( temp ) - items[1].z; 
      foreach item in ( items ) 
        MoveObjectToLocation( item, item.x, item.y, item.z + temp, item.realm, ITEMMOVEFLAGS ); 
        SleepMS( 2 ); 
      endforeach 
    elseif ( retmodify[BACKBUTTON] ) 
      break; 
    else 
      return ( 0 ); // Abbruch 
    endif 
  endwhile 
  return ( 1 ); 
endfunction // }}} 

// /////////////////////////////////
// ChooseRandom - Random determination of the items
// /////////////////////////////////

function ChooseRandom( byref liste ) // {{{ 
  var verteilung := 0, i; 
  var rand := RandomInt( 100 ) + 1; 
  if ( Find( liste[1], "%", 1 ) ) // Distribution according to Cfg 
    for ( i := 1; i <= liste.size(); i += 1 ) 
      verteilung += CInt( SplitWords( liste[i], "%" )[2] ); 
      if ( rand <= verteilung ) 
        return ( SplitWords( liste[i], "%" )[1] ); 
      endif 
    endfor 

  else // Gleichverteilt 
    verteilung := CInt( 100 / liste.size() ); 
    for ( i := 1; i <= liste.size(); i += 1 ) 
      if ( rand <= ( i * verteilung ) ) // within the probability? 
        return ( liste[i] ); // Shoo Shoo 
      endif 
    endfor 

  endif 
  return ( liste.randomentry() ); // well then just like that 
endfunction // }}} 

// /////////////////////////////////
// MenuBar - Creates the NavBar
// /////////////////////////////////

function MenuBar( byref layout, byref data, byref datadict ) // {{{ 
  var i, page := 1, y := 66, nextpagebreak := MAXBUTTON + 1; 
  if ( TypeOfInt( datadict ) == OT_DICTIONARY ) // Data in dictionary or array 
    for ( i := 1; i <= datadict.keys().size(); i += 1 ) 
      if ( i == nextpagebreak ) 
        nextpagebreak += MAXBUTTON; 
        y := 66; 
        page += 1; 
        layout.append( "button 565 287 5602 5606 0 " + page ); 
        layout.append( "page " + page ); 
        layout.append( "button 580 287 5600 5604 0 " + ( page - 1 ) ); 
      endif 
      layout.append( "button 525 " + ( y ) + " 2440 2440 1 0 " + ( MENUSTART + i ) ); 
      // layout.append("resizepic 525 "+(y)+" 9250 166 25");
      layout.append( "htmlgump 525 " + ( y ) + " 166 25 " + data.size() + " 1 0" ); 
      if ( ( cfgrandom[datadict.keys()[i]] ) && ( cfgrandom[datadict.keys()[i]].name ) ) 
        data.append( "<basefont color=" + HTML_DARKGRAY + "><center>" + cfgrandom[datadict.keys()[
                     i]].name + "</center>" ); 
      elseif ( ( cfgeinzel[datadict.keys()[i]] ) && ( cfgeinzel[datadict.keys()[i]].name ) ) 
        data.append( "<basefont color=" + HTML_DARKBLUE + "><center>" + cfgeinzel[datadict.keys()[
                     i]].name + "</center>" ); 
      elseif ( cfgset[datadict.keys()[i]].name ) 
        data.append( "<basefont color=" + HTML_DARKBLUE + "><center>" + cfgset[datadict.keys()[
                     i]].name + "</center>" ); 
      else 
        data.append( "<basefont color=" + HTML_DARKGRAY + "><center>" + datadict.keys()[
                     i] + "</center>" ); 
      endif 
      y += 30; 
    endfor 

  else 
    for ( i := 1; i <= datadict.size(); i += 1 ) 
      if ( i == nextpagebreak ) 
        nextpagebreak += MAXBUTTON; 
        y := 66; 
        page += 1; 
        layout.append( "button 565 287 5602 5606 0 " + page + " 0" ); 
        layout.append( "page " + page ); 
        layout.append( "button 580 287 5600 5604 0 " + ( page - 1 ) + " 0" ); 
      endif 
      layout.append( "button 525 " + ( y ) + " 2440 2440 1 0 " + ( MENUSTART + i ) ); 
      // layout.append("resizepic 525 "+(y)+" 9250 166 25");
      layout.append( "htmlgump 525 " + ( y ) + " 166 25 " + data.size() + " 1 0" ); 
      if ( TypeOfInt( datadict[i] ) == OT_ARRAY ) // Typebezeichnung im Array 
        if ( ( cfgrandom[datadict[i][1]].name ) || ( cfgeinzel[datadict[i][1]].name ) || 
             ( cfgset[datadict[i][1]].name ) ) 
          case ( datadict[i][2] ) 
            "Random": data.append( "<basefont color=" + HTML_SADDLEBROWN + "><center>" + cfgrandom[datadict[i][1]].name + "</center>" ); 
            "Einzel": data.append( "<basefont color=" + HTML_SADDLEBROWN + "><center>" + cfgeinzel[datadict[i][1]].name + "</center>" ); 
            "Set": data.append( "<basefont color=" + HTML_SADDLEBROWN + "><center>" + cfgset[datadict[i][1]].name + "</center>" ); 
          endcase 
        else 
          data.append( "<basefont color=" + HTML_SADDLEBROWN + "><center>" + datadict[i][1] + "</center>" ); 
        endif 
      endif 
      y += 30; 
    endfor 

  endif 
endfunction // }}} 

// /////////////////////////////////
// Init - Generates layout & data in a data file (server restart / hermit)
// /////////////////////////////////

function Init() // {{{ 
  var layoutraw := { "nodispose", "page 0" // "resizepic 500 0 3600 215 390",  // Background 
                     // "resizepic 515 15 5054 185 30",  // title
                     , "resizepic 500 0 9200 215 390", "resizepic 515 15 3000 185 30", 
                     "htmlgump 515 22 185 30 0 0 0" // Title text 
                     // "gumppictiled 516 47 183 328 2624", 
                     // "resizepic 516 47 83 183 328",   // Posts
                     , "resizepic 516 47 3000 183 328" // "checkertrans 524 57 168 308",
                     , "htmlgump 610 285 50 20 1 0 0", "button 660 280 9726 9728 1 0 " + BACKBUTTON, 
                     "gumppictiled 525 320 166 2 30002", "button 530 330 9721 9724 1 0 " + ITEMMODIFYMANUAL, 
                     "htmlgump 572 335 100 30 2 0 0", "page 1" }; 
  var dataraw := { "" // Titel
                   , "<basefont color=" + HTML_DARKBLUE + ">Back", "<basefont color=" + HTML_DARKBLUE + ">Item Modify" }; 

  SysLog( ".BAUTOOL Datafile begin" ); 
  SetGlobalProperty( "bautoolinit", 1 ); 

  var dataelement, layout := {}, data := {}, layoutp := {}; 
  var element := dictionary{}; 
  var cfgmenu := ReadConfigFile( "bautoolmenues" ); 

  DFPurgeFile( datafile ); 

  // Layout to build
  dataelement := datafile.CreateElement( "menu" ); 

  // Read out the cfgmenu and insert the 3 cfgs
  foreach key in ( GetConfigStringArray( cfgmenu["Rootlist"], "sublist" ) ) // 1. level 
    element[key] := dictionary{}; 

    if ( cfgmenu[key].list ) // Items 
      foreach itemlist in ( GetConfigStringArray( cfgmenu[key], "list" ) ) 
        element[key][itemlist] := array{}; 
        foreach itemkey in ( GetConfigStringKeys( cfgrandom ) ) // Insert possible random 
          if ( cfgrandom[itemkey].list == itemlist ) 
            element[key][itemlist].append( { itemkey, "Random", cfgrandom[itemkey].name } 
                                           ); 
          endif 
          SleepMS( 2 ); 
        endforeach 
        foreach itemkey in ( GetConfigStringKeys( cfgeinzel ) ) // Insert possible single 
          if ( cfgeinzel[itemkey].list == itemlist ) 
            element[key][itemlist].append( { itemkey, "Einzel", cfgeinzel[itemkey].name } 
                                           ); 
          endif 
          SleepMS( 2 ); 
        endforeach 
        foreach itemkey in ( GetConfigStringKeys( cfgset ) ) // Insert possible sets 
          if ( cfgset[itemkey].list == itemlist ) 
            element[key][itemlist].append( { itemkey, "Set", cfgset[itemkey].name } 
                                           ); 
          endif 
          SleepMS( 2 ); 
        endforeach 
        element[key][itemlist] := SortArrayABC( element[key][itemlist], 1, 3 ); 
      endforeach 
    endif 

    if ( cfgmenu[key].sublist ) 
      foreach sub1key in ( GetConfigStringArray( cfgmenu[key], "sublist" ) ) // 2. level 
        element[key][sub1key] := dictionary{}; 

        if ( cfgmenu[sub1key].list ) // Items 
          foreach itemlist in ( GetConfigStringArray( cfgmenu[sub1key], "list" ) ) 
            element[key][sub1key][itemlist] := array{}; 
            foreach itemkey in ( GetConfigStringKeys( cfgrandom ) ) // Insert possible random 
              if ( cfgrandom[itemkey].list == itemlist ) 
                element[key][sub1key][itemlist].append( { itemkey, "Random", cfgrandom[itemkey].name } 
                                                        ); 
              endif 
              SleepMS( 2 ); 
            endforeach 
            foreach itemkey in ( GetConfigStringKeys( cfgeinzel ) ) // Insert possible single 
              if ( cfgeinzel[itemkey].list == itemlist ) 
                element[key][sub1key][itemlist].append( { itemkey, "Einzel", cfgeinzel[itemkey].name } 
                                                        ); 
              endif 
              SleepMS( 2 ); 
            endforeach 
            foreach itemkey in ( GetConfigStringKeys( cfgset ) ) // Insert possible sets 
              if ( cfgset[itemkey].list == itemlist ) 
                element[key][sub1key][itemlist].append( { itemkey, "Set", cfgset[itemkey].name } 
                                                        ); 
              endif 
              SleepMS( 2 ); 
            endforeach 
            element[key][sub1key][itemlist] := SortArrayABC( element[key][sub1key][itemlist], 
                                                             1, 3 ); 
          endforeach 
        endif 

        if ( cfgmenu[sub1key].sublist ) 
          foreach sub2key in ( GetConfigStringArray( cfgmenu[sub1key], "sublist" ) ) // 3. level 
            element[key][sub1key][sub2key] := dictionary{}; 

            if ( cfgmenu[sub2key].list ) // Items 
              foreach itemlist in ( GetConfigStringArray( cfgmenu[sub2key], "list" ) ) 
                element[key][sub1key][sub2key][itemlist] := array{}; 
                foreach itemkey in ( GetConfigStringKeys( cfgrandom ) ) // Insert possible random 
                  if ( cfgrandom[itemkey].list == itemlist ) 
                    element[key][sub1key][sub2key][itemlist].append( { itemkey, "Random", 
                                                                     cfgrandom[itemkey].name } 
                                                                     ); 
                  endif 
                  SleepMS( 2 ); 
                endforeach 
                foreach itemkey in ( GetConfigStringKeys( cfgeinzel ) ) // Insert possible single 
                  if ( cfgeinzel[itemkey].list == itemlist ) 
                    element[key][sub1key][sub2key][itemlist].append( { itemkey, "Einzel", 
                                                                     cfgeinzel[itemkey].name } 
                                                                     ); 
                  endif 
                  SleepMS( 2 ); 
                endforeach 
                foreach itemkey in ( GetConfigStringKeys( cfgset ) ) // Insert possible sets 
                  if ( cfgset[itemkey].list == itemlist ) 
                    element[key][sub1key][sub2key][itemlist].append( { itemkey, "Set", 
                                                                     cfgset[itemkey].name } 
                                                                     ); 
                  endif 
                  SleepMS( 2 ); 
                endforeach 
                element[key][sub1key][sub2key][itemlist] := SortArrayABC( element[key][sub1key][sub2key][itemlist], 
                                                                          1, 3 ); 
              endforeach 
            endif 

            if ( cfgmenu[sub2key].sublist ) 
              foreach sub3key in ( GetConfigStringArray( cfgmenu[sub2key], "sublist" ) ) // 4. level 
                element[key][sub1key][sub2key][sub3key] := dictionary{}; 

                if ( cfgmenu[sub3key].list ) // Items 
                  foreach itemlist in ( GetConfigStringArray( cfgmenu[sub3key], "list" ) ) 
                    element[key][sub1key][sub2key][sub3key][itemlist] := array{}; 
                    foreach itemkey in ( GetConfigStringKeys( cfgrandom ) ) // Insert possible random 
                      if ( cfgrandom[itemkey].list == itemlist ) 
                        element[key][sub1key][sub2key][sub3key][itemlist].append( 
                                                                                  { 
                                                                                  itemkey, 
                                                                                  "Random", 
                                                                                  cfgrandom[itemkey].name } 
                                                                                  ); 
                      endif 
                      SleepMS( 2 ); 
                    endforeach 
                    foreach itemkey in ( GetConfigStringKeys( cfgeinzel ) ) // Insert possible single 
                      if ( cfgeinzel[itemkey].list == itemlist ) 
                        element[key][sub1key][sub2key][sub3key][itemlist].append( 
                                                                                  { 
                                                                                  itemkey, 
                                                                                  "Einzel", 
                                                                                  cfgeinzel[itemkey].name } 
                                                                                  ); 
                      endif 
                      SleepMS( 2 ); 
                    endforeach 
                    foreach itemkey in ( GetConfigStringKeys( cfgset ) ) // Insert possible sets 
                      if ( cfgset[itemkey].list == itemlist ) 
                        element[key][sub1key][sub2key][sub3key][itemlist].append( 
                                                                                  { 
                                                                                  itemkey, 
                                                                                  "Set", 
                                                                                  cfgset[itemkey].name } 
                                                                                  ); 
                      endif 
                      SleepMS( 2 ); 
                    endforeach 
                    element[key][sub1key][sub2key][sub3key][itemlist] := SortArrayABC( 
                                                                                       element[key][sub1key][sub2key][sub3key][itemlist], 
                                                                                       1, 
                                                                                       3 ); 
                  endforeach 
                endif 
              endforeach 
            endif 
          endforeach 
        endif 
      endforeach 
    endif 
  endforeach 

  // Rootlist
  layout := layoutraw; 
  data := dataraw; 
  MenuBar( layout, data, element ); 
  data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>BauTool " + VERSION + "</center>"; 
                                                                                                      // Titel 

  dataelement.setprop( "LayoutMenuBar", layout ); 
  dataelement.setprop( "DataMenuBar", data ); 

  foreach ebene1 in ( element ) // 1. level 
    layout := layoutraw; 
    data := dataraw; 
    MenuBar( layout, data, ebene1 ); 
    data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene1_iter + "</center>"; 
                                                                                                     // Titel 
    dataelement.setprop( "LayoutMain_" + _ebene1_iter, layout ); 
    dataelement.setprop( "DataMain_" + _ebene1_iter, data ); 

    foreach ebene2 in ( ebene1 ) // 2.level 
      layout := layoutraw; 
      data := dataraw; 
      MenuBar( layout, data, ebene2 ); 
      data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene2_iter + "</center>"; 
                                                                                                       // Titel 
      dataelement.setprop( "LayoutSub_" + _ebene1_iter + "_" + _ebene2_iter, layout ); 
      dataelement.setprop( "DataSub_" + _ebene1_iter + "_" + _ebene2_iter, data ); 

      if ( TypeOfInt( ebene2 ) <> OT_DICTIONARY ) // Items 
        foreach item in ( ebene2 ) 
          InitItems( data, layout, item, _ebene2_iter, layoutraw, dataraw ); 
          dataelement.setprop( "LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + item[1], 
                               layout ); 
          dataelement.setprop( "DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + item[1], 
                               data ); 
          SleepMS( 2 ); 
        endforeach 
      else 
        foreach ebene3 in ( ebene2 ) // 3.level 
          layout := layoutraw; 
          data := dataraw; 
          MenuBar( layout, data, ebene3 ); 
          data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene3_iter + "</center>"; 
                                                                                                           // Titel 
          dataelement.setprop( "LayoutSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter, 
                               layout ); 
          dataelement.setprop( "DataSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter, 
                               data ); 

          if ( TypeOfInt( ebene3 ) <> OT_DICTIONARY ) // Items 
            foreach item in ( ebene3 ) 
              InitItems( data, layout, item, _ebene3_iter, layoutraw, dataraw ); 
              dataelement.setprop( "LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + item[1], 
                                   layout ); 
              dataelement.setprop( "DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + item[1], 
                                   data ); 
              SleepMS( 2 ); 
            endforeach 
          else 
            foreach ebene4 in ( ebene3 ) // 4.level 
              layout := layoutraw; 
              data := dataraw; 
              MenuBar( layout, data, ebene4 ); 
              data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene4_iter + "</center>"; 
                                                                                                               // Titel 
              dataelement.setprop( "LayoutSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter, 
                                   layout ); 
              dataelement.setprop( "DataSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter, 
                                   data ); 

              if ( TypeOfInt( ebene4 ) <> OT_DICTIONARY ) // Items 
                foreach item in ( ebene4 ) 
                  InitItems( data, layout, item, _ebene4_iter, layoutraw, dataraw ); 
                  dataelement.setprop( "LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + item[1], 
                                       layout ); 
                  dataelement.setprop( "DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + item[1], 
                                       data ); 
                  SleepMS( 2 ); 
                endforeach 
              else 
                foreach ebene5 in ( ebene4 ) // 5.level 
                  layout := layoutraw; 
                  data := dataraw; 
                  MenuBar( layout, data, ebene5 ); 
                  data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene5_iter + "</center>"; 
                                                                                                                   // Titel 
                  dataelement.setprop( "LayoutSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter, 
                                       layout ); 
                  dataelement.setprop( "DataSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter, 
                                       data ); 

                  if ( TypeOfInt( ebene5 ) <> OT_DICTIONARY ) // Items 
                    foreach item in ( ebene5 ) 
                      InitItems( data, layout, item, _ebene5_iter, layoutraw, dataraw ); 
                      dataelement.setprop( "LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter + "_" + item[1], 
                                           layout ); 
                      dataelement.setprop( "DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter + "_" + item[1], 
                                           data ); 
                      SleepMS( 2 ); 
                    endforeach 
                  else 
                    foreach ebene6 in ( ebene5 ) // 6.level 
                      InitItems( data, layout, ebene6, _ebene6_iter, layoutraw, dataraw ); 
                      dataelement.setprop( "LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter + "_" + _ebene6_iter, 
                                           layout ); 
                      dataelement.setprop( "DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter + "_" + _ebene6_iter, 
                                           data ); 
                      SleepMS( 2 ); 
                    endforeach 
                  endif 
                endforeach 
              endif 
            endforeach 
          endif 
        endforeach 
      endif 
    endforeach 
  endforeach 

  // ModifyItem Menu
  dataelement := datafile.CreateElement( "modify" ); 
  layout := { "nodispose", "page 0", "resizepic 500 0 3600 215 280" // Background
              , "resizepic 515 15 5054 185 30" // title
              , "htmlgump 515 22 185 30 0 0 0" // Title text
              , "resizepic 515 47 83 185 218" // Posts
              , "checkertrans 523 57 170 198", "htmlgump 610 225 50 20 1 0 0" // Continue
              , "htmlgump 555 79 50 20 2 0 0" // X/Y
              , "htmlgump 624 79 50 20 3 0 0" // Z
              , "button 660 220 9721 9724 1 0 " + BACKBUTTON, "button 560 60 5600 5604 1 0 " + MODIFY_Y_DOWN, 
              "button 560 100 5602 5606 1 0 " + MODIFY_Y_UP, "button 530 80 5603 5607 1 0 " + MODIFY_X_DOWN, 
              "button 590 80 5601 5605 1 0 " + MODIFY_X_UP, "button 534 60 22406 22407 1 0 " + MODIFY_XY_MM, 
              "button 583 60 22401 22400 1 0 " + MODIFY_XY_PM, "button 534 100 22403 22402 1 0 " + MODIFY_XY_MP, 
              "button 583 100 22404 22405 1 0 " + MODIFY_XY_PP, "button 620 60 5600 5604 1 0 " + MODIFY_Z_UP, 
              "button 620 100 5602 5606 1 0 " + MODIFY_Z_DOWN, "htmlgump 570 165 50 20 4 0 0", 
              "button 530 160 9727 9728 1 0 " + MODIFY_DESTROY, "htmlgump 570 200 50 30 10 0 0", 
              "button 530 195 9727 9728 1 0 " + MODIFY_DUPE, "htmlgump 570 130 50 30 5 0 0", 
              "resizepic 610 125 2620 58 30", "textentry 616 130 40 20 1000 " + ITEMCOLOR + " 6", 
              "button 530 125 9727 9728 1 0 " + MODIFY_COLOR, "htmlgump 630 60 50 20 7 0 0" // x / y / z Coord Specification of the first item
              , "tooltip 3000561" // Coords.:
              , "htmlgump 630 80 50 20 8 0 0", "tooltip 3000561", "htmlgump 630 100 50 20 9 0 0", 
              "tooltip 3000561", "button 681 64 2103 2104 0 2 0", "button 681 84 2103 2104 0 3 0", 
              "button 681 104 2103 2104 0 4 0" }; 

  data := { "<basefont size=8 color=" + HTML_DARKGREEN + "><center>Modify Position</center>" // title
            , "<basefont color=" + HTML_DARKBLUE + ">Continue", "<basefont color=" + HTML_DARKBLUE + ">X/Y", 
            "<basefont color=" + HTML_DARKBLUE + ">Z", "<basefont color=" + HTML_DARKBLUE + ">Destroy", 
            "<basefont color=" + HTML_DARKBLUE + ">Color", "0", "<basefont color=" + HTML_DARKBLUE + "><p align=right>x</p></basefont>", 
            "<basefont color=" + HTML_DARKBLUE + "><p align=right>y</p></basefont>", 
            "<basefont color=" + HTML_DARKBLUE + "><p align=right>z</p></basefont>", 
            "<basefont color=" + HTML_DARKBLUE + ">Dupe", "0", "0", "0" }; 
  layoutp := { "page 2", "resizepic 720 40 3600 100 60", "resizepic 735 55 2620 48 30", 
               "textentrylimited 741 60 30 20 1000 " + MODIFY_X_ENTRY + " 11 4", 
               "button 790 63 2103 2104 1 0 " + MODIFY_X, "page 3", "resizepic 720 60 3600 100 60", 
               "resizepic 735 75 2620 48 30", "textentrylimited 741 80 30 20 1000 " + MODIFY_Y_ENTRY + " 12 4", 
               "button 790 83 2103 2104 1 0 " + MODIFY_Y, "page 4", "resizepic 720 80 3600 100 60", 
               "resizepic 735 95 2620 48 30", "textentrylimited 741 100 30 20 1000 " + MODIFY_Z_ENTRY + " 13 4", 
               "button 790 103 2103 2104 1 0 " + MODIFY_Z }; 

  dataelement.setprop( "LayoutMenu", layout + layoutp ); 
  dataelement.setprop( "DataMenu", data ); 

  // manual Modify
  layout[3] := "resizepic 500 0 3600 215 440"; // Background expand 
  layout[6] := "resizepic 516 47 83 183 377"; 
  layout[7] := "checkertrans 524 57 168 358"; 
  layout.erase( 8 ); // Next ButtonText 
  layout.erase( 10 ); // Next button 
  layout.append( "gumppictiled 525 235 165 2 30002" ); 
  layout.append( "htmlgump 595 255 100 20 1 0 0" ); 
  layout.append( "button 560 250 9721 9724 1 0 " + MODIFY_START ); 
  data[2] := "<basefont color=" + HTML_DARKBLUE + ">Choose Items"; 
  layout.append( "resizepic 530 285 2620 48 30" ); 
  layout.append( "textentry 536 290 30 20 1000 " + MODIFY_Z_START + " 14" ); 
  data.append( "-20" ); 
  layout.append( "resizepic 635 285 2620 48 30" ); 
  layout.append( "textentry 641 290 30 20 1000 " + MODIFY_Z_END + " 15" ); 
  data.append( "20" ); 
  layout.append( "htmlgump 585 290 50 20 16 0 0" ); 
  data.append( "<basefont color=" + HTML_DARKBLUE + ">Z-Range" ); 
  layout.append( "checkbox 530 320 9720 9723 0 " + MODIFY_CUSTOM ); 
  layout.append( "htmlgump 565 325 50 20 17 0 0" ); 
  data.append( "<basefont color=" + HTML_DARKBLUE + ">Custom" ); 
  layout.append( "checkbox 616 320 9720 9723 0 " + MODIFY_MARK ); 
  layout.append( "htmlgump 651 325 50 20 18 0 0" ); 
  data.append( "<basefont color=" + HTML_DARKBLUE + ">Mark" ); 
  layout.append( "gumppictiled 525 360 165 2 30002" ); 
  layout.append( "button 530 375 9721 9724 1 0 " + MODIFY_MARKEDIT ); 
  layout.append( "htmlgump 570 380 100 20 19 0 0" ); 
  data.append( "<basefont color=" + HTML_DARKBLUE + ">Mark Edit" ); 
  dataelement.setprop( "LayoutMenuManual", layout + layoutp ); 
  dataelement.setprop( "DataMenuManual", data ); 

  // Mark Edit
  dataelement := datafile.CreateElement( "modifymark" ); 
  layout := { "nodispose", "page 0", "resizepic 500 0 3600 215 213" // Background
              , "resizepic 515 15 5054 185 30" // title
              , "htmlgump 515 22 185 30 0 0 0" // Title text
              , "resizepic 515 47 83 185 150" // Posts-20
              , "checkertrans 523 57 170 130", "button 530 70 9721 9724 1 0 " + MARK_SHOW, 
              "htmlgump 570 75 50 20 1 0 0", "button 530 105 9721 9724 1 0 " + MARK_HIDE, 
              "htmlgump 570 110 50 20 2 0 0", "button 530 140 9721 9724 1 0 " + MARK_EDIT, 
              "htmlgump 570 145 50 20 3 0 0" }; 
  data := { "<basefont size=8 color=" + HTML_DARKGRAY + "><center>Mark Edit</center>", 
            "<basefont color=" + HTML_DARKBLUE + ">Show", "<basefont color=" + HTML_DARKBLUE + ">Hide", 
            "<basefont color=" + HTML_DARKBLUE + ">Edit" }; 
  dataelement.setprop( "LayoutMenuMark", layout ); 
  dataelement.setprop( "DataMenuMark", data ); 

  // Save the dict of the menus / items
  dataelement := datafile.CreateElement( "elemente" ); 
  dataelement.setprop( "dictionary", element ); 

  EraseGlobalProperty( "bautoolinit" ); 
  SysLog( ".BAUTOOL Datafile completed" ); 

endfunction // }}} 

// /////////////////////////////////
// InitItems - Outsourcing for the init function
// /////////////////////////////////

function InitItems( byref data, byref layout, byref element, name := 0, layoutraw, 
                    dataraw ) // {{{ 
  var tile, nextpagebreak, nextlinebreak, x, y, page, m, itemdesc; 
  case ( element[2] ) 
    "Random": // Random 
              layout := layoutraw; 
    data := dataraw; 
    data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + name + "</center>"; 
                                                                                             // TESTTESTTEST 
    layout := layout + { "page 0", "resizepic 70 0 3600 404 170", "resizepic 85 15 5054 374 30", 
                         "htmlgump 85 22 374 30 " + data.size() + " 0 0", "resizepic 85 47 83 374 108", 
                         "checkertrans 93 57 359 88" }; 
    data.append( "<basefont size=5><center>" + cfgrandom[element[1]].name + "</center>" ); 
    tile := GetConfigStringArray( cfgrandom[element[1]], "tile" )[1]; 
    layout.append( "tilepic 95 60 " + CInt( SplitWords( tile, "," )[1] ) ); 
    layout.append( "htmlgump 160 70 50 30 " + data.size() + " 0 0" ); 
    data.append( "<basefont color=" + HTML_DARKBLUE + ">Color" ); 
    layout.append( "resizepic 200 65 2620 48 30" ); 
    layout.append( "textentry 206 70 30 20 1000 " + ITEMCOLOR + " " + data.size() 
                   ); 
    data.append( "0" ); 
    if ( ( GetConfigString( cfgrandom[element[1]], "n" ) ) // Option necessary for edge parts? 
         || ( GetConfigString( cfgrandom[element[1]], "s" ) ) || ( GetConfigString( 
         cfgrandom[element[1]], "e" ) ) || ( GetConfigString( cfgrandom[element[1]], 
         "w" ) ) ) 
      layout.append( "htmlgump 360 60 50 40 " + data.size() + " 0 0" ); 
      data.append( "<basefont color=" + HTML_DARKBLUE + ">Produce Random Tiles" ); 
      layout.append( "checkbox 420 65 9720 9723 0 " + ITEMRAND ); 
    endif 
    layout.append( "htmlgump 260 70 50 30 " + data.size() + " 0 0" ); 
    data.append( "<basefont color=" + HTML_DARKBLUE + ">z-Coord" ); 
    layout.append( "resizepic 310 65 2620 38 30" ); 
    layout.append( "textentry 316 70 20 20 1000 " + ITEMPOS + " " + data.size() ); 
    data.append( "0" ); 
    layout.append( "checkbox 420 110 9720 9723 1 " + ITEMMODIFY ); 
    layout.append( "htmlgump 360 105 50 40 " + data.size() + " 0 0" ); 
    data.append( "<basefont color=" + HTML_DARKBLUE + ">Modify Position" ); 
    layout.append( "button 103 116 9721 9724 1 0 " + ITEMCREATE ); 
    layout.append( "htmlgump 140 121 50 30 " + data.size() + " 0 0" ); 
    data.append( "<basefont color=" + HTML_DARKBLUE + ">Create" ); 

    "Einzel": itemdesc := ReadConfigFile( ":*:itemdesc" ); // Reading of all Itemdesc's for name determination 
    layout := layoutraw; 
    data := dataraw; 
    data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + name + "</center>"; 
    layout := layout + { "page 0", "resizepic 70 0 3600 425 400", "resizepic 85 15 5054 395 30", 
                         "htmlgump 85 22 395 30 " + data.size() + " 0 0", "resizepic 85 47 83 395 343" }; 
    data.append( "<basefont size=5><center>" + cfgeinzel[element[1]].name + "</center>" ); 
    layout.append( "htmlgump 530 70 50 30 " + data.size() + " 0 0" ); 
    data.append( "<basefont color=" + HTML_DARKBLUE + ">Color" ); 
    layout.append( "resizepic 570 65 2620 48 30" ); 
    layout.append( "textentry 576 70 30 20 1000 " + ITEMCOLOR + " " + data.size() 
                   ); 
    data.append( "0" ); 
    layout.append( "htmlgump 530 110 50 30 " + data.size() + " 0 0" ); 
    data.append( "<basefont color=" + HTML_DARKBLUE + ">z-Coord" ); 
    layout.append( "resizepic 580 105 2620 38 30" ); 
    layout.append( "textentry 586 110 20 20 1000 " + ITEMPOS + " " + data.size() 
                   ); 
    data.append( "0" ); 
    layout.append( "checkbox 530 150 9720 9723 1 " + ITEMMODIFY ); 
    layout.append( "htmlgump 572 155 100 30 " + data.size() + " 0 0" ); 
    data.append( "<basefont color=" + HTML_DARKBLUE + ">Modify Position" ); 
    layout.append( "checkbox 530 185 9720 9723 0 " + ITEMMMULTICREATE ); 
    layout.append( "htmlgump 572 190 100 30 " + data.size() + " 0 0" ); 
    data.append( "<basefont color=" + HTML_DARKBLUE + ">Mark All" ); 
    layout.append( "button 570 225 9721 9724 1 0 " + ITEMCREATE ); 
    layout.append( "htmlgump 612 230 50 30 " + data.size() + " 0 0" ); 
    data.append( "<basefont color=" + HTML_DARKBLUE + ">Create" ); 

    tile := {}; 
    // Build an array of items
    foreach tiles in ( GetConfigStringArray( cfgeinzel[element[1]], "tile" ) ) 
      if ( !tile ) 
        tile := { tiles }; 
      else 
        tile.append( tiles ); 
      endif 
      SleepMS( 2 ); 
    endforeach 
    // Generate pages of the items
    nextpagebreak := MAXLINEITEM * 2 + 1; 
    nextlinebreak := MAXLINEITEM + 1; 
    x := 100; 
    y := 60; 
    page := 1; 
    layout.append( "page 1" ); 
    for ( m := 1; m <= tile.size(); m += 1 ) 
      if ( m == nextpagebreak ) 
        nextpagebreak += MAXLINEITEM * 2; 
        nextlinebreak += MAXLINEITEM; 
        x := 100; 
        y := 60; 
        if ( page > 1 ) 
          layout.append( "button 250 360 5603 5607 0 " + ( page - 1 ) + " 0" ); 
        endif 
        page += 1; 
        layout.append( "button 280 360 5601 5605 0 " + page + " 0" ); 
        layout.append( "page " + page ); 
      endif 
      if ( m == nextlinebreak ) 
        y := 210; 
        x := 100; 
        nextlinebreak += MAXLINEITEM; 
      endif 

      layout.append( "radio " + ( x ) + " " + ( y + 35 ) + " 9720 9723 0 " + m ); 
      layout.append( "tilepic " + ( x + 35 ) + " " + ( y + 35 ) + " " + CInt( SplitWords( 
                     tile[m], "," )[1] ) ); 
      if ( itemdesc[Hex( tile[m] )].desc ) // Insert name .desc or CliLoc entry 
        layout.append( "htmlgump " + ( x + 5 ) + " " + ( y ) + " 90 40 " + data.size() 
                       + " 0 0" ); 
        data.append( "<basefont color=" + HTML_GRAY + ">" + itemdesc[Hex( tile[m] )].desc ); 
      else 
        layout.append( "xmfhtmlgumpcolor " + ( x + 5 ) + " " + ( y ) + " 90 40 " + ( 1020000 + CInt( 
                       tile[m] ) ) + " 0 0 " + XMFCOLOR_GRAY2 ); 
      endif 
      x += 90; 
      SleepMS( 2 ); 
    endfor 

    if ( page > 1 ) 
      layout.append( "button 250 360 5603 5607 0 " + ( page - 1 ) + " 0" ); 
    endif 

    "Set": layout := layoutraw; 
    data := dataraw; 
    data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + name + "</center>"; 
    layout.append( "htmlgump 515 60 185 30 " + data.size() + " 0 0" ); 
    data.append( "<basefont size=5 color=" + HTML_DARKGRAY + "><center>" + cfgset[element[1]].name + "</center>" ); 
    layout.append( "htmlgump 530 100 50 30 " + data.size() + " 0 0" ); 
    data.append( "<basefont color=" + HTML_DARKBLUE + ">Color" ); 
    layout.append( "resizepic 570 95 2620 48 30" ); 
    layout.append( "textentry 576 100 30 20 1000 " + ITEMCOLOR + " " + data.size() 
                   ); 
    data.append( "0" ); 
    layout.append( "htmlgump 530 140 50 30 " + data.size() + " 0 0" ); 
    data.append( "<basefont color=" + HTML_DARKBLUE + ">z-Coord" ); 
    layout.append( "resizepic 580 135 2620 38 30" ); 
    layout.append( "textentry 586 140 20 20 1000 " + ITEMPOS + " " + data.size() 
                   ); 
    data.append( "0" ); 
    layout.append( "checkbox 530 180 9720 9723 1 " + ITEMMODIFY ); 
    layout.append( "htmlgump 572 185 100 30 " + data.size() + " 0 0" ); 
    data.append( "<basefont color=" + HTML_DARKBLUE + ">Modify Position" ); 
    layout.append( "checkbox 530 215 9720 9723 0 " + ITEMMMULTICREATE ); 
    layout.append( "htmlgump 572 220 100 30 " + data.size() + " 0 0" ); 
    data.append( "<basefont color=" + HTML_DARKBLUE + ">Mark All" ); 

    layout.append( "button 570 255 9721 9724 1 0 " + ITEMCREATE ); 
    layout.append( "htmlgump 612 260 50 30 " + data.size() + " 0 0" ); 
    data.append( "<basefont color=" + HTML_DARKBLUE + ">Create" ); 
  endcase 
endfunction // }}} 

// /////////////////////////////////
// RecoverInitItem - in the event of a non-existent init item attempt to restore
// /////////////////////////////////

function RecoverInitItem( newinit ) // {{{ 
  // Serial of the old, removed init item
  var oldinit := newinit.getprop( CPROP_INIT ); 

  // List of items found that also include the
  // have entered old serial as init item
  var found := array{ newinit }; 
  // List of the serials of these items (for a new initiative)
  var serials := array{ newinit.serial }; 

  // Search region for items ...
  foreach item in ( ListItemsNearLocation( newinit.x, newinit.y, LIST_IGNORE_Z, MAXAREASIZE, 
                                           newinit.realm ) ) 

    SleepMs( 2 ); 
    if ( item.serial == newinit.serial ) 
      // do not enter twice
      continue; 
    endif 
    // ... who also entered the old serial
    if ( item.getprop( CPROP_INIT ) == oldinit ) 
      // pack in lists and ...
      found.append( item ); 
      serials.append( item.serial ); 
      // ... Enter new init item
      item.setprop( CPROP_INIT, newinit.serial ); 
    endif 
  endforeach 

  // complete new initiative
  newinit.setprop( CPROP_INIT, newinit.serial ); 
  newinit.setprop( CPROP_ITEMS, serials ); 

  // return list last
  return found; 
endfunction // }}} 
// vim: sw=2 sts=2
