EScript Compiler v1.17
Copyright (C) 1993-2024 Eric N. Swanson

Formatting: bautool.src
BREAK 
"use cfgfile; " 0
BREAK 
"use os; " 0
BREAK 
"use uo; " 0
BREAK 
"use util; " 0
BREAK 
"include "client"; " 0
BREAK 
"include ":datafile:datafile"; " 0
BREAK 
"include ":gumps:textConsts"; " 0
BREAK 
"include "string"; " 0
BREAK 
"const VERSION := "<basefont color=" + HTML_DARKBLUE + ">V4.2a"; " 0
BREAK 
"enum TextEntry_Checkboxes " 0
BREAK 
"ITEMCOLOR := 1000, " 0
BREAK 
"ITEMRAND, " 0
BREAK 
"ITEMCREATE, " 0
BREAK 
"ITEMPOS, " 0
BREAK 
"ITEMMODIFY, " 0
BREAK 
"ITEMMMULTICREATE, " 0
BREAK 
"ITEMMODIFYMANUAL, // Modify menu for later modification " 0
BREAK 
"MODIFY_Z_START, " 0
BREAK 
"MODIFY_Z_END, " 0
BREAK 
"MODIFY_CUSTOM, " 0
BREAK 
"MODIFY_MARK, " 0
BREAK 
"MODIFY_X_ENTRY, " 0
BREAK 
"MODIFY_Y_ENTRY, " 0
BREAK 
"MODIFY_Z_ENTRY " 0
BREAK 
"endenum " 0
BREAK 
"enum Buttons " 0
BREAK 
"BACKBUTTON := 2000, // Back-Button " 0
BREAK 
"MODIFY_MARKEDIT, " 0
BREAK 
"MODIFY_START := 3000, " 0
BREAK 
"MODIFY_Y_UP := 3005, // ModifyItem-Buttons " 0
BREAK 
"MODIFY_Y_DOWN, " 0
BREAK 
"MODIFY_X_UP, " 0
BREAK 
"MODIFY_X_DOWN, " 0
BREAK 
"MODIFY_XY_MM, " 0
BREAK 
"MODIFY_XY_MP, " 0
BREAK 
"MODIFY_XY_PM, " 0
BREAK 
"MODIFY_XY_PP, " 0
BREAK 
"MODIFY_Z_UP, " 0
BREAK 
"MODIFY_Z_DOWN, " 0
BREAK 
"MODIFY_DESTROY, " 0
BREAK 
"MODIFY_COLOR, " 0
BREAK 
"MODIFY_DUPE, " 0
BREAK 
"MODIFY_X, " 0
BREAK 
"MODIFY_Y, " 0
BREAK 
"MODIFY_Z, " 0
BREAK 
"MARK_SHOW, " 0
BREAK 
"MARK_HIDE, " 0
BREAK 
"MARK_EDIT " 0
BREAK 
"endenum " 0
BREAK 
"enum dataPositionsAngaben " 0
BREAK 
"COLORDATAPOS := 7, " 0
BREAK 
"ZSTARTPOS := 15, " 0
BREAK 
"ZENDPOS := 16, " 0
BREAK 
"XKOORDSPOS := 8, " 0
BREAK 
"YKOORDSPOS := 9, " 0
BREAK 
"ZKOORDSPOS := 10, " 0
BREAK 
"XENTRY := 12, " 0
BREAK 
"YENTRY, " 0
BREAK 
"ZENTRY " 0
BREAK 
"endenum " 0
BREAK 
"enum Ebenen " 0
BREAK 
"ROOTLIST := 0, // plane definition " 0
BREAK 
"FIRSTLIST, " 0
BREAK 
"SECONDLIST, " 0
BREAK 
"THIRDLIST, " 0
BREAK 
"FOURTHLIST, " 0
BREAK 
"FIFTHLIST, " 0
BREAK 
"ITEMLIST, " 0
BREAK 
"ITEMLISTDUMMY " 0
BREAK 
"endenum " 0
BREAK 
"enum Cprops " 0
BREAK 
"CPROP_INIT := "bautoolinit", // CProps to find the items " 0
BREAK 
"CPROP_ITEMS := "bautoolitems", " 0
BREAK 
"CPROP_COLOR := "bautoolorigcol" // Original color for markedit " 0
BREAK 
"endenum " 0
BREAK 
"const MENUSTART := 4000; // Start value of the lists / item buttons " 0
BREAK 
"const MAXBUTTON := 7; // Max Buttons in the NavBar " 0
BREAK 
"const MAXLINEITEM := 4; // How many items side by side in single create " 0
BREAK 
"const MAXAREASIZE := 50; " 0
BREAK 
"const ITEMMOVEFLAGS := MOVEOBJECT_FORCELOCATION + MOVEITEM_IGNOREMOVABLE; " 0
BREAK 
"var cfgrandom := ReadConfigFile( "bautoolrandom" ); " 0
BREAK 
"var cfgeinzel := ReadConfigFile( "bautooleinzel" ); " 0
BREAK 
"var cfgset := ReadConfigFile( "bautoolset" ); " 0
BREAK 
"var datafile := DFOpenDataFile( "bautoolcmd", DF_CREATE, DF_KEYTYPE_STRING ); " 0
BREAK 
"var dataelementMenu := datafile.FindElement( "menu" ); " 0
BREAK 
"var dataelementModify := datafile.FindElement( "modify" ); " 0
BREAK 
"var dataelementElement := datafile.FindElement( "elemente" ); " 0
BREAK 
"var dataelementMark := datafile.FindElement( "modifymark" ); " 0
BREAK 
"var layoutmodify := dataelementModify.getprop( "LayoutMenu" ); " 0
BREAK 
"var datamodify := dataelementModify.getprop( "DataMenu" ); " 0
BREAK 
"var layoutmodify_M := dataelementModify.getprop( "LayoutMenuManual" ); " 0
BREAK 
"var datamodify_M := dataelementModify.getprop( "DataMenuManual" ); " 0
BREAK 
"var layoutmark := dataelementMark.getprop( "LayoutMenuMark" ); " 0
BREAK 
"var datamark := dataelementMark.getprop( "DataMenuMark" ); " 0
BREAK 
"var datafileelement := dataelementElement.getprop( "dictionary" ); " 0
BREAK 
"program bautool( who, param ) " 0
BREAK 
"if ( who[1] == "Init" ) // Generate datafile via script " 0
BREAK 
"Init(); " 0
BREAK 
"return; " 0
BREAK 
"endif " 0
BREAK 
"if ( !GetGlobalProperty( "BauServer" ) ) " 0
BREAK 
"if ( who.cmdlevel < 3 ) " 0
BREAK 
"SendSysMessage( who, "You are not authorized to use this command!" ); " 0
BREAK 
"return; " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"if ( Lower( param ) == "init" ) // Developer can start Init () manually " 0
BREAK 
"if ( who.cmdlevel == 5 ) " 0
BREAK 
"cfgrandom := 0; // First remove Ref's so that Unload works properly " 0
BREAK 
"cfgeinzel := 0; " 0
BREAK 
"cfgset := 0; " 0
BREAK 
"UnloadConfigFile( "bautoolmenues" ); " 0
BREAK 
"UnloadConfigFile( "bautooleinzel" ); " 0
BREAK 
"UnloadConfigFile( "bautoolrandom" ); " 0
BREAK 
"UnloadConfigFile( "bautoolset" ); " 0
BREAK 
"cfgrandom := ReadConfigFile( ":bautool:bautoolrandom" ); " 0
BREAK 
"cfgeinzel := ReadConfigFile( ":bautool:bautooleinzel" ); " 0
BREAK 
"cfgset := ReadConfigFile( ":bautool:bautoolset" ); " 0
BREAK 
"SendSysMessage( who, "Datafile building..." ); " 0
BREAK 
"Init(); " 0
BREAK 
"SendSysMessage( who, "Datafile completed" ); " 0
BREAK 
"return; " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"if ( GetGlobalProperty( "bautoolinit" ) ) " 0
BREAK 
"SendSysMessage( who, "Datafile is still being generated, try again later." ); " 0
BREAK 
"return; " 0
BREAK 
"endif " 0
BREAK 
"ShowMenu( who ); " 0
BREAK 
"endprogram " 0
BREAK 
"function ShowMenu( who ) // {{{ " 0
BREAK 
"var data := {}, layout := {}, nr, ebene; " 0
BREAK 
"var ret, tile := {}; " 0
BREAK 
"var element := dictionary, back := 0; " 0
BREAK 
"var firstebene, secondebene, thirdebene, fourthebene, fifthebene, itemebene; " 0
BREAK 
"var color; " 0
BREAK 
"element := datafileelement; " 0
BREAK 
"ebene := FIRSTLIST; " 0
BREAK 
"layout := dataelementMenu.getprop( "LayoutMenuBar" ); " 0
BREAK 
"data := dataelementMenu.getprop( "DataMenuBar" ); " 0
BREAK 
"ret := SendDialogGump( who, layout, data, 10, 50 ); " 0
BREAK 
"while ( who.connected ) " 0
BREAK 
"if ( ( ret.keys[ret.keys.size()] > MENUSTART ) || ( back ) ) " 0
BREAK 
"if ( back ) // Simulated buttone printing " 0
BREAK 
"nr := back; " 0
BREAK 
"back := 0; " 0
BREAK 
"else " 0
BREAK 
"nr := ret.keys[ret.keys.size()] - MENUSTART; " 0
BREAK 
"endif " 0
BREAK 
"case ( ebene ) // In which display level I am, create a suitable data list " 0
BREAK 
"ROOTLIST: " 0
BREAK 
"ebene := FIRSTLIST; " 0
BREAK 
"layout := dataelementMenu.getprop( "LayoutMenuBar" ); " 0
BREAK 
"data := dataelementMenu.getprop( "DataMenuBar" ); " 0
BREAK 
"FIRSTLIST: " 0
BREAK 
"ebene := SECONDLIST; " 0
BREAK 
"if ( TypeOfInt( nr ) == OT_STRING ) " 0
BREAK 
"firstebene := nr; " 0
BREAK 
"else " 0
BREAK 
"firstebene := element.keys()[nr]; " 0
BREAK 
"endif " 0
BREAK 
"layout := dataelementMenu.getprop( "LayoutMain_" + firstebene ); " 0
BREAK 
"data := dataelementMenu.getprop( "DataMain_" + firstebene ); " 0
BREAK 
"SECONDLIST: " 0
BREAK 
"ebene := THIRDLIST; " 0
BREAK 
"if ( TypeOfInt( element[firstebene] ) <> OT_DICTIONARY ) " 0
BREAK 
"secondebene := nr; " 0
BREAK 
"tile := BuildItems( layout, data, element[firstebene][nr], firstebene ); " 0
BREAK 
"else " 0
BREAK 
"if ( TypeOfInt( nr ) == OT_STRING ) " 0
BREAK 
"secondebene := nr; " 0
BREAK 
"else " 0
BREAK 
"secondebene := element[firstebene].keys()[nr]; " 0
BREAK 
"endif " 0
BREAK 
"layout := dataelementMenu.getprop( "LayoutSub_" + firstebene + "_" + secondebene ); " 0
BREAK 
"data := dataelementMenu.getprop( "DataSub_" + firstebene + "_" + secondebene ); " 0
BREAK 
"endif " 0
BREAK 
"THIRDLIST: " 0
BREAK 
"ebene := FOURTHLIST; " 0
BREAK 
"if ( TypeOfInt( element[firstebene][secondebene] ) <> OT_DICTIONARY ) " 0
BREAK 
"thirdebene := nr; " 0
BREAK 
"tile := BuildItems( layout, data, element[firstebene][secondebene][nr], firstebene, secondebene ); " 0
BREAK 
"else " 0
BREAK 
"if ( TypeOfInt( nr ) == OT_STRING ) " 0
BREAK 
"thirdebene := nr; " 0
BREAK 
"else " 0
BREAK 
"thirdebene := element[firstebene][secondebene].keys()[nr]; " 0
BREAK 
"endif " 0
BREAK 
"layout := dataelementMenu.getprop( "LayoutSub_" + firstebene + "_" + secondebene + "_" + thirdebene ); " 0
BREAK 
"data := dataelementMenu.getprop( "DataSub_" + firstebene + "_" + secondebene + "_" + thirdebene ); " 0
BREAK 
"endif " 0
BREAK 
"FOURTHLIST: " 0
BREAK 
"ebene := FIFTHLIST; " 0
BREAK 
"if ( TypeOfInt( element[firstebene][secondebene][thirdebene] ) <> OT_DICTIONARY ) " 0
BREAK 
"fourthebene := nr; " 0
BREAK 
"tile := BuildItems( layout, data, element[firstebene][secondebene][thirdebene][nr], firstebene, secondebene, thirdebene ); " 0
BREAK 
"else " 0
BREAK 
"ebene := FIFTHLIST; " 0
BREAK 
"if ( TypeOfInt( nr ) == OT_STRING ) " 0
BREAK 
"fourthebene := nr; " 0
BREAK 
"else " 0
BREAK 
"fourthebene := element[firstebene][secondebene][thirdebene].keys()[nr]; " 0
BREAK 
"endif " 0
BREAK 
"layout := dataelementMenu.getprop( "LayoutSub_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene ); " 0
BREAK 
"data := dataelementMenu.getprop( "DataSub_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene ); " 0
BREAK 
"endif " 0
BREAK 
"FIFTHLIST: " 0
BREAK 
"ebene := ITEMLIST; " 0
BREAK 
"if ( TypeOfInt( element[firstebene][secondebene][thirdebene][fourthebene] ) <> OT_DICTIONARY ) " 0
BREAK 
"fifthebene := nr; " 0
BREAK 
"tile := BuildItems( layout, data, element[firstebene][secondebene][thirdebene][fourthebene][nr], firstebene, secondebene, thirdebene, fourthebene ); " 0
BREAK 
"else " 0
BREAK 
"ebene := ITEMLIST; " 0
BREAK 
"if ( TypeOfInt( nr ) == OT_STRING ) " 0
BREAK 
"fifthebene := nr; " 0
BREAK 
"else " 0
BREAK 
"fifthebene := element[firstebene][secondebene][thirdebene][fourthebene].keys()[nr]; " 0
BREAK 
"endif " 0
BREAK 
"layout := dataelementMenu.getprop( "LayoutSub_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene ); " 0
BREAK 
"data := dataelementMenu.getprop( "DataSub_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene ); " 0
BREAK 
"endif " 0
BREAK 
"ITEMLIST: " 0
BREAK 
"ITEMLISTDUMMY: " 0
BREAK 
"ebene := ITEMLISTDUMMY; " 0
BREAK 
"if ( TypeOfInt( nr ) == OT_STRING ) " 0
BREAK 
"itemebene := nr; " 0
BREAK 
"else " 0
BREAK 
"itemebene := element[firstebene][secondebene][thirdebene][fourthebene][fifthebene][nr]; " 0
BREAK 
"endif " 0
BREAK 
"tile := BuildItems( layout, data, element[firstebene][secondebene][thirdebene][fourthebene][fifthebene][nr], firstebene, secondebene, thirdebene, fourthebene, fifthebene, itemebene[1] ); " 0
BREAK 
"endcase " 0
BREAK 
"ret := SendDialogGump( who, layout, data, 10, 50 ); " 0
BREAK 
"elseif ( ret[BACKBUTTON] ) // Back " 0
BREAK 
"ebene -= 2; // 2 because one was added beforehand " 0
BREAK 
"if ( ebene < 0 ) " 0
BREAK 
"ebene := ROOTLIST; " 0
BREAK 
"endif " 0
BREAK 
"case ( ebene ) " 0
BREAK 
"ROOTLIST: " 0
BREAK 
"back := 1; " 0
BREAK 
"FIRSTLIST: " 0
BREAK 
"back := firstebene; " 0
BREAK 
"SECONDLIST: " 0
BREAK 
"back := secondebene; " 0
BREAK 
"THIRDLIST: " 0
BREAK 
"back := thirdebene; " 0
BREAK 
"FOURTHLIST: " 0
BREAK 
"back := fourthebene; " 0
BREAK 
"FIFTHLIST: " 0
BREAK 
"back := fifthebene; " 0
BREAK 
"ITEMLIST: " 0
BREAK 
"back := itemebene; " 0
BREAK 
"ITEMLISTDUMMY: " 0
BREAK 
"back := itemebene; " 0
BREAK 
"endcase " 0
BREAK 
"elseif ( ret[ITEMCREATE] ) " 0
BREAK 
"ebene -= 1; " 0
BREAK 
"back := nr; // So that there is no final lock loop with Create " 0
BREAK 
"color := ret[ITEMCOLOR]; " 0
BREAK 
"color[1, 6] := ""; " 0
BREAK 
"color := CInt( color ); " 0
BREAK 
"case ( tile[1][2] ) " 0
BREAK 
""Random": " 0
BREAK 
"CreateRandom( who, ret, tile[2], tile[3], color, tile[1][1] ); " 0
BREAK 
""Einzel": " 0
BREAK 
"CreateEinzel( who, ret, tile[2], color ); " 0
BREAK 
""Set": " 0
BREAK 
"CreateSet( who, ret, tile[2], color ); " 0
BREAK 
"default: " 0
BREAK 
"SendSysMessage( who, "error..." ); " 0
BREAK 
"return; " 0
BREAK 
"endcase " 0
BREAK 
"elseif ( ret[ITEMMODIFYMANUAL] ) " 0
BREAK 
"ModifyItemsManual( who ); " 0
BREAK 
"back := 1; " 0
BREAK 
"ebene := ROOTLIST; " 0
BREAK 
"else " 0
BREAK 
"return; // Winke " 0
BREAK 
"endif " 0
BREAK 
"endwhile " 0
BREAK 
"endfunction // }}} " 0
BREAK 
"function BuildItems( byref layout, byref data, byref element, firstebene, secondebene := 0, thirdebene := 0, fourthebene := 0, fifthebene := 0, itemebene := 0 ) " 0
BREAK 
"var tiles := {}; " 0
BREAK 
"var tiles1 := {}; " 0
BREAK 
"var splittiles := {}; " 0
BREAK 
"if ( itemebene ) " 0
BREAK 
"layout := dataelementMenu.getprop( "LayoutItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene + "_" + itemebene ); " 0
BREAK 
"data := dataelementMenu.getprop( "DataItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene + "_" + itemebene ); " 0
BREAK 
"elseif ( fifthebene ) " 0
BREAK 
"layout := dataelementMenu.getprop( "LayoutItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene ); " 0
BREAK 
"data := dataelementMenu.getprop( "DataItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene ); " 0
BREAK 
"elseif ( fourthebene ) " 0
BREAK 
"layout := dataelementMenu.getprop( "LayoutItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + element[1] ); " 0
BREAK 
"data := dataelementMenu.getprop( "DataItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + element[1] ); " 0
BREAK 
"elseif ( thirdebene ) " 0
BREAK 
"layout := dataelementMenu.getprop( "LayoutItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + element[1] ); " 0
BREAK 
"data := dataelementMenu.getprop( "DataItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + element[1] ); " 0
BREAK 
"elseif ( secondebene ) " 0
BREAK 
"layout := dataelementMenu.getprop( "LayoutItem_" + firstebene + "_" + secondebene + "_" + element[1] ); " 0
BREAK 
"data := dataelementMenu.getprop( "DataItem_" + firstebene + "_" + secondebene + "_" + element[1] ); " 0
BREAK 
"elseif ( firstebene ) " 0
BREAK 
"layout := dataelementMenu.getprop( "LayoutItem_" + firstebene + "_" + element[1] ); " 0
BREAK 
"data := dataelementMenu.getprop( "DataItem_" + firstebene + "_" + element[1] ); " 0
BREAK 
"endif " 0
BREAK 
"case ( element[2] ) " 0
BREAK 
""Random": " 0
BREAK 
"foreach tile in ( GetConfigStringArray( cfgrandom[element[1]], "tile" ) ) " 0
BREAK 
"splittiles := SplitWords( tile ); " 0
BREAK 
"tiles.append( splittiles[1] ); " 0
BREAK 
"if ( splittiles[2] ) " 0
BREAK 
"tiles1.append( splittiles[2] ); " 0
BREAK 
"endif " 0
BREAK 
"endforeach " 0
BREAK 
""Einzel": " 0
BREAK 
"foreach tile in ( GetConfigStringArray( cfgeinzel[element[1]], "tile" ) ) " 0
BREAK 
"if ( !tiles ) " 0
BREAK 
"tiles := { tile }; " 0
BREAK 
"else " 0
BREAK 
"tiles.append( tile ); " 0
BREAK 
"endif " 0
BREAK 
"endforeach " 0
BREAK 
""Set": " 0
BREAK 
"tiles := element[1]; " 0
BREAK 
"endcase " 0
BREAK 
"return ( { element, tiles, tiles1 } ); " 0
BREAK 
"endfunction // }}} " 0
BREAK 
"function CreateRandom( who, byref ret, byref tiles, byref tiles1, byref color, byref element ) " 0
BREAK 
"var tar1, tar2, item, x, y, z, Tarx, Tary, Tarx2, Tary2, itemdef, items := {}, itemserials := {}; " 0
BREAK 
"SendSysMessage( who, "Target first corner" ); " 0
BREAK 
"tar1 := TargetCoordinates( who ); " 0
BREAK 
"if ( tar1 ) " 0
BREAK 
"SendSysMessage( who, "Target the second corner" ); " 0
BREAK 
"tar2 := TargetCoordinates( who ); " 0
BREAK 
"if ( tar2 ) " 0
BREAK 
"if ( ( tar1.item ) || ( tar2.item ) ) " 0
BREAK 
"if ( ( tar1.item.container ) || ( tar2.item.container ) ) " 0
BREAK 
"SendSysMessage( who, "cancellation. Item in Container targeted!" ); " 0
BREAK 
"return; " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"if ( tar1.x >= tar2.x ) // Sorting the area " 0
BREAK 
"Tarx := tar2.x; " 0
BREAK 
"Tarx2 := tar1.x; " 0
BREAK 
"else " 0
BREAK 
"Tarx := tar1.x; " 0
BREAK 
"Tarx2 := tar2.x; " 0
BREAK 
"endif " 0
BREAK 
"if ( tar1.y >= tar2.y ) " 0
BREAK 
"Tary := tar2.y; " 0
BREAK 
"Tary2 := tar1.y; " 0
BREAK 
"else " 0
BREAK 
"Tary := tar1.y; " 0
BREAK 
"Tary2 := tar2.y; " 0
BREAK 
"endif " 0
BREAK 
"if ( ( ( Tarx2 - Tarx ) > MAXAREASIZE ) || ( ( Tary2 - Tary ) > MAXAREASIZE ) ) " 0
BREAK 
"SendSysMessage( who, "Cancellation.  " + MAXAREASIZE + "x" + MAXAREASIZE + " Generate items!" ); " 0
BREAK 
"return; " 0
BREAK 
"endif " 0
BREAK 
"z := ret[ITEMPOS]; " 0
BREAK 
"z[1, 6] := ""; " 0
BREAK 
"z := CInt( z ); " 0
BREAK 
"if ( GetConfigString( cfgrandom[element], "x" ) ) " 0
BREAK 
"Tarx2 := Tarx + CInt( GetConfigString( cfgrandom[element], "x" ) ) - 1; " 0
BREAK 
"endif " 0
BREAK 
"if ( GetConfigString( cfgrandom[element], "y" ) ) " 0
BREAK 
"Tary2 := Tary + CInt( GetConfigString( cfgrandom[element], "y" ) ) - 1; " 0
BREAK 
"endif " 0
BREAK 
"if ( ret[ITEMRAND] ) // Random items are to be generated " 0
BREAK 
"for ( x := Tarx; x <= Tarx2; x += 1 ) " 0
BREAK 
"for ( y := Tary; y <= Tary2; y += 1 ) " 0
BREAK 
"if ( ( x == Tarx ) && ( y == Tary ) ) // NW corner " 0
BREAK 
"itemdef := GetConfigString( cfgrandom[element], "nw" ); " 0
BREAK 
"if ( !itemdef ) " 0
BREAK 
"SendSysMessage( who, "NW corner is missing." ); " 0
BREAK 
"else " 0
BREAK 
"itemdef := SplitWords( itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( itemdef ); " 0
BREAK 
"itemdef := SplitWords( itemdef, "," ); " 0
BREAK 
"item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm ); " 0
BREAK 
"if ( item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Create Error!  " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"itemdef := GetConfigString( cfgrandom[element], "nw1" ); " 0
BREAK 
"if ( ( itemdef ) && ( itemdef <> {} ) ) " 0
BREAK 
"itemdef := SplitWords( itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( itemdef ); " 0
BREAK 
"itemdef := SplitWords( itemdef, "," ); " 0
BREAK 
"item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm ); " 0
BREAK 
"if ( item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Create error! NW-Corner 2nd item" + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"elseif ( ( x == Tarx2 ) && ( y == Tary ) ) // NE corner " 0
BREAK 
"itemdef := GetConfigString( cfgrandom[element], "no" ); " 0
BREAK 
"if ( !itemdef ) " 0
BREAK 
"SendSysMessage( who, "NE corner missing." ); " 0
BREAK 
"else " 0
BREAK 
"itemdef := SplitWords( itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( itemdef ); " 0
BREAK 
"itemdef := SplitWords( itemdef, "," ); " 0
BREAK 
"item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm ); " 0
BREAK 
"if ( item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Create error! NE-corner Item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"itemdef := GetConfigString( cfgrandom[element], "no1" ); " 0
BREAK 
"if ( ( itemdef ) && ( itemdef <> {} ) ) " 0
BREAK 
"itemdef := SplitWords( itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( itemdef ); " 0
BREAK 
"itemdef := SplitWords( itemdef, "," ); " 0
BREAK 
"item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm ); " 0
BREAK 
"if ( item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Create error! NE-Corner 2nd item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"elseif ( ( x == Tarx2 ) && ( y == Tary2 ) ) // SE corner " 0
BREAK 
"itemdef := GetConfigString( cfgrandom[element], "so" ); " 0
BREAK 
"if ( !itemdef ) " 0
BREAK 
"SendSysMessage( who, "SE-Corner is missing." ); " 0
BREAK 
"else " 0
BREAK 
"itemdef := SplitWords( itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( itemdef ); " 0
BREAK 
"itemdef := SplitWords( itemdef, "," ); " 0
BREAK 
"item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm ); " 0
BREAK 
"if ( item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Create error! SO-Ecke Item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"itemdef := GetConfigString( cfgrandom[element], "so1" ); " 0
BREAK 
"if ( ( itemdef ) && ( itemdef <> {} ) ) " 0
BREAK 
"itemdef := SplitWords( itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( itemdef ); " 0
BREAK 
"itemdef := SplitWords( itemdef, "," ); " 0
BREAK 
"item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm ); " 0
BREAK 
"if ( item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Create error! SE-Corner 2nd item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"elseif ( ( x == Tarx ) && ( y == Tary2 ) ) // SW corner " 0
BREAK 
"itemdef := GetConfigString( cfgrandom[element], "sw" ); " 0
BREAK 
"if ( !itemdef ) " 0
BREAK 
"SendSysMessage( who, "SW-Corner is missing." ); " 0
BREAK 
"else " 0
BREAK 
"itemdef := SplitWords( itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( itemdef ); " 0
BREAK 
"itemdef := SplitWords( itemdef, "," ); " 0
BREAK 
"item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm ); " 0
BREAK 
"if ( item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Create error! SW-corner Item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"itemdef := GetConfigString( cfgrandom[element], "sw1" ); " 0
BREAK 
"if ( ( itemdef ) && ( itemdef <> {} ) ) " 0
BREAK 
"itemdef := SplitWords( itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( itemdef ); " 0
BREAK 
"itemdef := SplitWords( itemdef, "," ); " 0
BREAK 
"item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm ); " 0
BREAK 
"if ( item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Create error! SW-Corner 2nd item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"elseif ( y == Tary ) // N page " 0
BREAK 
"itemdef := GetConfigString( cfgrandom[element], "n" ); " 0
BREAK 
"if ( !itemdef ) " 0
BREAK 
"SendSysMessage( who, "N-Page is missing." ); " 0
BREAK 
"else " 0
BREAK 
"itemdef := SplitWords( itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( itemdef ); " 0
BREAK 
"itemdef := SplitWords( itemdef, "," ); " 0
BREAK 
"item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm ); " 0
BREAK 
"if ( item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Create error! N-Item page " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"itemdef := GetConfigString( cfgrandom[element], "n1" ); " 0
BREAK 
"if ( ( itemdef ) && ( itemdef <> {} ) ) " 0
BREAK 
"itemdef := SplitWords( itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( itemdef ); " 0
BREAK 
"itemdef := SplitWords( itemdef, "," ); " 0
BREAK 
"item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm ); " 0
BREAK 
"if ( item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Create error! N-Page 2nd item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"elseif ( x == Tarx2 ) // E side " 0
BREAK 
"itemdef := GetConfigString( cfgrandom[element], "o" ); " 0
BREAK 
"if ( !itemdef ) " 0
BREAK 
"SendSysMessage( who, "E-side is missing." ); " 0
BREAK 
"else " 0
BREAK 
"itemdef := SplitWords( itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( itemdef ); " 0
BREAK 
"itemdef := SplitWords( itemdef, "," ); " 0
BREAK 
"item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm ); " 0
BREAK 
"if ( item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Create error! E-side item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"itemdef := GetConfigString( cfgrandom[element], "o1" ); " 0
BREAK 
"if ( ( itemdef ) && ( itemdef <> {} ) ) " 0
BREAK 
"itemdef := SplitWords( itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( itemdef ); " 0
BREAK 
"itemdef := SplitWords( itemdef, "," ); " 0
BREAK 
"item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm ); " 0
BREAK 
"if ( item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Create error! E-side 2nd item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"elseif ( y == Tary2 ) // S side " 0
BREAK 
"itemdef := GetConfigString( cfgrandom[element], "s" ); " 0
BREAK 
"if ( !itemdef ) " 0
BREAK 
"SendSysMessage( who, "S side is missing." ); " 0
BREAK 
"else " 0
BREAK 
"itemdef := SplitWords( itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( itemdef ); " 0
BREAK 
"itemdef := SplitWords( itemdef, "," ); " 0
BREAK 
"item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm ); " 0
BREAK 
"if ( item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Create error! S-Item page " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"itemdef := GetConfigString( cfgrandom[element], "s1" ); " 0
BREAK 
"if ( ( itemdef ) && ( itemdef <> {} ) ) " 0
BREAK 
"itemdef := SplitWords( itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( itemdef ); " 0
BREAK 
"itemdef := SplitWords( itemdef, "," ); " 0
BREAK 
"item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm ); " 0
BREAK 
"if ( item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Create error! S-side 2nd item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"elseif ( x == Tarx ) // W page " 0
BREAK 
"itemdef := GetConfigString( cfgrandom[element], "w" ); " 0
BREAK 
"if ( !itemdef ) " 0
BREAK 
"SendSysMessage( who, "W-Page is missing." ); " 0
BREAK 
"else " 0
BREAK 
"itemdef := SplitWords( itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( itemdef ); " 0
BREAK 
"itemdef := SplitWords( itemdef, "," ); " 0
BREAK 
"item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm ); " 0
BREAK 
"if ( item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Create error! W side item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"itemdef := GetConfigString( cfgrandom[element], "w1" ); " 0
BREAK 
"if ( ( itemdef ) && ( itemdef <> {} ) ) " 0
BREAK 
"itemdef := SplitWords( itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( itemdef ); " 0
BREAK 
"itemdef := SplitWords( itemdef, "," ); " 0
BREAK 
"item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm ); " 0
BREAK 
"if ( item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Create error! W-Page 2nd item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"else // centerpiece " 0
BREAK 
"itemdef := ChooseRandom( tiles ); " 0
BREAK 
"if ( !itemdef ) " 0
BREAK 
"SendSysMessage( who, "Middle piece is missing." ); " 0
BREAK 
"else " 0
BREAK 
"itemdef := SplitWords( itemdef, "," ); " 0
BREAK 
"item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm ); " 0
BREAK 
"if ( item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Create error! Midsection item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"itemdef := tiles1.randomentry(); " 0
BREAK 
"if ( ( itemdef ) && ( itemdef <> {} ) ) " 0
BREAK 
"itemdef := SplitWords( itemdef, "," ); " 0
BREAK 
"item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm ); " 0
BREAK 
"if ( item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Create error! Middle part 2nd item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 5 ); " 0
BREAK 
"endfor " 0
BREAK 
"endfor " 0
BREAK 
"else // Boring version without a border " 0
BREAK 
"for ( x := Tarx; x <= Tarx2; x += 1 ) " 0
BREAK 
"for ( y := Tary; y <= Tary2; y += 1 ) " 0
BREAK 
"itemdef := ChooseRandom( tiles ); " 0
BREAK 
"if ( !itemdef ) " 0
BREAK 
"SendSysMessage( who, "Middle piece is missing." ); " 0
BREAK 
"else " 0
BREAK 
"itemdef := SplitWords( itemdef, "," ); " 0
BREAK 
"item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm ); " 0
BREAK 
"if ( item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Create error! Item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"itemdef := tiles1.randomentry(); " 0
BREAK 
"if ( ( itemdef ) && ( itemdef <> {} ) ) " 0
BREAK 
"itemdef := SplitWords( itemdef, "," ); " 0
BREAK 
"item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm ); " 0
BREAK 
"if ( item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Create error! 2nd Item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 5 ); " 0
BREAK 
"endfor " 0
BREAK 
"endfor " 0
BREAK 
"endif " 0
BREAK 
"foreach item in items " 0
BREAK 
"item.setprop( CPROP_INIT, items[1].serial ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"foreach item in items " 0
BREAK 
"itemserials.append( item.serial ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"items[1].setprop( CPROP_ITEMS, itemserials ); " 0
BREAK 
"if ( ret[ITEMMODIFY] ) // Change position " 0
BREAK 
"if ( !ModifyItems( who, items ) ) " 0
BREAK 
"return; " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Abort" ); " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Abort" ); " 0
BREAK 
"endif " 0
BREAK 
"endfunction // }}} " 0
BREAK 
"function CreateEinzel( who, byref ret, byref tiles, byref color ) // {{{ " 0
BREAK 
"var z, itemdef := {}, iTarget, item, items := {}, itemserials := {}; " 0
BREAK 
"if ( !tiles[ret.keys[2]] ) " 0
BREAK 
"SendSysMessage( who, "No item selected" ); " 0
BREAK 
"return; " 0
BREAK 
"endif " 0
BREAK 
"SendSysMessage( who, "Target position" ); " 0
BREAK 
"z := ret[ITEMPOS]; " 0
BREAK 
"z[1, 6] := ""; " 0
BREAK 
"z := CInt( z ); " 0
BREAK 
"itemdef[1] := CInt( SplitWords( tiles[ret.keys[2]], "," )[1] ); // Objtype " 0
BREAK 
"itemdef[2] := CInt( SplitWords( tiles[ret.keys[2]], "," )[2] ); // Feste z-Koords " 0
BREAK 
"iTarget := TargetCoordinates( who ); " 0
BREAK 
"if ( iTarget.item ) " 0
BREAK 
"if ( iTarget.item.container ) " 0
BREAK 
"SendSysMessage( who, "cancellation. Item in Container targeted!" ); " 0
BREAK 
"return; " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"while ( iTarget ) // Endless to ESC " 0
BREAK 
"item := CreateItemAtLocation( iTarget.x, iTarget.y, iTarget.z + itemdef[2] + z, itemdef[1], 1, who.realm ); " 0
BREAK 
"if ( item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"if ( !ret[ITEMMMULTICREATE] ) " 0
BREAK 
"item.setprop( CPROP_INIT, item.serial ); " 0
BREAK 
"item.setprop( CPROP_ITEMS, { item.serial } ); " 0
BREAK 
"if ( ret[ITEMMODIFY] ) // Change position " 0
BREAK 
"if ( !ModifyItems( who, item ) ) " 0
BREAK 
"SendSysMessage( who, "Abort" ); " 0
BREAK 
"return; " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"items.append( item ); " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Create error! Item " + iTarget.x + " " + iTarget.y + " " + ( iTarget.z + itemdef[2] + z ) + " " + Hex( tiles[ret.keys[2]] ) + " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"iTarget := TargetCoordinates( who ); " 0
BREAK 
"endwhile " 0
BREAK 
"if ( ret[ITEMMMULTICREATE] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"item.setprop( CPROP_INIT, items[1].serial ); " 0
BREAK 
"endforeach " 0
BREAK 
"foreach item in items " 0
BREAK 
"itemserials.append( item.serial ); " 0
BREAK 
"endforeach " 0
BREAK 
"items[1].setprop( CPROP_ITEMS, itemserials ); " 0
BREAK 
"if ( ret[ITEMMODIFY] ) // Postion to change " 0
BREAK 
"ModifyItems( who, items ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SendSysMessage( who, "Abort" ); " 0
BREAK 
"endfunction // }}} " 0
BREAK 
"function CreateSet( unused who, byref unused ret, byref unused set, byref unused color ) " 0
BREAK 
"endfunction " 0
BREAK 
"function ModifyItemsManual( who ) // {{{ " 0
BREAK 
"var retmodify, tar, inititem, items := {}, itemserials := {}, color, zstart, zend, temp, i, obj, tempitems := {}; " 0
BREAK 
"var tar1, tar2, x1, x2, y1, y2, breakflag; " 0
BREAK 
"var dupe := {}, dupeitem, dupeserials := {}; " 0
BREAK 
"while ( who.connected ) " 0
BREAK 
"if ( items <> {} ) " 0
BREAK 
"datamodify_M[COLORDATAPOS] := items[1].color; " 0
BREAK 
"datamodify_M[XKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>" + items[1].x + "</p></basefont>"; " 0
BREAK 
"datamodify_M[YKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>" + items[1].y + "</p></basefont>"; " 0
BREAK 
"datamodify_M[ZKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>" + items[1].z + "</p></basefont>"; " 0
BREAK 
"datamodify_M[XENTRY] := items[1].x; " 0
BREAK 
"datamodify_M[YENTRY] := items[1].y; " 0
BREAK 
"datamodify_M[ZENTRY] := items[1].z; " 0
BREAK 
"else " 0
BREAK 
"datamodify_M[COLORDATAPOS] := "0"; " 0
BREAK 
"datamodify_M[XKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>x</p></basefont>"; " 0
BREAK 
"datamodify_M[YKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>y</p></basefont>"; " 0
BREAK 
"datamodify_M[ZKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>z</p></basefont>"; " 0
BREAK 
"datamodify_M[XENTRY] := 0; " 0
BREAK 
"datamodify_M[YENTRY] := 0; " 0
BREAK 
"datamodify_M[ZENTRY] := 0; " 0
BREAK 
"endif " 0
BREAK 
"retmodify := SendDialogGump( who, layoutmodify_M, datamodify_M, 10, 50 ); " 0
BREAK 
"if ( retmodify[MODIFY_START] ) " 0
BREAK 
"if ( !retmodify[MODIFY_CUSTOM] ) // Search for .bautool items " 0
BREAK 
"tar := Target( who, TGTOPT_NOCHECK_LOS ); " 0
BREAK 
"if ( tar ) " 0
BREAK 
"if ( ( !tar.getprop( CPROP_ITEMS ) ) && ( tar.getprop( CPROP_INIT ) ) ) " 0
BREAK 
"inititem := SystemFindObjectBySerial( tar.getprop( CPROP_INIT ) ); " 0
BREAK 
"if ( inititem ) " 0
BREAK 
"itemserials := inititem.getprop( CPROP_ITEMS ); " 0
BREAK 
"items := {}; " 0
BREAK 
"tempitems := {}; " 0
BREAK 
"foreach item in itemserials " 0
BREAK 
"obj := SystemFindObjectBySerial( item ); " 0
BREAK 
"if ( obj ) " 0
BREAK 
"if ( CInt( obj.getprop( CPROP_INIT ) ) == CInt( inititem.serial ) ) // it belongs to the same group " 0
BREAK 
"items.append( obj ); " 0
BREAK 
"tempitems.append( obj.serial ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"inititem.setprop( CPROP_ITEMS, tempitems ); // save filtered serials " 0
BREAK 
"if ( ( !items ) || ( items == {} ) ) " 0
BREAK 
"SendSysMessage( who, "Items could not be found. " ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, items.size() + " Items recognized." ); " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Init item not found. " ); " 0
BREAK 
"items := RecoverInitItem( tar ); " 0
BREAK 
"endif " 0
BREAK 
"elseif ( tar.getprop( CPROP_ITEMS ) ) " 0
BREAK 
"itemserials := tar.getprop( CPROP_ITEMS ); " 0
BREAK 
"items := {}; " 0
BREAK 
"tempitems := {}; " 0
BREAK 
"foreach item in itemserials " 0
BREAK 
"obj := SystemFindObjectBySerial( item ); " 0
BREAK 
"if ( obj ) " 0
BREAK 
"if ( CInt( obj.getprop( CPROP_INIT ) ) == CInt( tar.serial ) ) // it belongs to the same group " 0
BREAK 
"items.append( obj ); " 0
BREAK 
"tempitems.append( obj.serial ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"tar.setprop( CPROP_ITEMS, tempitems ); // save filtered serials " 0
BREAK 
"SendSysMessage( who, items.size() + " Items recognized." ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Invalid Item selected." ); " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Abort" ); " 0
BREAK 
"items := {}; " 0
BREAK 
"endif " 0
BREAK 
"else // Search for any items " 0
BREAK 
"zstart := retmodify[MODIFY_Z_START]; " 0
BREAK 
"zstart[1, 6] := ""; " 0
BREAK 
"zstart := CInt( zstart ); " 0
BREAK 
"zend := retmodify[MODIFY_Z_END]; " 0
BREAK 
"zend[1, 6] := ""; " 0
BREAK 
"zend := CInt( zend ); " 0
BREAK 
"datamodify_M[ZSTARTPOS] := zstart; " 0
BREAK 
"datamodify_M[ZENDPOS] := zend; " 0
BREAK 
"SendSysMessage( who, "Target the first corner of the area" ); " 0
BREAK 
"tar1 := TargetCoordinates( who ); " 0
BREAK 
"if ( tar1 ) " 0
BREAK 
"SendSysMessage( who, "Target the second corner of the area" ); " 0
BREAK 
"tar2 := TargetCoordinates( who ); " 0
BREAK 
"if ( tar2 ) " 0
BREAK 
"if ( tar1.x > tar2.x ) // Sorting the area " 0
BREAK 
"x1 := tar2.x; " 0
BREAK 
"x2 := tar1.x; " 0
BREAK 
"else " 0
BREAK 
"x1 := tar1.x; " 0
BREAK 
"x2 := tar2.x; " 0
BREAK 
"endif " 0
BREAK 
"if ( tar1.y > tar2.y ) " 0
BREAK 
"y1 := tar2.y; " 0
BREAK 
"y2 := tar1.y; " 0
BREAK 
"else " 0
BREAK 
"y1 := tar1.y; " 0
BREAK 
"y2 := tar2.y; " 0
BREAK 
"endif " 0
BREAK 
"items := {}; " 0
BREAK 
"foreach item in ListObjectsInBox( x1, y1, zstart, x2, y2, zend, tar2.realm ) " 0
BREAK 
"if ( item.isA( POLCLASS_ITEM ) ) " 0
BREAK 
"if ( !item.invisible ) // Don't take invisible stuff like spawn runes " 0
BREAK 
"items.append( item ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"if ( items <> {} ) " 0
BREAK 
"SendSysMessage( who, items.size() + " Items recognized." ); " 0
BREAK 
"if ( retmodify[MODIFY_MARK] ) " 0
BREAK 
"itemserials := {}; " 0
BREAK 
"foreach item in items " 0
BREAK 
"itemserials.append( item.serial ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"SendSysMessage( who, "Choose the original item." ); " 0
BREAK 
"breakflag := 0; " 0
BREAK 
"while ( who.connected ) " 0
BREAK 
"tar := Target( who, TGTOPT_NOCHECK_LOS ); " 0
BREAK 
"if ( tar ) " 0
BREAK 
"i := tar.serial in itemserials; " 0
BREAK 
"if ( i ) // Move the selected item to the first position " 0
BREAK 
"temp := itemserials[1]; " 0
BREAK 
"itemserials[i] := temp; " 0
BREAK 
"itemserials[1] := tar.serial; " 0
BREAK 
"foreach item in items " 0
BREAK 
"item.setprop( CPROP_INIT, tar.serial ); " 0
BREAK 
"item.eraseprop( CPROP_ITEMS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"tar.setprop( CPROP_ITEMS, itemserials ); " 0
BREAK 
"break;" 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Item is not among those recognized!" ); " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Abort" ); " 0
BREAK 
"breakflag := 1; " 0
BREAK 
"break;" 0
BREAK 
"endif " 0
BREAK 
"endwhile " 0
BREAK 
"items := {}; " 0
BREAK 
"if ( !breakflag ) " 0
BREAK 
"foreach item in itemserials // Reordering and final check " 0
BREAK 
"obj := SystemFindObjectBySerial( item ); " 0
BREAK 
"if ( obj ) " 0
BREAK 
"items.append( obj ); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"SendSysMessage( who, ".. and branded." ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "No items recognized." ); " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Abort" ); " 0
BREAK 
"items := {}; " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Abort" ); " 0
BREAK 
"items := {}; " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"if ( retmodify.keys[retmodify.keys.size()] > MODIFY_START ) " 0
BREAK 
"if ( items <> {} ) " 0
BREAK 
"if ( retmodify[MODIFY_Y_UP] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x, item.y + 1, item.z, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_Y_DOWN] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x, item.y - 1, item.z, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_X_UP] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x + 1, item.y, item.z, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_X_DOWN] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x - 1, item.y, item.z, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_XY_MM] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x - 1, item.y - 1, item.z, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_XY_PM] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x + 1, item.y - 1, item.z, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_XY_MP] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x - 1, item.y + 1, item.z, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_XY_PP] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x + 1, item.y + 1, item.z, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_Z_UP] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x, item.y, item.z + 1, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_Z_DOWN] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x, item.y, item.z - 1, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_DESTROY] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"DestroyItem( item ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"items := {}; " 0
BREAK 
"elseif ( retmodify[MODIFY_COLOR] ) " 0
BREAK 
"color := retmodify[ITEMCOLOR]; " 0
BREAK 
"color[1, 6] := ""; " 0
BREAK 
"color := CInt( color ); " 0
BREAK 
"foreach item in items " 0
BREAK 
"item.color := color; " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_DUPE] ) " 0
BREAK 
"dupe := {}; " 0
BREAK 
"dupeserials := {}; " 0
BREAK 
"foreach item in items " 0
BREAK 
"dupeitem := CreateItemCopyAtLocation( item.x, item.y, item.z, item, item.realm ); " 0
BREAK 
"if ( dupeitem ) " 0
BREAK 
"dupe.append( dupeitem ); " 0
BREAK 
"dupeserials.append( dupeitem.serial ); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"foreach item in dupe " 0
BREAK 
"item.setprop( CPROP_INIT, dupeserials[1] ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"dupe[1].setprop( CPROP_ITEMS, dupeserials ); " 0
BREAK 
"SendSysMessage( who, dupe.size() + " Items successfully duplicated." ); " 0
BREAK 
"items := dupe; // Continue working with a copy " 0
BREAK 
"elseif ( retmodify[MODIFY_X] ) " 0
BREAK 
"temp := retmodify[MODIFY_X_ENTRY]; " 0
BREAK 
"temp[1, 6] := ""; " 0
BREAK 
"temp := CInt( temp ) - items[1].x; " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x + temp, item.y, item.z, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_Y] ) " 0
BREAK 
"temp := retmodify[MODIFY_Y_ENTRY]; " 0
BREAK 
"temp[1, 6] := ""; " 0
BREAK 
"temp := CInt( temp ) - items[1].y; " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x, item.y + temp, item.z, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_Z] ) " 0
BREAK 
"temp := retmodify[MODIFY_Z_ENTRY]; " 0
BREAK 
"temp[1, 6] := ""; " 0
BREAK 
"temp := CInt( temp ) - items[1].z; " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x, item.y, item.z + temp, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "No items selected." ); " 0
BREAK 
"endif " 0
BREAK 
"elseif ( retmodify[MODIFY_MARKEDIT] ) " 0
BREAK 
"MarkEdit( who ); " 0
BREAK 
"else // Gump closed " 0
BREAK 
"SendSysMessage( who, "Abort" ); " 0
BREAK 
"break;" 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"endwhile " 0
BREAK 
"endfunction // }}} " 0
BREAK 
"function MarkEdit( who ) // {{{ " 0
BREAK 
"var ret, tar1, tar2, x1, x2, y1, y2, items := {}, itemref, inititem, itemserials, tempitems, obj, i; " 0
BREAK 
"while ( who.connected ) " 0
BREAK 
"ret := SendDialogGump( who, layoutmark, datamark, 10, 50 ); " 0
BREAK 
"if ( ret[MARK_SHOW] ) " 0
BREAK 
"SendSysMessage( who, "Target the first corner of the area" ); " 0
BREAK 
"tar1 := TargetCoordinates( who ); " 0
BREAK 
"if ( tar1 ) " 0
BREAK 
"SendSysMessage( who, "Target the second corner of the area" ); " 0
BREAK 
"tar2 := TargetCoordinates( who ); " 0
BREAK 
"if ( tar2 ) " 0
BREAK 
"if ( tar1.x > tar2.x ) // Sorting the area " 0
BREAK 
"x1 := tar2.x; " 0
BREAK 
"x2 := tar1.x; " 0
BREAK 
"else " 0
BREAK 
"x1 := tar1.x; " 0
BREAK 
"x2 := tar2.x; " 0
BREAK 
"endif " 0
BREAK 
"if ( tar1.y > tar2.y ) " 0
BREAK 
"y1 := tar2.y; " 0
BREAK 
"y2 := tar1.y; " 0
BREAK 
"else " 0
BREAK 
"y1 := tar1.y; " 0
BREAK 
"y2 := tar2.y; " 0
BREAK 
"endif " 0
BREAK 
"items := {}; " 0
BREAK 
"foreach item in ListObjectsInBox( x1, y1, -127, x2, y2, 128, tar2.realm ) " 0
BREAK 
"if ( item.isA( POLCLASS_ITEM ) ) " 0
BREAK 
"if ( item.getprop( CPROP_ITEMS ) ) " 0
BREAK 
"items.append( item ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"if ( items <> {} ) " 0
BREAK 
"foreach item in items // Coloring by groups " 0
BREAK 
"foreach slaveitem in ( item.getprop( CPROP_ITEMS ) ) " 0
BREAK 
"itemref := SystemFindObjectBySerial( slaveitem ); " 0
BREAK 
"if ( itemref ) " 0
BREAK 
"if ( itemref.getprop( CPROP_COLOR ).errortext ) " 0
BREAK 
"itemref.setprop( CPROP_COLOR, itemref.color ); " 0
BREAK 
"endif " 0
BREAK 
"itemref.color := _item_iter + 6; " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"elseif ( ret[MARK_HIDE] ) " 0
BREAK 
"SendSysMessage( who, "Target the first corner of the area" ); " 0
BREAK 
"tar1 := TargetCoordinates( who ); " 0
BREAK 
"if ( tar1 ) " 0
BREAK 
"SendSysMessage( who, "Target the second corner of the area" ); " 0
BREAK 
"tar2 := TargetCoordinates( who ); " 0
BREAK 
"if ( tar2 ) " 0
BREAK 
"if ( tar1.x > tar2.x ) // Sorting the area " 0
BREAK 
"x1 := tar2.x; " 0
BREAK 
"x2 := tar1.x; " 0
BREAK 
"else " 0
BREAK 
"x1 := tar1.x; " 0
BREAK 
"x2 := tar2.x; " 0
BREAK 
"endif " 0
BREAK 
"if ( tar1.y > tar2.y ) " 0
BREAK 
"y1 := tar2.y; " 0
BREAK 
"y2 := tar1.y; " 0
BREAK 
"else " 0
BREAK 
"y1 := tar1.y; " 0
BREAK 
"y2 := tar2.y; " 0
BREAK 
"endif " 0
BREAK 
"items := {}; " 0
BREAK 
"foreach item in ListObjectsInBox( x1, y1, -127, x2, y2, 128, tar2.realm ) " 0
BREAK 
"if ( item.isA( POLCLASS_ITEM ) ) " 0
BREAK 
"if ( item.getprop( CPROP_ITEMS ) ) " 0
BREAK 
"items.append( item ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"if ( items <> {} ) " 0
BREAK 
"foreach item in items // Coloring by groups " 0
BREAK 
"foreach slaveitem in ( item.getprop( CPROP_ITEMS ) ) " 0
BREAK 
"itemref := SystemFindObjectBySerial( slaveitem ); " 0
BREAK 
"if ( itemref ) " 0
BREAK 
"if ( itemref.getprop( CPROP_COLOR ).errortext ) " 0
BREAK 
"itemref.setprop( CPROP_COLOR, itemref.color ); " 0
BREAK 
"endif " 0
BREAK 
"itemref.color := _item_iter + 6; " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"foreach item in ListObjectsInBox( x1, y1, -128, x2, y2, 127, tar2.realm ) " 0
BREAK 
"if ( item.isA( POLCLASS_ITEM ) ) " 0
BREAK 
"if ( ( item.getprop( CPROP_ITEMS ) ) && ( !item.getprop( CPROP_COLOR ).errortext ) ) " 0
BREAK 
"foreach slaveitem in ( item.getprop( CPROP_ITEMS ) ) " 0
BREAK 
"itemref := SystemFindObjectBySerial( slaveitem ); " 0
BREAK 
"if ( itemref ) " 0
BREAK 
"if ( !itemref.getprop( CPROP_COLOR ).errortext ) " 0
BREAK 
"itemref.color := CInt( item.getprop( CPROP_COLOR ) ); " 0
BREAK 
"itemref.eraseprop( CPROP_COLOR ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"elseif ( ret[MARK_EDIT] ) " 0
BREAK 
"SendSysMessage( who, "Selects the item group." ); " 0
BREAK 
"tar1 := Target( who, TGTOPT_NOCHECK_LOS ); " 0
BREAK 
"items := {}; " 0
BREAK 
"tempitems := {}; " 0
BREAK 
"if ( ( !tar1.getprop( CPROP_ITEMS ) ) && ( tar1.getprop( CPROP_INIT ) ) ) " 0
BREAK 
"inititem := SystemFindObjectBySerial( tar1.getprop( CPROP_INIT ) ); " 0
BREAK 
"if ( inititem ) " 0
BREAK 
"itemserials := inititem.getprop( CPROP_ITEMS ); " 0
BREAK 
"foreach item in itemserials " 0
BREAK 
"obj := SystemFindObjectBySerial( item ); " 0
BREAK 
"if ( obj ) " 0
BREAK 
"if ( ( CInt( obj.getprop( CPROP_INIT ) ) == CInt( inititem.serial ) ) && ( !( obj.serial in tempitems ) ) ) // it belongs to the same group " 0
BREAK 
"items.append( obj ); " 0
BREAK 
"tempitems.append( obj.serial ); " 0
BREAK 
"if ( obj.getprop( CPROP_COLOR ).errortext ) " 0
BREAK 
"obj.setprop( CPROP_COLOR, obj.color ); " 0
BREAK 
"endif " 0
BREAK 
"obj.color := 1281; " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"inititem.setprop( CPROP_ITEMS, tempitems ); // save filtered serials " 0
BREAK 
"if ( ( !items ) || ( items == {} ) ) " 0
BREAK 
"SendSysMessage( who, "Items could not be found. " ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, items.size() + " Items recognized." ); " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "Init item not found. " ); " 0
BREAK 
"items := RecoverInitItem( tar1 ); " 0
BREAK 
"endif " 0
BREAK 
"elseif ( tar1.getprop( CPROP_ITEMS ) ) " 0
BREAK 
"itemserials := tar1.getprop( CPROP_ITEMS ); " 0
BREAK 
"foreach item in itemserials " 0
BREAK 
"obj := SystemFindObjectBySerial( item ); " 0
BREAK 
"if ( obj ) " 0
BREAK 
"if ( CInt( obj.getprop( CPROP_INIT ) ) == CInt( tar1.serial ) ) // it belongs to the same group " 0
BREAK 
"items.append( obj ); " 0
BREAK 
"tempitems.append( obj.serial ); " 0
BREAK 
"if ( obj.getprop( CPROP_COLOR ).errortext ) " 0
BREAK 
"obj.setprop( CPROP_COLOR, obj.color ); " 0
BREAK 
"endif " 0
BREAK 
"obj.color := 1281; " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"tar1.setprop( CPROP_ITEMS, tempitems ); // save filtered serials " 0
BREAK 
"SendSysMessage( who, items.size() + " Items recognized." ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( who, "No items recognized." ); " 0
BREAK 
"endif " 0
BREAK 
"if ( items <> {} ) " 0
BREAK 
"while ( who.connected ) " 0
BREAK 
"SendSysMessage( who, "Selects the item to be added / removed." ); " 0
BREAK 
"tar1 := Target( who, TGTOPT_NOCHECK_LOS ); " 0
BREAK 
"if ( ( !tar1 ) && ( !tar1.isA( POLCLASS_ITEM ) ) ) " 0
BREAK 
"SendSysMessage( who, "Abort" ); " 0
BREAK 
"break;" 0
BREAK 
"endif " 0
BREAK 
"i := tar1.serial in tempitems; " 0
BREAK 
"if ( i ) // Remove from group " 0
BREAK 
"tempitems.erase( i ); " 0
BREAK 
"items.erase( i ); " 0
BREAK 
"tar1.eraseprop( CPROP_INIT ); " 0
BREAK 
"tar1.eraseprop( CPROP_ITEMS ); " 0
BREAK 
"if ( !tar1.getprop( CPROP_COLOR ).errortext ) " 0
BREAK 
"tar1.color := CInt( tar1.getprop( CPROP_COLOR ) ); " 0
BREAK 
"tar1.eraseprop( CPROP_COLOR ); " 0
BREAK 
"endif " 0
BREAK 
"else // Add " 0
BREAK 
"if ( tar1.getprop( CPROP_COLOR ).errortext ) " 0
BREAK 
"tar1.setprop( CPROP_COLOR, tar1.color ); " 0
BREAK 
"endif " 0
BREAK 
"tar1.color := items[1].color; " 0
BREAK 
"tempitems.append( tar1.serial ); " 0
BREAK 
"items.append( tar1 ); " 0
BREAK 
"endif " 0
BREAK 
"endwhile " 0
BREAK 
"foreach item in items " 0
BREAK 
"item.setprop( CPROP_INIT, items[1].serial ); " 0
BREAK 
"item.eraseprop( CPROP_ITEMS ); " 0
BREAK 
"endforeach " 0
BREAK 
"items[1].setprop( CPROP_ITEMS, tempitems ); " 0
BREAK 
"foreach item in items " 0
BREAK 
"if ( !item.getprop( CPROP_COLOR ).errortext ) " 0
BREAK 
"item.color := CInt( item.getprop( CPROP_COLOR ) ); " 0
BREAK 
"item.eraseprop( CPROP_COLOR ); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 1 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"if ( x1 ) // If something has been done, reset the color " 0
BREAK 
"foreach item in ListObjectsInBox( x1, y1, -128, x2, y2, 127, tar2.realm ) " 0
BREAK 
"if ( item.isA( POLCLASS_ITEM ) ) " 0
BREAK 
"if ( ( item.getprop( CPROP_ITEMS ) ) && ( !item.getprop( CPROP_COLOR ).errortext ) ) " 0
BREAK 
"foreach slaveitem in ( item.getprop( CPROP_ITEMS ) ) " 0
BREAK 
"itemref := SystemFindObjectBySerial( slaveitem ); " 0
BREAK 
"if ( itemref ) " 0
BREAK 
"if ( !itemref.getprop( CPROP_COLOR ).errortext ) " 0
BREAK 
"itemref.color := CInt( item.getprop( CPROP_COLOR ) ); " 0
BREAK 
"itemref.eraseprop( CPROP_COLOR ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"SendSysMessage( who, "Abort" ); " 0
BREAK 
"return; " 0
BREAK 
"endif " 0
BREAK 
"endwhile " 0
BREAK 
"endfunction // }}} " 0
BREAK 
"function ModifyItems( who, byref items ) // {{{ " 0
BREAK 
"var retmodify, color, temp, dupe := {}, dupeitem, dupeserials := {}; " 0
BREAK 
"if ( TypeOfInt( items ) != OT_ARRAY ) " 0
BREAK 
"temp := items; " 0
BREAK 
"items := {}; " 0
BREAK 
"items.append( temp ); " 0
BREAK 
"endif " 0
BREAK 
"while ( who.connected ) " 0
BREAK 
"datamodify[COLORDATAPOS] := items[1].color; " 0
BREAK 
"datamodify[XKOORDSPOS] := "<basefont color=" + HTML_WHITE + "><p align=right>" + items[1].x + "</p></basefont>"; " 0
BREAK 
"datamodify[YKOORDSPOS] := "<basefont color=" + HTML_WHITE + "><p align=right>" + items[1].y + "</p></basefont>"; " 0
BREAK 
"datamodify[ZKOORDSPOS] := "<basefont color=" + HTML_WHITE + "><p align=right>" + items[1].z + "</p></basefont>"; " 0
BREAK 
"datamodify[XENTRY] := items[1].x; " 0
BREAK 
"datamodify[YENTRY] := items[1].y; " 0
BREAK 
"datamodify[ZENTRY] := items[1].z; " 0
BREAK 
"retmodify := SendDialogGump( who, layoutmodify, datamodify, 10, 50 ); " 0
BREAK 
"if ( retmodify[MODIFY_Y_UP] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x, item.y + 1, item.z, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_Y_DOWN] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x, item.y - 1, item.z, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_X_UP] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x + 1, item.y, item.z, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_X_DOWN] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x - 1, item.y, item.z, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_XY_MM] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x - 1, item.y - 1, item.z, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_XY_PM] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x + 1, item.y - 1, item.z, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_XY_MP] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x - 1, item.y + 1, item.z, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_XY_PP] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x + 1, item.y + 1, item.z, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_Z_UP] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x, item.y, item.z + 1, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_Z_DOWN] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x, item.y, item.z - 1, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_DESTROY] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"DestroyItem( item ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"break;" 0
BREAK 
"elseif ( retmodify[MODIFY_COLOR] ) " 0
BREAK 
"color := retmodify[ITEMCOLOR]; " 0
BREAK 
"color[1, 6] := ""; " 0
BREAK 
"color := CInt( color ); " 0
BREAK 
"foreach item in items " 0
BREAK 
"item.color := color; " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_DUPE] ) " 0
BREAK 
"dupe := {}; " 0
BREAK 
"dupeserials := {}; " 0
BREAK 
"foreach item in items " 0
BREAK 
"dupeitem := CreateItemCopyAtLocation( item.x, item.y, item.z, item, item.realm ); " 0
BREAK 
"if ( dupeitem ) " 0
BREAK 
"dupe.append( dupeitem ); " 0
BREAK 
"dupeserials.append( dupeitem.serial ); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"foreach item in dupe " 0
BREAK 
"item.setprop( CPROP_INIT, dupeserials[1] ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"dupe[1].setprop( CPROP_ITEMS, dupeserials ); " 0
BREAK 
"SendSysMessage( who, dupe.size() + " Items successfully duplicated." ); " 0
BREAK 
"items := dupe; // Edit copy further " 0
BREAK 
"elseif ( retmodify[MODIFY_X] ) " 0
BREAK 
"temp := retmodify[MODIFY_X_ENTRY]; " 0
BREAK 
"temp[1, 6] := ""; " 0
BREAK 
"temp := CInt( temp ) - items[1].x; " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x + temp, item.y, item.z, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_Y] ) " 0
BREAK 
"temp := retmodify[MODIFY_Y_ENTRY]; " 0
BREAK 
"temp[1, 6] := ""; " 0
BREAK 
"temp := CInt( temp ) - items[1].y; " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x, item.y + temp, item.z, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[MODIFY_Z] ) " 0
BREAK 
"temp := retmodify[MODIFY_Z_ENTRY]; " 0
BREAK 
"temp[1, 6] := ""; " 0
BREAK 
"temp := CInt( temp ) - items[1].z; " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( item, item.x, item.y, item.z + temp, item.realm, ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( retmodify[BACKBUTTON] ) " 0
BREAK 
"break;" 0
BREAK 
"else " 0
BREAK 
"return ( 0 ); // Abbruch " 0
BREAK 
"endif " 0
BREAK 
"endwhile " 0
BREAK 
"return ( 1 ); " 0
BREAK 
"endfunction // }}} " 0
BREAK 
"function ChooseRandom( byref liste ) // {{{ " 0
BREAK 
"var verteilung := 0, i; " 0
BREAK 
"var rand := RandomInt( 100 ) + 1; " 0
BREAK 
"if ( Find( liste[1], "%", 1 ) ) // Distribution according to Cfg " 0
BREAK 
"for ( i := 1; i <= liste.size(); i += 1 ) " 0
BREAK 
"verteilung += CInt( SplitWords( liste[i], "%" )[2] ); " 0
BREAK 
"if ( rand <= verteilung ) " 0
BREAK 
"return ( SplitWords( liste[i], "%" )[1] ); " 0
BREAK 
"endif " 0
BREAK 
"endfor " 0
BREAK 
"else // Gleichverteilt " 0
BREAK 
"verteilung := CInt( 100 / liste.size() ); " 0
BREAK 
"for ( i := 1; i <= liste.size(); i += 1 ) " 0
BREAK 
"if ( rand <= ( i * verteilung ) ) // within the probability? " 0
BREAK 
"return ( liste[i] ); // Shoo Shoo " 0
BREAK 
"endif " 0
BREAK 
"endfor " 0
BREAK 
"endif " 0
BREAK 
"return ( liste.randomentry() ); // well then just like that " 0
BREAK 
"endfunction // }}} " 0
BREAK 
"function MenuBar( byref layout, byref data, byref datadict ) // {{{ " 0
BREAK 
"var i, page := 1, y := 66, nextpagebreak := MAXBUTTON + 1; " 0
BREAK 
"if ( TypeOfInt( datadict ) == OT_DICTIONARY ) // Data in dictionary or array " 0
BREAK 
"for ( i := 1; i <= datadict.keys().size(); i += 1 ) " 0
BREAK 
"if ( i == nextpagebreak ) " 0
BREAK 
"nextpagebreak += MAXBUTTON; " 0
BREAK 
"y := 66; " 0
BREAK 
"page += 1; " 0
BREAK 
"layout.append( "button 565 287 5602 5606 0 " + page ); " 0
BREAK 
"layout.append( "page " + page ); " 0
BREAK 
"layout.append( "button 580 287 5600 5604 0 " + ( page - 1 ) ); " 0
BREAK 
"endif " 0
BREAK 
"layout.append( "button 525 " + ( y ) + " 2440 2440 1 0 " + ( MENUSTART + i ) ); " 0
BREAK 
"layout.append( "htmlgump 525 " + ( y ) + " 166 25 " + data.size() + " 1 0" ); " 0
BREAK 
"if ( ( cfgrandom[datadict.keys()[i]] ) && ( cfgrandom[datadict.keys()[i]].name ) ) " 0
BREAK 
"data.append( "<basefont color=" + HTML_DARKGRAY + "><center>" + cfgrandom[datadict.keys()[i]].name + "</center>" ); " 0
BREAK 
"elseif ( ( cfgeinzel[datadict.keys()[i]] ) && ( cfgeinzel[datadict.keys()[i]].name ) ) " 0
BREAK 
"data.append( "<basefont color=" + HTML_DARKBLUE + "><center>" + cfgeinzel[datadict.keys()[i]].name + "</center>" ); " 0
BREAK 
"elseif ( cfgset[datadict.keys()[i]].name ) " 0
BREAK 
"data.append( "<basefont color=" + HTML_DARKBLUE + "><center>" + cfgset[datadict.keys()[i]].name + "</center>" ); " 0
BREAK 
"else " 0
BREAK 
"data.append( "<basefont color=" + HTML_DARKGRAY + "><center>" + datadict.keys()[i] + "</center>" ); " 0
BREAK 
"endif " 0
BREAK 
"y += 30; " 0
BREAK 
"endfor " 0
BREAK 
"else " 0
BREAK 
"for ( i := 1; i <= datadict.size(); i += 1 ) " 0
BREAK 
"if ( i == nextpagebreak ) " 0
BREAK 
"nextpagebreak += MAXBUTTON; " 0
BREAK 
"y := 66; " 0
BREAK 
"page += 1; " 0
BREAK 
"layout.append( "button 565 287 5602 5606 0 " + page + " 0" ); " 0
BREAK 
"layout.append( "page " + page ); " 0
BREAK 
"layout.append( "button 580 287 5600 5604 0 " + ( page - 1 ) + " 0" ); " 0
BREAK 
"endif " 0
BREAK 
"layout.append( "button 525 " + ( y ) + " 2440 2440 1 0 " + ( MENUSTART + i ) ); " 0
BREAK 
"layout.append( "htmlgump 525 " + ( y ) + " 166 25 " + data.size() + " 1 0" ); " 0
BREAK 
"if ( TypeOfInt( datadict[i] ) == OT_ARRAY ) // Typebezeichnung im Array " 0
BREAK 
"if ( ( cfgrandom[datadict[i][1]].name ) || ( cfgeinzel[datadict[i][1]].name ) || ( cfgset[datadict[i][1]].name ) ) " 0
BREAK 
"case ( datadict[i][2] ) " 0
BREAK 
""Random": " 0
BREAK 
"data.append( "<basefont color=" + HTML_SADDLEBROWN + "><center>" + cfgrandom[datadict[i][1]].name + "</center>" ); " 0
BREAK 
""Einzel": " 0
BREAK 
"data.append( "<basefont color=" + HTML_SADDLEBROWN + "><center>" + cfgeinzel[datadict[i][1]].name + "</center>" ); " 0
BREAK 
""Set": " 0
BREAK 
"data.append( "<basefont color=" + HTML_SADDLEBROWN + "><center>" + cfgset[datadict[i][1]].name + "</center>" ); " 0
BREAK 
"endcase " 0
BREAK 
"else " 0
BREAK 
"data.append( "<basefont color=" + HTML_SADDLEBROWN + "><center>" + datadict[i][1] + "</center>" ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"y += 30; " 0
BREAK 
"endfor " 0
BREAK 
"endif " 0
BREAK 
"endfunction // }}} " 0
BREAK 
"function Init() // {{{ " 0
BREAK 
"var layoutraw := { "nodispose", "page 0", // "resizepic 500 0 3600 215 390",  // Background " 0
"// "resizepic 515 15 5054 185 30",  // title " 0
""resizepic 500 0 9200 215 390", "resizepic 515 15 3000 185 30", "htmlgump 515 22 185 30 0 0 0", // Title text " 0
"// "gumppictiled 516 47 183 328 2624", " 0
"// "resizepic 516 47 83 183 328",   // Posts " 0
""resizepic 516 47 3000 183 328", // "checkertrans 524 57 168 308", " 0
""htmlgump 610 285 50 20 1 0 0", "button 660 280 9726 9728 1 0 " + BACKBUTTON, "gumppictiled 525 320 166 2 30002", "button 530 330 9721 9724 1 0 " + ITEMMODIFYMANUAL, "htmlgump 572 335 100 30 2 0 0", "page 1" }; " 0
BREAK 
"var dataraw := { "", // Titel " 0
""<basefont color=" + HTML_DARKBLUE + ">Back", "<basefont color=" + HTML_DARKBLUE + ">Item Modify" }; " 0
BREAK 
"SysLog( ".BAUTOOL Datafile begin" ); " 0
BREAK 
"SetGlobalProperty( "bautoolinit", 1 ); " 0
BREAK 
"var dataelement, layout := {}, data := {}, layoutp := {}; " 0
BREAK 
"var element := dictionary; " 0
BREAK 
"var cfgmenu := ReadConfigFile( "bautoolmenues" ); " 0
BREAK 
"DFPurgeFile( datafile ); " 0
BREAK 
"dataelement := datafile.CreateElement( "menu" ); " 0
BREAK 
"foreach key in ( GetConfigStringArray( cfgmenu["Rootlist"], "sublist" ) ) // 1. level " 0
BREAK 
"element[key] := dictionary; " 0
BREAK 
"if ( cfgmenu[key].list ) // Items " 0
BREAK 
"foreach itemlist in ( GetConfigStringArray( cfgmenu[key], "list" ) ) " 0
BREAK 
"element[key][itemlist] := array; " 0
BREAK 
"foreach itemkey in ( GetConfigStringKeys( cfgrandom ) ) // Insert possible random " 0
BREAK 
"if ( cfgrandom[itemkey].list == itemlist ) " 0
BREAK 
"element[key][itemlist].append( { itemkey, "Random", cfgrandom[itemkey].name } ); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"foreach itemkey in ( GetConfigStringKeys( cfgeinzel ) ) // Insert possible single " 0
BREAK 
"if ( cfgeinzel[itemkey].list == itemlist ) " 0
BREAK 
"element[key][itemlist].append( { itemkey, "Einzel", cfgeinzel[itemkey].name } ); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"foreach itemkey in ( GetConfigStringKeys( cfgset ) ) // Insert possible sets " 0
BREAK 
"if ( cfgset[itemkey].list == itemlist ) " 0
BREAK 
"element[key][itemlist].append( { itemkey, "Set", cfgset[itemkey].name } ); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"element[key][itemlist] := SortArrayABC( element[key][itemlist], 1, 3 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"if ( cfgmenu[key].sublist ) " 0
BREAK 
"foreach sub1key in ( GetConfigStringArray( cfgmenu[key], "sublist" ) ) // 2. level " 0
BREAK 
"element[key][sub1key] := dictionary; " 0
BREAK 
"if ( cfgmenu[sub1key].list ) // Items " 0
BREAK 
"foreach itemlist in ( GetConfigStringArray( cfgmenu[sub1key], "list" ) ) " 0
BREAK 
"element[key][sub1key][itemlist] := array; " 0
BREAK 
"foreach itemkey in ( GetConfigStringKeys( cfgrandom ) ) // Insert possible random " 0
BREAK 
"if ( cfgrandom[itemkey].list == itemlist ) " 0
BREAK 
"element[key][sub1key][itemlist].append( { itemkey, "Random", cfgrandom[itemkey].name } ); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"foreach itemkey in ( GetConfigStringKeys( cfgeinzel ) ) // Insert possible single " 0
BREAK 
"if ( cfgeinzel[itemkey].list == itemlist ) " 0
BREAK 
"element[key][sub1key][itemlist].append( { itemkey, "Einzel", cfgeinzel[itemkey].name } ); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"foreach itemkey in ( GetConfigStringKeys( cfgset ) ) // Insert possible sets " 0
BREAK 
"if ( cfgset[itemkey].list == itemlist ) " 0
BREAK 
"element[key][sub1key][itemlist].append( { itemkey, "Set", cfgset[itemkey].name } ); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"element[key][sub1key][itemlist] := SortArrayABC( element[key][sub1key][itemlist], 1, 3 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"if ( cfgmenu[sub1key].sublist ) " 0
BREAK 
"foreach sub2key in ( GetConfigStringArray( cfgmenu[sub1key], "sublist" ) ) // 3. level " 0
BREAK 
"element[key][sub1key][sub2key] := dictionary; " 0
BREAK 
"if ( cfgmenu[sub2key].list ) // Items " 0
BREAK 
"foreach itemlist in ( GetConfigStringArray( cfgmenu[sub2key], "list" ) ) " 0
BREAK 
"element[key][sub1key][sub2key][itemlist] := array; " 0
BREAK 
"foreach itemkey in ( GetConfigStringKeys( cfgrandom ) ) // Insert possible random " 0
BREAK 
"if ( cfgrandom[itemkey].list == itemlist ) " 0
BREAK 
"element[key][sub1key][sub2key][itemlist].append( { itemkey, "Random", cfgrandom[itemkey].name } ); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"foreach itemkey in ( GetConfigStringKeys( cfgeinzel ) ) // Insert possible single " 0
BREAK 
"if ( cfgeinzel[itemkey].list == itemlist ) " 0
BREAK 
"element[key][sub1key][sub2key][itemlist].append( { itemkey, "Einzel", cfgeinzel[itemkey].name } ); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"foreach itemkey in ( GetConfigStringKeys( cfgset ) ) // Insert possible sets " 0
BREAK 
"if ( cfgset[itemkey].list == itemlist ) " 0
BREAK 
"element[key][sub1key][sub2key][itemlist].append( { itemkey, "Set", cfgset[itemkey].name } ); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"element[key][sub1key][sub2key][itemlist] := SortArrayABC( element[key][sub1key][sub2key][itemlist], 1, 3 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"if ( cfgmenu[sub2key].sublist ) " 0
BREAK 
"foreach sub3key in ( GetConfigStringArray( cfgmenu[sub2key], "sublist" ) ) // 4. level " 0
BREAK 
"element[key][sub1key][sub2key][sub3key] := dictionary; " 0
BREAK 
"if ( cfgmenu[sub3key].list ) // Items " 0
BREAK 
"foreach itemlist in ( GetConfigStringArray( cfgmenu[sub3key], "list" ) ) " 0
BREAK 
"element[key][sub1key][sub2key][sub3key][itemlist] := array; " 0
BREAK 
"foreach itemkey in ( GetConfigStringKeys( cfgrandom ) ) // Insert possible random " 0
BREAK 
"if ( cfgrandom[itemkey].list == itemlist ) " 0
BREAK 
"element[key][sub1key][sub2key][sub3key][itemlist].append( { itemkey, "Random", cfgrandom[itemkey].name } ); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"foreach itemkey in ( GetConfigStringKeys( cfgeinzel ) ) // Insert possible single " 0
BREAK 
"if ( cfgeinzel[itemkey].list == itemlist ) " 0
BREAK 
"element[key][sub1key][sub2key][sub3key][itemlist].append( { itemkey, "Einzel", cfgeinzel[itemkey].name } ); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"foreach itemkey in ( GetConfigStringKeys( cfgset ) ) // Insert possible sets " 0
BREAK 
"if ( cfgset[itemkey].list == itemlist ) " 0
BREAK 
"element[key][sub1key][sub2key][sub3key][itemlist].append( { itemkey, "Set", cfgset[itemkey].name } ); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"element[key][sub1key][sub2key][sub3key][itemlist] := SortArrayABC( element[key][sub1key][sub2key][sub3key][itemlist], 1, 3 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"endforeach " 0
BREAK 
"layout := layoutraw; " 0
BREAK 
"data := dataraw; " 0
BREAK 
"MenuBar( layout, data, element ); " 0
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>BauTool " + VERSION + "</center>"; " 0
BREAK 
"dataelement.setprop( "LayoutMenuBar", layout ); " 0
BREAK 
"dataelement.setprop( "DataMenuBar", data ); " 0
BREAK 
"foreach ebene1 in element // 1. level " 0
BREAK 
"layout := layoutraw; " 0
BREAK 
"data := dataraw; " 0
BREAK 
"MenuBar( layout, data, ebene1 ); " 0
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene1_iter + "</center>"; " 0
BREAK 
"dataelement.setprop( "LayoutMain_" + _ebene1_iter, layout ); " 0
BREAK 
"dataelement.setprop( "DataMain_" + _ebene1_iter, data ); " 0
BREAK 
"foreach ebene2 in ebene1 // 2.level " 0
BREAK 
"layout := layoutraw; " 0
BREAK 
"data := dataraw; " 0
BREAK 
"MenuBar( layout, data, ebene2 ); " 0
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene2_iter + "</center>"; " 0
BREAK 
"dataelement.setprop( "LayoutSub_" + _ebene1_iter + "_" + _ebene2_iter, layout ); " 0
BREAK 
"dataelement.setprop( "DataSub_" + _ebene1_iter + "_" + _ebene2_iter, data ); " 0
BREAK 
"if ( TypeOfInt( ebene2 ) <> OT_DICTIONARY ) // Items " 0
BREAK 
"foreach item in ebene2 " 0
BREAK 
"InitItems( data, layout, item, _ebene2_iter, layoutraw, dataraw ); " 0
BREAK 
"dataelement.setprop( "LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + item[1], layout ); " 0
BREAK 
"dataelement.setprop( "DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + item[1], data ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"else " 0
BREAK 
"foreach ebene3 in ebene2 // 3.level " 0
BREAK 
"layout := layoutraw; " 0
BREAK 
"data := dataraw; " 0
BREAK 
"MenuBar( layout, data, ebene3 ); " 0
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene3_iter + "</center>"; " 0
BREAK 
"dataelement.setprop( "LayoutSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter, layout ); " 0
BREAK 
"dataelement.setprop( "DataSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter, data ); " 0
BREAK 
"if ( TypeOfInt( ebene3 ) <> OT_DICTIONARY ) // Items " 0
BREAK 
"foreach item in ebene3 " 0
BREAK 
"InitItems( data, layout, item, _ebene3_iter, layoutraw, dataraw ); " 0
BREAK 
"dataelement.setprop( "LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + item[1], layout ); " 0
BREAK 
"dataelement.setprop( "DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + item[1], data ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"else " 0
BREAK 
"foreach ebene4 in ebene3 // 4.level " 0
BREAK 
"layout := layoutraw; " 0
BREAK 
"data := dataraw; " 0
BREAK 
"MenuBar( layout, data, ebene4 ); " 0
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene4_iter + "</center>"; " 0
BREAK 
"dataelement.setprop( "LayoutSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter, layout ); " 0
BREAK 
"dataelement.setprop( "DataSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter, data ); " 0
BREAK 
"if ( TypeOfInt( ebene4 ) <> OT_DICTIONARY ) // Items " 0
BREAK 
"foreach item in ebene4 " 0
BREAK 
"InitItems( data, layout, item, _ebene4_iter, layoutraw, dataraw ); " 0
BREAK 
"dataelement.setprop( "LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + item[1], layout ); " 0
BREAK 
"dataelement.setprop( "DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + item[1], data ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"else " 0
BREAK 
"foreach ebene5 in ebene4 // 5.level " 0
BREAK 
"layout := layoutraw; " 0
BREAK 
"data := dataraw; " 0
BREAK 
"MenuBar( layout, data, ebene5 ); " 0
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene5_iter + "</center>"; " 0
BREAK 
"dataelement.setprop( "LayoutSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter, layout ); " 0
BREAK 
"dataelement.setprop( "DataSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter, data ); " 0
BREAK 
"if ( TypeOfInt( ebene5 ) <> OT_DICTIONARY ) // Items " 0
BREAK 
"foreach item in ebene5 " 0
BREAK 
"InitItems( data, layout, item, _ebene5_iter, layoutraw, dataraw ); " 0
BREAK 
"dataelement.setprop( "LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter + "_" + item[1], layout ); " 0
BREAK 
"dataelement.setprop( "DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter + "_" + item[1], data ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"else " 0
BREAK 
"foreach ebene6 in ebene5 // 6.level " 0
BREAK 
"InitItems( data, layout, ebene6, _ebene6_iter, layoutraw, dataraw ); " 0
BREAK 
"dataelement.setprop( "LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter + "_" + _ebene6_iter, layout ); " 0
BREAK 
"dataelement.setprop( "DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter + "_" + _ebene6_iter, data ); " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"endforeach " 0
BREAK 
"endforeach " 0
BREAK 
"dataelement := datafile.CreateElement( "modify" ); " 0
BREAK 
"layout := { "nodispose", "page 0", "resizepic 500 0 3600 215 280", // Background " 0
""resizepic 515 15 5054 185 30", // title " 0
""htmlgump 515 22 185 30 0 0 0", // Title text " 0
""resizepic 515 47 83 185 218", // Posts " 0
""checkertrans 523 57 170 198", "htmlgump 610 225 50 20 1 0 0", // Continue " 0
""htmlgump 555 79 50 20 2 0 0", // X/Y " 0
""htmlgump 624 79 50 20 3 0 0", // Z " 0
""button 660 220 9721 9724 1 0 " + BACKBUTTON, "button 560 60 5600 5604 1 0 " + MODIFY_Y_DOWN, "button 560 100 5602 5606 1 0 " + MODIFY_Y_UP, "button 530 80 5603 5607 1 0 " + MODIFY_X_DOWN, "button 590 80 5601 5605 1 0 " + MODIFY_X_UP, "button 534 60 22406 22407 1 0 " + MODIFY_XY_MM, "button 583 60 22401 22400 1 0 " + MODIFY_XY_PM, "button 534 100 22403 22402 1 0 " + MODIFY_XY_MP, "button 583 100 22404 22405 1 0 " + MODIFY_XY_PP, "button 620 60 5600 5604 1 0 " + MODIFY_Z_UP, "button 620 100 5602 5606 1 0 " + MODIFY_Z_DOWN, "htmlgump 570 165 50 20 4 0 0", "button 530 160 9727 9728 1 0 " + MODIFY_DESTROY, "htmlgump 570 200 50 30 10 0 0", "button 530 195 9727 9728 1 0 " + MODIFY_DUPE, "htmlgump 570 130 50 30 5 0 0", "resizepic 610 125 2620 58 30", "textentry 616 130 40 20 1000 " + ITEMCOLOR + " 6", "button 530 125 9727 9728 1 0 " + MODIFY_COLOR, "htmlgump 630 60 50 20 7 0 0", // x / y / z Coord Specification of the first item " 0
""tooltip 3000561", // Coords.: " 0
""htmlgump 630 80 50 20 8 0 0", "tooltip 3000561", "htmlgump 630 100 50 20 9 0 0", "tooltip 3000561", "button 681 64 2103 2104 0 2 0", "button 681 84 2103 2104 0 3 0", "button 681 104 2103 2104 0 4 0" }; " 0
BREAK 
"data := { "<basefont size=8 color=" + HTML_DARKGREEN + "><center>Modify Position</center>", // title " 0
""<basefont color=" + HTML_DARKBLUE + ">Continue", "<basefont color=" + HTML_DARKBLUE + ">X/Y", "<basefont color=" + HTML_DARKBLUE + ">Z", "<basefont color=" + HTML_DARKBLUE + ">Destroy", "<basefont color=" + HTML_DARKBLUE + ">Color", "0", "<basefont color=" + HTML_DARKBLUE + "><p align=right>x</p></basefont>", "<basefont color=" + HTML_DARKBLUE + "><p align=right>y</p></basefont>", "<basefont color=" + HTML_DARKBLUE + "><p align=right>z</p></basefont>", "<basefont color=" + HTML_DARKBLUE + ">Dupe", "0", "0", "0" }; " 0
BREAK 
"layoutp := { "page 2", "resizepic 720 40 3600 100 60", "resizepic 735 55 2620 48 30", "textentrylimited 741 60 30 20 1000 " + MODIFY_X_ENTRY + " 11 4", "button 790 63 2103 2104 1 0 " + MODIFY_X, "page 3", "resizepic 720 60 3600 100 60", "resizepic 735 75 2620 48 30", "textentrylimited 741 80 30 20 1000 " + MODIFY_Y_ENTRY + " 12 4", "button 790 83 2103 2104 1 0 " + MODIFY_Y, "page 4", "resizepic 720 80 3600 100 60", "resizepic 735 95 2620 48 30", "textentrylimited 741 100 30 20 1000 " + MODIFY_Z_ENTRY + " 13 4", "button 790 103 2103 2104 1 0 " + MODIFY_Z }; " 0
BREAK 
"dataelement.setprop( "LayoutMenu", layout + layoutp ); " 0
BREAK 
"dataelement.setprop( "DataMenu", data ); " 0
BREAK 
"layout[3] := "resizepic 500 0 3600 215 440"; // Background expand " 0
BREAK 
"layout[6] := "resizepic 516 47 83 183 377"; " 0
BREAK 
"layout[7] := "checkertrans 524 57 168 358"; " 0
BREAK 
"layout.erase( 8 ); // Next ButtonText " 0
BREAK 
"layout.erase( 10 ); // Next button " 0
BREAK 
"layout.append( "gumppictiled 525 235 165 2 30002" ); " 0
BREAK 
"layout.append( "htmlgump 595 255 100 20 1 0 0" ); " 0
BREAK 
"layout.append( "button 560 250 9721 9724 1 0 " + MODIFY_START ); " 0
BREAK 
"data[2] := "<basefont color=" + HTML_DARKBLUE + ">Choose Items"; " 0
BREAK 
"layout.append( "resizepic 530 285 2620 48 30" ); " 0
BREAK 
"layout.append( "textentry 536 290 30 20 1000 " + MODIFY_Z_START + " 14" ); " 0
BREAK 
"data.append( "-20" ); " 0
BREAK 
"layout.append( "resizepic 635 285 2620 48 30" ); " 0
BREAK 
"layout.append( "textentry 641 290 30 20 1000 " + MODIFY_Z_END + " 15" ); " 0
BREAK 
"data.append( "20" ); " 0
BREAK 
"layout.append( "htmlgump 585 290 50 20 16 0 0" ); " 0
BREAK 
"data.append( "<basefont color=" + HTML_DARKBLUE + ">Z-Range" ); " 0
BREAK 
"layout.append( "checkbox 530 320 9720 9723 0 " + MODIFY_CUSTOM ); " 0
BREAK 
"layout.append( "htmlgump 565 325 50 20 17 0 0" ); " 0
BREAK 
"data.append( "<basefont color=" + HTML_DARKBLUE + ">Custom" ); " 0
BREAK 
"layout.append( "checkbox 616 320 9720 9723 0 " + MODIFY_MARK ); " 0
BREAK 
"layout.append( "htmlgump 651 325 50 20 18 0 0" ); " 0
BREAK 
"data.append( "<basefont color=" + HTML_DARKBLUE + ">Mark" ); " 0
BREAK 
"layout.append( "gumppictiled 525 360 165 2 30002" ); " 0
BREAK 
"layout.append( "button 530 375 9721 9724 1 0 " + MODIFY_MARKEDIT ); " 0
BREAK 
"layout.append( "htmlgump 570 380 100 20 19 0 0" ); " 0
BREAK 
"data.append( "<basefont color=" + HTML_DARKBLUE + ">Mark Edit" ); " 0
BREAK 
"dataelement.setprop( "LayoutMenuManual", layout + layoutp ); " 0
BREAK 
"dataelement.setprop( "DataMenuManual", data ); " 0
BREAK 
"dataelement := datafile.CreateElement( "modifymark" ); " 0
BREAK 
"layout := { "nodispose", "page 0", "resizepic 500 0 3600 215 213", // Background " 0
""resizepic 515 15 5054 185 30", // title " 0
""htmlgump 515 22 185 30 0 0 0", // Title text " 0
""resizepic 515 47 83 185 150", // Posts-20 " 0
""checkertrans 523 57 170 130", "button 530 70 9721 9724 1 0 " + MARK_SHOW, "htmlgump 570 75 50 20 1 0 0", "button 530 105 9721 9724 1 0 " + MARK_HIDE, "htmlgump 570 110 50 20 2 0 0", "button 530 140 9721 9724 1 0 " + MARK_EDIT, "htmlgump 570 145 50 20 3 0 0" }; " 0
BREAK 
"data := { "<basefont size=8 color=" + HTML_DARKGRAY + "><center>Mark Edit</center>", "<basefont color=" + HTML_DARKBLUE + ">Show", "<basefont color=" + HTML_DARKBLUE + ">Hide", "<basefont color=" + HTML_DARKBLUE + ">Edit" }; " 0
BREAK 
"dataelement.setprop( "LayoutMenuMark", layout ); " 0
BREAK 
"dataelement.setprop( "DataMenuMark", data ); " 0
BREAK 
"dataelement := datafile.CreateElement( "elemente" ); " 0
BREAK 
"dataelement.setprop( "dictionary", element ); " 0
BREAK 
"EraseGlobalProperty( "bautoolinit" ); " 0
BREAK 
"SysLog( ".BAUTOOL Datafile completed" ); " 0
BREAK 
"endfunction // }}} " 0
BREAK 
"function InitItems( byref data, byref layout, byref element, name := 0, layoutraw, dataraw ) // {{{ " 0
BREAK 
"var tile, nextpagebreak, nextlinebreak, x, y, page, m, itemdesc; " 0
BREAK 
"case ( element[2] ) " 0
BREAK 
""Random": // Random " 0
BREAK 
"layout := layoutraw; " 0
BREAK 
"data := dataraw; " 0
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + name + "</center>"; " 0
BREAK 
"layout := layout + { "page 0", "resizepic 70 0 3600 404 170", "resizepic 85 15 5054 374 30", "htmlgump 85 22 374 30 " + data.size() + " 0 0", "resizepic 85 47 83 374 108", "checkertrans 93 57 359 88" }; " 0
BREAK 
"data.append( "<basefont size=5><center>" + cfgrandom[element[1]].name + "</center>" ); " 0
BREAK 
"tile := GetConfigStringArray( cfgrandom[element[1]], "tile" )[1]; " 0
BREAK 
"layout.append( "tilepic 95 60 " + CInt( SplitWords( tile, "," )[1] ) ); " 0
BREAK 
"layout.append( "htmlgump 160 70 50 30 " + data.size() + " 0 0" ); " 0
BREAK 
"data.append( "<basefont color=" + HTML_DARKBLUE + ">Color" ); " 0
BREAK 
"layout.append( "resizepic 200 65 2620 48 30" ); " 0
BREAK 
"layout.append( "textentry 206 70 30 20 1000 " + ITEMCOLOR + " " + data.size() ); " 0
BREAK 
"data.append( "0" ); " 0
BREAK 
"if ( ( GetConfigString( cfgrandom[element[1]], "n" ) ) // Option necessary for edge parts? " 0
"|| ( GetConfigString( cfgrandom[element[1]], "s" ) ) || ( GetConfigString( cfgrandom[element[1]], "e" ) ) || ( GetConfigString( cfgrandom[element[1]], "w" ) ) ) " 0
BREAK 
"layout.append( "htmlgump 360 60 50 40 " + data.size() + " 0 0" ); " 0
BREAK 
"data.append( "<basefont color=" + HTML_DARKBLUE + ">Produce Random Tiles" ); " 0
BREAK 
"layout.append( "checkbox 420 65 9720 9723 0 " + ITEMRAND ); " 0
BREAK 
"endif " 0
BREAK 
"layout.append( "htmlgump 260 70 50 30 " + data.size() + " 0 0" ); " 0
BREAK 
"data.append( "<basefont color=" + HTML_DARKBLUE + ">z-Coord" ); " 0
BREAK 
"layout.append( "resizepic 310 65 2620 38 30" ); " 0
BREAK 
"layout.append( "textentry 316 70 20 20 1000 " + ITEMPOS + " " + data.size() ); " 0
BREAK 
"data.append( "0" ); " 0
BREAK 
"layout.append( "checkbox 420 110 9720 9723 1 " + ITEMMODIFY ); " 0
BREAK 
"layout.append( "htmlgump 360 105 50 40 " + data.size() + " 0 0" ); " 0
BREAK 
"data.append( "<basefont color=" + HTML_DARKBLUE + ">Modify Position" ); " 0
BREAK 
"layout.append( "button 103 116 9721 9724 1 0 " + ITEMCREATE ); " 0
BREAK 
"layout.append( "htmlgump 140 121 50 30 " + data.size() + " 0 0" ); " 0
BREAK 
"data.append( "<basefont color=" + HTML_DARKBLUE + ">Create" ); " 0
BREAK 
""Einzel": " 0
BREAK 
"itemdesc := ReadConfigFile( ":*:itemdesc" ); // Reading of all Itemdesc's for name determination " 0
BREAK 
"layout := layoutraw; " 0
BREAK 
"data := dataraw; " 0
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + name + "</center>"; " 0
BREAK 
"layout := layout + { "page 0", "resizepic 70 0 3600 425 400", "resizepic 85 15 5054 395 30", "htmlgump 85 22 395 30 " + data.size() + " 0 0", "resizepic 85 47 83 395 343" }; " 0
BREAK 
"data.append( "<basefont size=5><center>" + cfgeinzel[element[1]].name + "</center>" ); " 0
BREAK 
"layout.append( "htmlgump 530 70 50 30 " + data.size() + " 0 0" ); " 0
BREAK 
"data.append( "<basefont color=" + HTML_DARKBLUE + ">Color" ); " 0
BREAK 
"layout.append( "resizepic 570 65 2620 48 30" ); " 0
BREAK 
"layout.append( "textentry 576 70 30 20 1000 " + ITEMCOLOR + " " + data.size() ); " 0
BREAK 
"data.append( "0" ); " 0
BREAK 
"layout.append( "htmlgump 530 110 50 30 " + data.size() + " 0 0" ); " 0
BREAK 
"data.append( "<basefont color=" + HTML_DARKBLUE + ">z-Coord" ); " 0
BREAK 
"layout.append( "resizepic 580 105 2620 38 30" ); " 0
BREAK 
"layout.append( "textentry 586 110 20 20 1000 " + ITEMPOS + " " + data.size() ); " 0
BREAK 
"data.append( "0" ); " 0
BREAK 
"layout.append( "checkbox 530 150 9720 9723 1 " + ITEMMODIFY ); " 0
BREAK 
"layout.append( "htmlgump 572 155 100 30 " + data.size() + " 0 0" ); " 0
BREAK 
"data.append( "<basefont color=" + HTML_DARKBLUE + ">Modify Position" ); " 0
BREAK 
"layout.append( "checkbox 530 185 9720 9723 0 " + ITEMMMULTICREATE ); " 0
BREAK 
"layout.append( "htmlgump 572 190 100 30 " + data.size() + " 0 0" ); " 0
BREAK 
"data.append( "<basefont color=" + HTML_DARKBLUE + ">Mark All" ); " 0
BREAK 
"layout.append( "button 570 225 9721 9724 1 0 " + ITEMCREATE ); " 0
BREAK 
"layout.append( "htmlgump 612 230 50 30 " + data.size() + " 0 0" ); " 0
BREAK 
"data.append( "<basefont color=" + HTML_DARKBLUE + ">Create" ); " 0
BREAK 
"tile := {}; " 0
BREAK 
"foreach tiles in ( GetConfigStringArray( cfgeinzel[element[1]], "tile" ) ) " 0
BREAK 
"if ( !tile ) " 0
BREAK 
"tile := { tiles }; " 0
BREAK 
"else " 0
BREAK 
"tile.append( tiles ); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"nextpagebreak := MAXLINEITEM * 2 + 1; " 0
BREAK 
"nextlinebreak := MAXLINEITEM + 1; " 0
BREAK 
"x := 100; " 0
BREAK 
"y := 60; " 0
BREAK 
"page := 1; " 0
BREAK 
"layout.append( "page 1" ); " 0
BREAK 
"for ( m := 1; m <= tile.size(); m += 1 ) " 0
BREAK 
"if ( m == nextpagebreak ) " 0
BREAK 
"nextpagebreak += MAXLINEITEM * 2; " 0
BREAK 
"nextlinebreak += MAXLINEITEM; " 0
BREAK 
"x := 100; " 0
BREAK 
"y := 60; " 0
BREAK 
"if ( page > 1 ) " 0
BREAK 
"layout.append( "button 250 360 5603 5607 0 " + ( page - 1 ) + " 0" ); " 0
BREAK 
"endif " 0
BREAK 
"page += 1; " 0
BREAK 
"layout.append( "button 280 360 5601 5605 0 " + page + " 0" ); " 0
BREAK 
"layout.append( "page " + page ); " 0
BREAK 
"endif " 0
BREAK 
"if ( m == nextlinebreak ) " 0
BREAK 
"y := 210; " 0
BREAK 
"x := 100; " 0
BREAK 
"nextlinebreak += MAXLINEITEM; " 0
BREAK 
"endif " 0
BREAK 
"layout.append( "radio " + ( x ) + " " + ( y + 35 ) + " 9720 9723 0 " + m ); " 0
BREAK 
"layout.append( "tilepic " + ( x + 35 ) + " " + ( y + 35 ) + " " + CInt( SplitWords( tile[m], "," )[1] ) ); " 0
BREAK 
"if ( itemdesc[Hex( tile[m] )].desc ) // Insert name .desc or CliLoc entry " 0
BREAK 
"layout.append( "htmlgump " + ( x + 5 ) + " " + ( y ) + " 90 40 " + data.size() + " 0 0" ); " 0
BREAK 
"data.append( "<basefont color=" + HTML_GRAY + ">" + itemdesc[Hex( tile[m] )].desc ); " 0
BREAK 
"else " 0
BREAK 
"layout.append( "xmfhtmlgumpcolor " + ( x + 5 ) + " " + ( y ) + " 90 40 " + ( 1020000 + CInt( tile[m] ) ) + " 0 0 " + XMFCOLOR_GRAY2 ); " 0
BREAK 
"endif " 0
BREAK 
"x += 90; " 0
BREAK 
"SleepMS( 2 ); " 0
BREAK 
"endfor " 0
BREAK 
"if ( page > 1 ) " 0
BREAK 
"layout.append( "button 250 360 5603 5607 0 " + ( page - 1 ) + " 0" ); " 0
BREAK 
"endif " 0
BREAK 
""Set": " 0
BREAK 
"layout := layoutraw; " 0
BREAK 
"data := dataraw; " 0
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + name + "</center>"; " 0
BREAK 
"layout.append( "htmlgump 515 60 185 30 " + data.size() + " 0 0" ); " 0
BREAK 
"data.append( "<basefont size=5 color=" + HTML_DARKGRAY + "><center>" + cfgset[element[1]].name + "</center>" ); " 0
BREAK 
"layout.append( "htmlgump 530 100 50 30 " + data.size() + " 0 0" ); " 0
BREAK 
"data.append( "<basefont color=" + HTML_DARKBLUE + ">Color" ); " 0
BREAK 
"layout.append( "resizepic 570 95 2620 48 30" ); " 0
BREAK 
"layout.append( "textentry 576 100 30 20 1000 " + ITEMCOLOR + " " + data.size() ); " 0
BREAK 
"data.append( "0" ); " 0
BREAK 
"layout.append( "htmlgump 530 140 50 30 " + data.size() + " 0 0" ); " 0
BREAK 
"data.append( "<basefont color=" + HTML_DARKBLUE + ">z-Coord" ); " 0
BREAK 
"layout.append( "resizepic 580 135 2620 38 30" ); " 0
BREAK 
"layout.append( "textentry 586 140 20 20 1000 " + ITEMPOS + " " + data.size() ); " 0
BREAK 
"data.append( "0" ); " 0
BREAK 
"layout.append( "checkbox 530 180 9720 9723 1 " + ITEMMODIFY ); " 0
BREAK 
"layout.append( "htmlgump 572 185 100 30 " + data.size() + " 0 0" ); " 0
BREAK 
"data.append( "<basefont color=" + HTML_DARKBLUE + ">Modify Position" ); " 0
BREAK 
"layout.append( "checkbox 530 215 9720 9723 0 " + ITEMMMULTICREATE ); " 0
BREAK 
"layout.append( "htmlgump 572 220 100 30 " + data.size() + " 0 0" ); " 0
BREAK 
"data.append( "<basefont color=" + HTML_DARKBLUE + ">Mark All" ); " 0
BREAK 
"layout.append( "button 570 255 9721 9724 1 0 " + ITEMCREATE ); " 0
BREAK 
"layout.append( "htmlgump 612 260 50 30 " + data.size() + " 0 0" ); " 0
BREAK 
"data.append( "<basefont color=" + HTML_DARKBLUE + ">Create" ); " 0
BREAK 
"endcase " 0
BREAK 
"endfunction // }}} " 0
BREAK 
"function RecoverInitItem( newinit ) // {{{ " 0
BREAK 
"var oldinit := newinit.getprop( CPROP_INIT ); " 0
BREAK 
"var found := array{ newinit }; " 0
BREAK 
"var serials := array{ newinit.serial }; " 0
BREAK 
"foreach item in ( ListItemsNearLocation( newinit.x, newinit.y, LIST_IGNORE_Z, MAXAREASIZE, newinit.realm ) ) " 0
BREAK 
"SleepMs( 2 ); " 0
BREAK 
"if ( item.serial == newinit.serial ) " 0
BREAK 
"continue;" 0
BREAK 
"endif " 0
BREAK 
"if ( item.getprop( CPROP_INIT ) == oldinit ) " 0
BREAK 
"found.append( item ); " 0
BREAK 
"serials.append( item.serial ); " 0
BREAK 
"item.setprop( CPROP_INIT, newinit.serial ); " 0
BREAK 
"endif " 0
BREAK 
"endforeach " 0
BREAK 
"newinit.setprop( CPROP_INIT, newinit.serial ); " 0
BREAK 
"newinit.setprop( CPROP_ITEMS, serials ); " 0
BREAK 
"return found; " 0
BREAK 
"endfunction // }}} " 0

FORMATTED:
///////////////////////////////////////////////////////////////////////////
// bautool - bequemes Erzeugen und Verändern von Items und Itemgruppen
//
// Author: Turley
// eMail : michi.at.www@gmx.de

// Konfigurationsdateien
// - Menustruktur
// - bautoolmenues.cfg
// - Erstellt Rechtecke mit Tiles (Zufällig oder nur einen)
// - bautoolrandom.cfg
// - Erstellt einzelne Items
// - bautooleinzel.cfg
// - Erstellt Sets
// - bautoolset.cfg

///////////////////////////////////////////////////////////////////////////
// ToDo:
// Zufallsding
// - Auswahlliste wie Random/Einzel/Sets
// - Wählt aus plus Wahrscheinlichkeiten
// - Wenn fertig zusammengestellt Eck-Koords angeben und
// createn, immer auf Maphöhe

use cfgfile;
use os;
use uo;
use util;

include "client";
include ":datafile:datafile";
include ":gumps:textConsts";
// Include "include/itemnpc";
// Include "include/msgs";
// Include "include/server";
// Include "include/set";
include "string";

const VERSION := "<basefont color=" + HTML_DARKBLUE + ">V4.2a";

enum TextEntry_Checkboxes
  ITEMCOLOR := 1000,
  ITEMRAND,
  ITEMCREATE,
  ITEMPOS,
  ITEMMODIFY,
  ITEMMMULTICREATE,
  ITEMMODIFYMANUAL, // Modify menu for later modification
  MODIFY_Z_START,
  MODIFY_Z_END,
  MODIFY_CUSTOM,
  MODIFY_MARK,
  MODIFY_X_ENTRY,
  MODIFY_Y_ENTRY,
  MODIFY_Z_ENTRY
endenum

enum Buttons
  BACKBUTTON := 2000, // Back-Button
  MODIFY_MARKEDIT,
  MODIFY_START := 3000,
  MODIFY_Y_UP := 3005, // ModifyItem-Buttons
  MODIFY_Y_DOWN,
  MODIFY_X_UP,
  MODIFY_X_DOWN,
  MODIFY_XY_MM,
  MODIFY_XY_MP,
  MODIFY_XY_PM,
  MODIFY_XY_PP,
  MODIFY_Z_UP,
  MODIFY_Z_DOWN,
  MODIFY_DESTROY,
  MODIFY_COLOR,
  MODIFY_DUPE,
  MODIFY_X,
  MODIFY_Y,
  MODIFY_Z,
  MARK_SHOW,
  MARK_HIDE,
  MARK_EDIT
endenum

enum dataPositionsAngaben
  COLORDATAPOS := 7,
  ZSTARTPOS := 15,
  ZENDPOS := 16,
  XKOORDSPOS := 8,
  YKOORDSPOS := 9,
  ZKOORDSPOS := 10,
  XENTRY := 12,
  YENTRY,
  ZENTRY
endenum

enum Ebenen
  ROOTLIST := 0, // plane definition
  FIRSTLIST,
  SECONDLIST,
  THIRDLIST,
  FOURTHLIST,
  FIFTHLIST,
  ITEMLIST,
  ITEMLISTDUMMY
endenum

enum Cprops
  CPROP_INIT := "bautoolinit", // CProps to find the items
  CPROP_ITEMS := "bautoolitems",
  CPROP_COLOR := "bautoolorigcol" // Original color for markedit
endenum

const MENUSTART := 4000; // Start value of the lists / item buttons

const MAXBUTTON := 7; // Max Buttons in the NavBar
const MAXLINEITEM := 4; // How many items side by side in single create

const MAXAREASIZE := 50;

const ITEMMOVEFLAGS := MOVEOBJECT_FORCELOCATION + MOVEITEM_IGNOREMOVABLE;

// Load everything you need
var cfgrandom := ReadConfigFile( "bautoolrandom" );
var cfgeinzel := ReadConfigFile( "bautooleinzel" );
var cfgset := ReadConfigFile( "bautoolset" );
var datafile := DFOpenDataFile( "bautoolcmd", DF_CREATE, DF_KEYTYPE_STRING );
var dataelementMenu := datafile.FindElement( "menu" );
var dataelementModify := datafile.FindElement( "modify" );
var dataelementElement := datafile.FindElement( "elemente" );
var dataelementMark := datafile.FindElement( "modifymark" );
var layoutmodify := dataelementModify.getprop( "LayoutMenu" );
var datamodify := dataelementModify.getprop( "DataMenu" );
var layoutmodify_M := dataelementModify.getprop( "LayoutMenuManual" );
var datamodify_M := dataelementModify.getprop( "DataMenuManual" );
var layoutmark := dataelementMark.getprop( "LayoutMenuMark" );
var datamark := dataelementMark.getprop( "DataMenuMark" );
var datafileelement := dataelementElement.getprop( "dictionary" );

program bautool( who, param )
  if ( who[1] == "Init" ) // Generate datafile via script
    Init();
    return;
  endif

  if ( !GetGlobalProperty( "BauServer" ) )
    if ( who.cmdlevel < 3 )
      SendSysMessage( who, "You are not authorized to use this command!" );
      return;
    endif
  endif

  if ( Lower( param ) == "init" ) // Developer can start Init () manually
    if ( who.cmdlevel == 5 )
      cfgrandom := 0; // First remove Ref's so that Unload works properly
      cfgeinzel := 0;
      cfgset := 0;
      UnloadConfigFile( "bautoolmenues" );
      UnloadConfigFile( "bautooleinzel" );
      UnloadConfigFile( "bautoolrandom" );
      UnloadConfigFile( "bautoolset" );
      cfgrandom := ReadConfigFile( ":bautool:bautoolrandom" );
      cfgeinzel := ReadConfigFile( ":bautool:bautooleinzel" );
      cfgset := ReadConfigFile( ":bautool:bautoolset" );
      SendSysMessage( who, "Datafile building..." );
      Init();
      SendSysMessage( who, "Datafile completed" );
      return;
    endif
  endif

  if ( GetGlobalProperty( "bautoolinit" ) )
    SendSysMessage( who, "Datafile is still being generated, try again later." );
    return;
  endif

  ShowMenu( who );

endprogram

///////////////////////////////////
// ShowMenu - Actual main part
///////////////////////////////////

function ShowMenu( who ) // {{{
  var data := {}, layout := {}, nr, ebene;
  var ret, tile := {};
  var element := dictionary, back := 0;
  var firstebene, secondebene, thirdebene, fourthebene, fifthebene, itemebene;
  var color;

  element := datafileelement;

  // Now it can start
  ebene := FIRSTLIST;
  layout := dataelementMenu.getprop( "LayoutMenuBar" );
  data := dataelementMenu.getprop( "DataMenuBar" );

  ret := SendDialogGump( who, layout, data, 10, 50 );

  while ( who.connected )
    if ( ( ret.keys[ret.keys.size()] > MENUSTART ) || ( back ) )
      if ( back ) // Simulated buttone printing
        nr := back;
        back := 0;
      else
        nr := ret.keys[ret.keys.size()] - MENUSTART;
      endif
      case ( ebene ) // In which display level I am, create a suitable data list
        ROOTLIST:
          ebene := FIRSTLIST;
          layout := dataelementMenu.getprop( "LayoutMenuBar" );
          data := dataelementMenu.getprop( "DataMenuBar" );

        FIRSTLIST:
          ebene := SECONDLIST;
          if ( TypeOfInt( nr ) == OT_STRING )
            firstebene := nr;
          else
            firstebene := element.keys()[nr];
          endif
          layout := dataelementMenu.getprop( "LayoutMain_" + firstebene );
          data := dataelementMenu.getprop( "DataMain_" + firstebene );

        SECONDLIST:
          ebene := THIRDLIST;
          if ( TypeOfInt( element[firstebene] ) <> OT_DICTIONARY )
            secondebene := nr;
            tile := BuildItems( layout, data, element[firstebene][nr], firstebene );
          else
            if ( TypeOfInt( nr ) == OT_STRING )
              secondebene := nr;
            else
              secondebene := element[firstebene].keys()[nr];
            endif
            layout := dataelementMenu.getprop( "LayoutSub_" + firstebene + "_" + secondebene );
            data := dataelementMenu.getprop( "DataSub_" + firstebene + "_" + secondebene );
          endif

        THIRDLIST:
          ebene := FOURTHLIST;
          if ( TypeOfInt( element[firstebene][secondebene] ) <> OT_DICTIONARY )
            thirdebene := nr;
            tile := BuildItems( layout, data, element[firstebene][secondebene][nr], firstebene, secondebene );
          else
            if ( TypeOfInt( nr ) == OT_STRING )
              thirdebene := nr;
            else
              thirdebene := element[firstebene][secondebene].keys()[nr];
            endif
            layout := dataelementMenu.getprop( "LayoutSub_" + firstebene + "_" + secondebene + "_" + thirdebene );
            data := dataelementMenu.getprop( "DataSub_" + firstebene + "_" + secondebene + "_" + thirdebene );
          endif

        FOURTHLIST:
          ebene := FIFTHLIST;
          if ( TypeOfInt( element[firstebene][secondebene][thirdebene] ) <> OT_DICTIONARY )
            fourthebene := nr;
            tile := BuildItems( layout, data, element[firstebene][secondebene][thirdebene][nr], firstebene, secondebene, thirdebene );
          else
            ebene := FIFTHLIST;
            if ( TypeOfInt( nr ) == OT_STRING )
              fourthebene := nr;
            else
              fourthebene := element[firstebene][secondebene][thirdebene].keys()[nr];
            endif
            layout := dataelementMenu.getprop( "LayoutSub_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene );
            data := dataelementMenu.getprop( "DataSub_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene );
          endif

        FIFTHLIST:
          ebene := ITEMLIST;
          if ( TypeOfInt( element[firstebene][secondebene][thirdebene][fourthebene] ) <> OT_DICTIONARY )
            fifthebene := nr;
            tile := BuildItems( layout, data, element[firstebene][secondebene][thirdebene][fourthebene][nr], firstebene, secondebene, thirdebene, fourthebene );
          else
            ebene := ITEMLIST;
            if ( TypeOfInt( nr ) == OT_STRING )
              fifthebene := nr;
            else
              fifthebene := element[firstebene][secondebene][thirdebene][fourthebene].keys()[nr];
            endif
            layout := dataelementMenu.getprop( "LayoutSub_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene );
            data := dataelementMenu.getprop( "DataSub_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene );
          endif

        ITEMLIST:
        ITEMLISTDUMMY:
          ebene := ITEMLISTDUMMY;
          if ( TypeOfInt( nr ) == OT_STRING )
            itemebene := nr;
          else
            itemebene := element[firstebene][secondebene][thirdebene][fourthebene][fifthebene][nr];
          endif
          tile := BuildItems( layout, data, element[firstebene][secondebene][thirdebene][fourthebene][fifthebene][nr], firstebene, secondebene, thirdebene, fourthebene, fifthebene, itemebene[1] );

      endcase
      ret := SendDialogGump( who, layout, data, 10, 50 );

    elseif ( ret[BACKBUTTON] ) // Back
      ebene -= 2; // 2 because one was added beforehand
      if ( ebene < 0 )
        ebene := ROOTLIST;
      endif
      case ( ebene )
        ROOTLIST:
          back := 1;
        FIRSTLIST:
          back := firstebene;
        SECONDLIST:
          back := secondebene;
        THIRDLIST:
          back := thirdebene;
        FOURTHLIST:
          back := fourthebene;
        FIFTHLIST:
          back := fifthebene;
        ITEMLIST:
          back := itemebene;
        ITEMLISTDUMMY:
          back := itemebene;
      endcase

    // The Interesting Junk Item Creation
    elseif ( ret[ITEMCREATE] )
      ebene -= 1;
      back := nr; // So that there is no final lock loop with Create
      color := ret[ITEMCOLOR];
      color[1, 6] := "";
      color := CInt( color );
      case ( tile[1][2] )
        "Random":
          CreateRandom( who, ret, tile[2], tile[3], color, tile[1][1] );
        "Einzel":
          CreateEinzel( who, ret, tile[2], color );
        "Set":
          CreateSet( who, ret, tile[2], color );
        default:
          SendSysMessage( who, "error..." );
          return;
      endcase

    // Manual ItemModify
    elseif ( ret[ITEMMODIFYMANUAL] )
      ModifyItemsManual( who );
      back := 1;
      ebene := ROOTLIST;
    else
      return; // Winke
    endif
  endwhile
endfunction // }}}

///////////////////////////////////
// BuildItems - get layout / data +
// special stuff from Itemcreategumps
///////////////////////////////////

function BuildItems( byref layout, byref data, byref element, firstebene, secondebene := 0, thirdebene := 0, fourthebene := 0, fifthebene := 0, itemebene := 0 )
  // {{{
  var tiles := {};
  var tiles1 := {};
  var splittiles := {};

  if ( itemebene )
    layout := dataelementMenu.getprop( "LayoutItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene + "_" + itemebene );
    data := dataelementMenu.getprop( "DataItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene + "_" + itemebene );
  elseif ( fifthebene )
    layout := dataelementMenu.getprop( "LayoutItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene );
    data := dataelementMenu.getprop( "DataItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene );
  elseif ( fourthebene )
    layout := dataelementMenu.getprop( "LayoutItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + element[1] );
    data := dataelementMenu.getprop( "DataItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + element[1] );
  elseif ( thirdebene )
    layout := dataelementMenu.getprop( "LayoutItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + element[1] );
    data := dataelementMenu.getprop( "DataItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + element[1] );
  elseif ( secondebene )
    layout := dataelementMenu.getprop( "LayoutItem_" + firstebene + "_" + secondebene + "_" + element[1] );
    data := dataelementMenu.getprop( "DataItem_" + firstebene + "_" + secondebene + "_" + element[1] );
  elseif ( firstebene )
    layout := dataelementMenu.getprop( "LayoutItem_" + firstebene + "_" + element[1] );
    data := dataelementMenu.getprop( "DataItem_" + firstebene + "_" + element[1] );
  endif

  // Build an array of items
  case ( element[2] )
    "Random":
      foreach tile in ( GetConfigStringArray( cfgrandom[element[1]], "tile" ) )
        splittiles := SplitWords( tile );
        tiles.append( splittiles[1] );
        if ( splittiles[2] )
          tiles1.append( splittiles[2] );
        endif
      endforeach

    "Einzel":
      foreach tile in ( GetConfigStringArray( cfgeinzel[element[1]], "tile" ) )
        if ( !tiles )
          tiles := { tile };
        else
          tiles.append( tile );
        endif
      endforeach

    "Set":
      tiles := element[1];

  endcase
  return ( { element, tiles, tiles1 } );
endfunction // }}}

///////////////////////////////////
// CreateRandom - ...
///////////////////////////////////

function CreateRandom( who, byref ret, byref tiles, byref tiles1, byref color, byref element )
  // {{{
  var tar1, tar2, item, x, y, z, Tarx, Tary, Tarx2, Tary2, itemdef, items := {}, itemserials := {};

  SendSysMessage( who, "Target first corner" );
  tar1 := TargetCoordinates( who );
  if ( tar1 )
    SendSysMessage( who, "Target the second corner" );
    tar2 := TargetCoordinates( who );
    if ( tar2 )
      if ( ( tar1.item ) || ( tar2.item ) )
        if ( ( tar1.item.container ) || ( tar2.item.container ) )
          SendSysMessage( who, "cancellation. Item in Container targeted!" );
          return;
        endif
      endif
      if ( tar1.x >= tar2.x ) // Sorting the area
        Tarx := tar2.x;
        Tarx2 := tar1.x;
      else
        Tarx := tar1.x;
        Tarx2 := tar2.x;
      endif
      if ( tar1.y >= tar2.y )
        Tary := tar2.y;
        Tary2 := tar1.y;
      else
        Tary := tar1.y;
        Tary2 := tar2.y;
      endif
      if ( ( ( Tarx2 - Tarx ) > MAXAREASIZE ) || ( ( Tary2 - Tary ) > MAXAREASIZE ) )
        SendSysMessage( who, "Cancellation.  " + MAXAREASIZE + "x" + MAXAREASIZE + " Generate items!" );
        return;
      endif
      z := ret[ITEMPOS];
      z[1, 6] := "";
      z := CInt( z );
      // Begrenzte Ausdehnung?
      if ( GetConfigString( cfgrandom[element], "x" ) )
        Tarx2 := Tarx + CInt( GetConfigString( cfgrandom[element], "x" ) ) - 1;
      endif
      if ( GetConfigString( cfgrandom[element], "y" ) )
        Tary2 := Tary + CInt( GetConfigString( cfgrandom[element], "y" ) ) - 1;
      endif
      if ( ret[ITEMRAND] ) // Random items are to be generated
        for ( x := Tarx; x <= Tarx2; x += 1 )
          for ( y := Tary; y <= Tary2; y += 1 )
            if ( ( x == Tarx ) && ( y == Tary ) ) // NW corner
              itemdef := GetConfigString( cfgrandom[element], "nw" );
              if ( !itemdef )
                SendSysMessage( who, "NW corner is missing." );
              else
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create Error!  " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
              // Create second item
              itemdef := GetConfigString( cfgrandom[element], "nw1" );
              if ( ( itemdef ) && ( itemdef <> {} ) )
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! NW-Corner 2nd item" + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
            elseif ( ( x == Tarx2 ) && ( y == Tary ) ) // NE corner
              itemdef := GetConfigString( cfgrandom[element], "no" );
              if ( !itemdef )
                SendSysMessage( who, "NE corner missing." );
              else
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! NE-corner Item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
              // Create second item
              itemdef := GetConfigString( cfgrandom[element], "no1" );
              if ( ( itemdef ) && ( itemdef <> {} ) )
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! NE-Corner 2nd item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
            elseif ( ( x == Tarx2 ) && ( y == Tary2 ) ) // SE corner
              itemdef := GetConfigString( cfgrandom[element], "so" );
              if ( !itemdef )
                SendSysMessage( who, "SE-Corner is missing." );
              else
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! SO-Ecke Item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
              // Create second item
              itemdef := GetConfigString( cfgrandom[element], "so1" );
              if ( ( itemdef ) && ( itemdef <> {} ) )
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! SE-Corner 2nd item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
            elseif ( ( x == Tarx ) && ( y == Tary2 ) ) // SW corner
              itemdef := GetConfigString( cfgrandom[element], "sw" );
              if ( !itemdef )
                SendSysMessage( who, "SW-Corner is missing." );
              else
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! SW-corner Item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
              // Create second item
              itemdef := GetConfigString( cfgrandom[element], "sw1" );
              if ( ( itemdef ) && ( itemdef <> {} ) )
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! SW-Corner 2nd item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
            elseif ( y == Tary ) // N page
              itemdef := GetConfigString( cfgrandom[element], "n" );
              if ( !itemdef )
                SendSysMessage( who, "N-Page is missing." );
              else
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! N-Item page " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
              // Create second item
              itemdef := GetConfigString( cfgrandom[element], "n1" );
              if ( ( itemdef ) && ( itemdef <> {} ) )
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! N-Page 2nd item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
            elseif ( x == Tarx2 ) // E side
              itemdef := GetConfigString( cfgrandom[element], "o" );
              if ( !itemdef )
                SendSysMessage( who, "E-side is missing." );
              else
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! E-side item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
              // Create second item
              itemdef := GetConfigString( cfgrandom[element], "o1" );
              if ( ( itemdef ) && ( itemdef <> {} ) )
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! E-side 2nd item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
            elseif ( y == Tary2 ) // S side
              itemdef := GetConfigString( cfgrandom[element], "s" );
              if ( !itemdef )
                SendSysMessage( who, "S side is missing." );
              else
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! S-Item page " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
              // Create second item
              itemdef := GetConfigString( cfgrandom[element], "s1" );
              if ( ( itemdef ) && ( itemdef <> {} ) )
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! S-side 2nd item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
            elseif ( x == Tarx ) // W page
              itemdef := GetConfigString( cfgrandom[element], "w" );
              if ( !itemdef )
                SendSysMessage( who, "W-Page is missing." );
              else
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! W side item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
              // Create second item
              itemdef := GetConfigString( cfgrandom[element], "w1" );
              if ( ( itemdef ) && ( itemdef <> {} ) )
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! W-Page 2nd item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
            else // centerpiece
              itemdef := ChooseRandom( tiles );
              if ( !itemdef )
                SendSysMessage( who, "Middle piece is missing." );
              else
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! Midsection item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
              // Create second item
              itemdef := tiles1.randomentry();
              if ( ( itemdef ) && ( itemdef <> {} ) )
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! Middle part 2nd item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
            endif
            SleepMS( 5 );
          endfor
        endfor
      else // Boring version without a border
        for ( x := Tarx; x <= Tarx2; x += 1 )
          for ( y := Tary; y <= Tary2; y += 1 )
            itemdef := ChooseRandom( tiles );
            if ( !itemdef )
              SendSysMessage( who, "Middle piece is missing." );
            else
              itemdef := SplitWords( itemdef, "," );
              item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm );
              if ( item )
                item.color := color;
                item.movable := 0;
                items.append( item );
              else
                SendSysMessage( who, "Create error! Item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext );
              endif
            endif
            // Create second item
            itemdef := tiles1.randomentry();
            if ( ( itemdef ) && ( itemdef <> {} ) )
              itemdef := SplitWords( itemdef, "," );
              item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z, CInt( itemdef[1] ), 1, who.realm );
              if ( item )
                item.color := color;
                item.movable := 0;
                items.append( item );
              else
                SendSysMessage( who, "Create error! 2nd Item " + x + " " + y + " " + ( tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] ) + " ErrorText: " + item.errortext );
              endif
            endif
            SleepMS( 5 );
          endfor
        endfor
      endif
      // Save item series
      foreach item in items
        item.setprop( CPROP_INIT, items[1].serial );
        SleepMS( 2 );
      endforeach
      foreach item in items
        itemserials.append( item.serial );
        SleepMS( 2 );
      endforeach
      items[1].setprop( CPROP_ITEMS, itemserials );

      if ( ret[ITEMMODIFY] ) // Change position
        if ( !ModifyItems( who, items ) )
          return;
        endif
      endif
    else
      SendSysMessage( who, "Abort" );
    endif
  else
    SendSysMessage( who, "Abort" );
  endif
endfunction // }}}

///////////////////////////////////
// Create singles - ...
///////////////////////////////////

function CreateEinzel( who, byref ret, byref tiles, byref color ) // {{{
  var z, itemdef := {}, iTarget, item, items := {}, itemserials := {};

  if ( !tiles[ret.keys[2]] )
    SendSysMessage( who, "No item selected" );
    return;
  endif
  SendSysMessage( who, "Target position" );
  z := ret[ITEMPOS];
  z[1, 6] := "";
  z := CInt( z );
  itemdef[1] := CInt( SplitWords( tiles[ret.keys[2]], "," )[1] ); // Objtype
  itemdef[2] := CInt( SplitWords( tiles[ret.keys[2]], "," )[2] ); // Feste z-Koords
  iTarget := TargetCoordinates( who );
  if ( iTarget.item )
    if ( iTarget.item.container )
      SendSysMessage( who, "cancellation. Item in Container targeted!" );
      return;
    endif
  endif
  while ( iTarget ) // Endless to ESC
    item := CreateItemAtLocation( iTarget.x, iTarget.y, iTarget.z + itemdef[2] + z, itemdef[1], 1, who.realm );
    if ( item )
      item.color := color;
      item.movable := 0;
      // Save item series
      if ( !ret[ITEMMMULTICREATE] )
        item.setprop( CPROP_INIT, item.serial );
        item.setprop( CPROP_ITEMS, { item.serial } );
        if ( ret[ITEMMODIFY] ) // Change position
          if ( !ModifyItems( who, item ) )
            SendSysMessage( who, "Abort" );
            return;
          endif
        endif
      else
        items.append( item );
      endif
    else
      SendSysMessage( who, "Create error! Item " + iTarget.x + " " + iTarget.y + " " + ( iTarget.z + itemdef[2] + z ) + " " + Hex( tiles[ret.keys[2]] ) + " ErrorText: " + item.errortext );
    endif
    iTarget := TargetCoordinates( who );
  endwhile
  if ( ret[ITEMMMULTICREATE] )
    // Itemserials to save
    foreach item in items
      item.setprop( CPROP_INIT, items[1].serial );
    endforeach
    foreach item in items
      itemserials.append( item.serial );
    endforeach
    items[1].setprop( CPROP_ITEMS, itemserials );
    if ( ret[ITEMMODIFY] ) // Postion to change
      ModifyItems( who, items );
    endif
  endif
  SendSysMessage( who, "Abort" );
endfunction // }}}

///////////////////////////////////
// CreateSet - ...
///////////////////////////////////

function CreateSet( unused who, byref unused ret, byref unused set, byref unused color )
/* Var iTarget, items, itemserials:={}, wholeitems:={};
  Var z:=ret[ITEMPOS];
  z[1,6]:="";
  z:=CInt(z);

  iTarget:=TargetCoordinates(who);
  If (iTarget.item)
    If (iTarget.item.container)
      SendSysMessage(who,"cancellation. Item in Container targeted!");
      Return;
    EndIf
  EndIf
  While (iTarget)  // Endless to ESC
    iTarget.z:=iTarget.z+z;
    items:=MakeSet(iTarget, set, 1)[2];
    If (items)
      If (color)
        ForEach item in items
          item.color:=color;
          SleepMS(2);
        EndForEach
      EndIf
      If (!ret[ITEMMMULTICREATE])
        // Save item series
        itemserials:={};
        ForEach item in items
          item.setprop(CPROP_INIT,items[1].serial);
          SleepMS(2);
        EndForEach
        ForEach item in items
          itemserials.append(item.serial);
          SleepMS(2);
        EndForEach
        items[1].setprop(CPROP_ITEMS,itemserials);

        If (ret[ITEMMODIFY])  // Change position
          If (!ModifyItems(who,items))
            Return;
          EndIf
        EndIf
      Else
        ForEach item in items
          wholeitems.append(item);
          SleepMS(2);
        EndForEach
      EndIf
    Else
      SendSysMessage(who,"Something went wrong.");
      Return;
    EndIf
    iTarget:=TargetCoordinates(who);
  EndWhile
  If (ret[ITEMMMULTICREATE])
    // Save item series
    ForEach item in wholeitems
      item.setprop(CPROP_INIT,wholeitems[1].serial);
      SleepMS(2);
    EndForEach
    ForEach item in wholeitems
      itemserials.append(item.serial);
      SleepMS(2);
    EndForEach
    wholeitems[1].setprop(CPROP_ITEMS,itemserials);
    If (ret[ITEMMODIFY])  // Change position
      ModifyItems(who,items);
    EndIf
  EndIf
  SendSysMessage(who, "Abort"); */
endfunction

///////////////////////////////////
// ModifyItemsManual - ...
///////////////////////////////////

function ModifyItemsManual( who ) // {{{
  var retmodify, tar, inititem, items := {}, itemserials := {}, color, zstart, zend, temp, i, obj, tempitems := {};
  var tar1, tar2, x1, x2, y1, y2, breakflag;
  var dupe := {}, dupeitem, dupeserials := {};

  while ( who.connected )
    if ( items <> {} )
      datamodify_M[COLORDATAPOS] := items[1].color;
      datamodify_M[XKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>" + items[1].x + "</p></basefont>";
      datamodify_M[YKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>" + items[1].y + "</p></basefont>";
      datamodify_M[ZKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>" + items[1].z + "</p></basefont>";
      datamodify_M[XENTRY] := items[1].x;
      datamodify_M[YENTRY] := items[1].y;
      datamodify_M[ZENTRY] := items[1].z;
    else
      datamodify_M[COLORDATAPOS] := "0";
      datamodify_M[XKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>x</p></basefont>";
      datamodify_M[YKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>y</p></basefont>";
      datamodify_M[ZKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>z</p></basefont>";
      datamodify_M[XENTRY] := 0;
      datamodify_M[YENTRY] := 0;
      datamodify_M[ZENTRY] := 0;
    endif
    retmodify := SendDialogGump( who, layoutmodify_M, datamodify_M, 10, 50 );
    if ( retmodify[MODIFY_START] )
      if ( !retmodify[MODIFY_CUSTOM] ) // Search for .bautool items
        tar := Target( who, TGTOPT_NOCHECK_LOS );
        if ( tar )
          if ( ( !tar.getprop( CPROP_ITEMS ) ) && ( tar.getprop( CPROP_INIT ) ) )
            inititem := SystemFindObjectBySerial( tar.getprop( CPROP_INIT ) );
            if ( inititem )
              itemserials := inititem.getprop( CPROP_ITEMS );
              items := {};
              tempitems := {};
              foreach item in itemserials
                obj := SystemFindObjectBySerial( item );
                if ( obj )
                  if ( CInt( obj.getprop( CPROP_INIT ) ) == CInt( inititem.serial ) ) // it belongs to the same group
                    items.append( obj );
                    tempitems.append( obj.serial );
                  endif
                endif
                SleepMS( 5 );
              endforeach
              inititem.setprop( CPROP_ITEMS, tempitems ); // save filtered serials
              if ( ( !items ) || ( items == {} ) )
                SendSysMessage( who, "Items could not be found. " );
              else
                SendSysMessage( who, items.size() + " Items recognized." );
              endif
            else
              SendSysMessage( who, "Init item not found. " );
              items := RecoverInitItem( tar );
            // items:={};
            endif
          elseif ( tar.getprop( CPROP_ITEMS ) )
            itemserials := tar.getprop( CPROP_ITEMS );
            items := {};
            tempitems := {};
            foreach item in itemserials
              obj := SystemFindObjectBySerial( item );
              if ( obj )
                if ( CInt( obj.getprop( CPROP_INIT ) ) == CInt( tar.serial ) ) // it belongs to the same group
                  items.append( obj );
                  tempitems.append( obj.serial );
                endif
              endif
              SleepMS( 5 );
            endforeach
            tar.setprop( CPROP_ITEMS, tempitems ); // save filtered serials
            SendSysMessage( who, items.size() + " Items recognized." );
          else
            SendSysMessage( who, "Invalid Item selected." );
          endif
        else
          SendSysMessage( who, "Abort" );
          items := {};
        endif
      else // Search for any items
        zstart := retmodify[MODIFY_Z_START];
        zstart[1, 6] := "";
        zstart := CInt( zstart );
        zend := retmodify[MODIFY_Z_END];
        zend[1, 6] := "";
        zend := CInt( zend );
        datamodify_M[ZSTARTPOS] := zstart;
        datamodify_M[ZENDPOS] := zend;
        SendSysMessage( who, "Target the first corner of the area" );
        tar1 := TargetCoordinates( who );
        if ( tar1 )
          SendSysMessage( who, "Target the second corner of the area" );
          tar2 := TargetCoordinates( who );
          if ( tar2 )
            if ( tar1.x > tar2.x ) // Sorting the area
              x1 := tar2.x;
              x2 := tar1.x;
            else
              x1 := tar1.x;
              x2 := tar2.x;
            endif
            if ( tar1.y > tar2.y )
              y1 := tar2.y;
              y2 := tar1.y;
            else
              y1 := tar1.y;
              y2 := tar2.y;
            endif
            items := {};
            foreach item in ListObjectsInBox( x1, y1, zstart, x2, y2, zend, tar2.realm )
              if ( item.isA( POLCLASS_ITEM ) )
                if ( !item.invisible ) // Don't take invisible stuff like spawn runes
                  items.append( item );
                endif
              endif
              SleepMS( 5 );
            endforeach
            if ( items <> {} )
              SendSysMessage( who, items.size() + " Items recognized." );
              if ( retmodify[MODIFY_MARK] )
                // Save item series
                itemserials := {};
                foreach item in items
                  itemserials.append( item.serial );
                  SleepMS( 2 );
                endforeach
                SendSysMessage( who, "Choose the original item." );
                breakflag := 0;
                while ( who.connected )
                  tar := Target( who, TGTOPT_NOCHECK_LOS );
                  if ( tar )
                    i := tar.serial in itemserials;
                    if ( i ) // Move the selected item to the first position
                      temp := itemserials[1];
                      itemserials[i] := temp;
                      itemserials[1] := tar.serial;
                      foreach item in items
                        item.setprop( CPROP_INIT, tar.serial );
                        item.eraseprop( CPROP_ITEMS );
                        SleepMS( 2 );
                      endforeach
                      tar.setprop( CPROP_ITEMS, itemserials );
                      break;
                    else
                      SendSysMessage( who, "Item is not among those recognized!" );
                    endif
                  else
                    SendSysMessage( who, "Abort" );
                    breakflag := 1;
                    break;
                  endif
                endwhile
                items := {};
                if ( !breakflag )
                  foreach item in itemserials // Reordering and final check
                    obj := SystemFindObjectBySerial( item );
                    if ( obj )
                      items.append( obj );
                    endif
                    SleepMS( 5 );
                  endforeach
                  SendSysMessage( who, ".. and branded." );
                endif
              endif
            else
              SendSysMessage( who, "No items recognized." );
            endif
          else
            SendSysMessage( who, "Abort" );
            items := {};
          endif
        else
          SendSysMessage( who, "Abort" );
          items := {};
        endif
      endif
    else
      if ( retmodify.keys[retmodify.keys.size()] > MODIFY_START )
        if ( items <> {} )
          if ( retmodify[MODIFY_Y_UP] )
            foreach item in items
              MoveObjectToLocation( item, item.x, item.y + 1, item.z, item.realm, ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_Y_DOWN] )
            foreach item in items
              MoveObjectToLocation( item, item.x, item.y - 1, item.z, item.realm, ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_X_UP] )
            foreach item in items
              MoveObjectToLocation( item, item.x + 1, item.y, item.z, item.realm, ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_X_DOWN] )
            foreach item in items
              MoveObjectToLocation( item, item.x - 1, item.y, item.z, item.realm, ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_XY_MM] )
            foreach item in items
              MoveObjectToLocation( item, item.x - 1, item.y - 1, item.z, item.realm, ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_XY_PM] )
            foreach item in items
              MoveObjectToLocation( item, item.x + 1, item.y - 1, item.z, item.realm, ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_XY_MP] )
            foreach item in items
              MoveObjectToLocation( item, item.x - 1, item.y + 1, item.z, item.realm, ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_XY_PP] )
            foreach item in items
              MoveObjectToLocation( item, item.x + 1, item.y + 1, item.z, item.realm, ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_Z_UP] )
            foreach item in items
              MoveObjectToLocation( item, item.x, item.y, item.z + 1, item.realm, ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_Z_DOWN] )
            foreach item in items
              MoveObjectToLocation( item, item.x, item.y, item.z - 1, item.realm, ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_DESTROY] )
            foreach item in items
              DestroyItem( item );
              SleepMS( 2 );
            endforeach
            items := {};
          elseif ( retmodify[MODIFY_COLOR] )
            color := retmodify[ITEMCOLOR];
            color[1, 6] := "";
            color := CInt( color );
            foreach item in items
              item.color := color;
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_DUPE] )
            dupe := {};
            dupeserials := {};
            foreach item in items
              dupeitem := CreateItemCopyAtLocation( item.x, item.y, item.z, item, item.realm );
              if ( dupeitem )
                dupe.append( dupeitem );
                dupeserials.append( dupeitem.serial );
              endif
              SleepMS( 2 );
            endforeach
            foreach item in dupe
              item.setprop( CPROP_INIT, dupeserials[1] );
              SleepMS( 2 );
            endforeach
            dupe[1].setprop( CPROP_ITEMS, dupeserials );
            SendSysMessage( who, dupe.size() + " Items successfully duplicated." );
            items := dupe; // Continue working with a copy
          elseif ( retmodify[MODIFY_X] )
            temp := retmodify[MODIFY_X_ENTRY];
            temp[1, 6] := "";
            temp := CInt( temp ) - items[1].x;
            foreach item in items
              MoveObjectToLocation( item, item.x + temp, item.y, item.z, item.realm, ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_Y] )
            temp := retmodify[MODIFY_Y_ENTRY];
            temp[1, 6] := "";
            temp := CInt( temp ) - items[1].y;
            foreach item in items
              MoveObjectToLocation( item, item.x, item.y + temp, item.z, item.realm, ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_Z] )
            temp := retmodify[MODIFY_Z_ENTRY];
            temp[1, 6] := "";
            temp := CInt( temp ) - items[1].z;
            foreach item in items
              MoveObjectToLocation( item, item.x, item.y, item.z + temp, item.realm, ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          endif
        else
          SendSysMessage( who, "No items selected." );
        endif
      elseif ( retmodify[MODIFY_MARKEDIT] )
        MarkEdit( who );
      else // Gump closed
        SendSysMessage( who, "Abort" );
        break;
      endif
    endif
  endwhile
endfunction // }}}

///////////////////////////////////
// MarkEdit - Possibility to change the groups
///////////////////////////////////

function MarkEdit( who ) // {{{
  var ret, tar1, tar2, x1, x2, y1, y2, items := {}, itemref, inititem, itemserials, tempitems, obj, i;

  while ( who.connected )
    ret := SendDialogGump( who, layoutmark, datamark, 10, 50 );

    if ( ret[MARK_SHOW] )
      SendSysMessage( who, "Target the first corner of the area" );
      tar1 := TargetCoordinates( who );
      if ( tar1 )
        SendSysMessage( who, "Target the second corner of the area" );
        tar2 := TargetCoordinates( who );
        if ( tar2 )
          if ( tar1.x > tar2.x ) // Sorting the area
            x1 := tar2.x;
            x2 := tar1.x;
          else
            x1 := tar1.x;
            x2 := tar2.x;
          endif
          if ( tar1.y > tar2.y )
            y1 := tar2.y;
            y2 := tar1.y;
          else
            y1 := tar1.y;
            y2 := tar2.y;
          endif
          items := {};
          foreach item in ListObjectsInBox( x1, y1, -127, x2, y2, 128, tar2.realm )
            // Items besorgen
            if ( item.isA( POLCLASS_ITEM ) )
              if ( item.getprop( CPROP_ITEMS ) )
                items.append( item );
              endif
            endif
            SleepMS( 5 );
          endforeach
          if ( items <> {} )
            foreach item in items // Coloring by groups
              foreach slaveitem in ( item.getprop( CPROP_ITEMS ) )
                itemref := SystemFindObjectBySerial( slaveitem );
                if ( itemref )
                  if ( itemref.getprop( CPROP_COLOR ).errortext )
                    itemref.setprop( CPROP_COLOR, itemref.color );
                  endif
                  itemref.color := _item_iter + 6;
                endif
                SleepMS( 5 );
              endforeach
            endforeach
          endif
        endif
      endif

    elseif ( ret[MARK_HIDE] )
      SendSysMessage( who, "Target the first corner of the area" );
      tar1 := TargetCoordinates( who );
      if ( tar1 )
        SendSysMessage( who, "Target the second corner of the area" );
        tar2 := TargetCoordinates( who );
        if ( tar2 )
          if ( tar1.x > tar2.x ) // Sorting the area
            x1 := tar2.x;
            x2 := tar1.x;
          else
            x1 := tar1.x;
            x2 := tar2.x;
          endif
          if ( tar1.y > tar2.y )
            y1 := tar2.y;
            y2 := tar1.y;
          else
            y1 := tar1.y;
            y2 := tar2.y;
          endif
          items := {};
          foreach item in ListObjectsInBox( x1, y1, -127, x2, y2, 128, tar2.realm )
            // Items besorgen
            if ( item.isA( POLCLASS_ITEM ) )
              if ( item.getprop( CPROP_ITEMS ) )
                items.append( item );
              endif
            endif
            SleepMS( 5 );
          endforeach
          if ( items <> {} )
            foreach item in items // Coloring by groups
              foreach slaveitem in ( item.getprop( CPROP_ITEMS ) )
                itemref := SystemFindObjectBySerial( slaveitem );
                if ( itemref )
                  if ( itemref.getprop( CPROP_COLOR ).errortext )
                    itemref.setprop( CPROP_COLOR, itemref.color );
                  endif
                  itemref.color := _item_iter + 6;
                endif
                SleepMS( 5 );
              endforeach
            endforeach
          endif

          foreach item in ListObjectsInBox( x1, y1, -128, x2, y2, 127, tar2.realm )
            // Freset work
            if ( item.isA( POLCLASS_ITEM ) )
              if ( ( item.getprop( CPROP_ITEMS ) ) && ( !item.getprop( CPROP_COLOR ).errortext ) )
                foreach slaveitem in ( item.getprop( CPROP_ITEMS ) )
                  itemref := SystemFindObjectBySerial( slaveitem );
                  if ( itemref )
                    if ( !itemref.getprop( CPROP_COLOR ).errortext )
                      itemref.color := CInt( item.getprop( CPROP_COLOR ) );
                      itemref.eraseprop( CPROP_COLOR );
                    endif
                  endif
                  SleepMS( 5 );
                endforeach
              endif
            endif
            SleepMS( 5 );
          endforeach
        endif
      endif

    elseif ( ret[MARK_EDIT] )
      SendSysMessage( who, "Selects the item group." );
      tar1 := Target( who, TGTOPT_NOCHECK_LOS );
      items := {};
      tempitems := {};
      if ( ( !tar1.getprop( CPROP_ITEMS ) ) && ( tar1.getprop( CPROP_INIT ) ) )
        inititem := SystemFindObjectBySerial( tar1.getprop( CPROP_INIT ) );
        if ( inititem )
          itemserials := inititem.getprop( CPROP_ITEMS );
          foreach item in itemserials
            obj := SystemFindObjectBySerial( item );
            if ( obj )
              if ( ( CInt( obj.getprop( CPROP_INIT ) ) == CInt( inititem.serial ) ) && ( !( obj.serial in tempitems ) ) ) // it belongs to the same group
                items.append( obj );
                tempitems.append( obj.serial );
                if ( obj.getprop( CPROP_COLOR ).errortext )
                  obj.setprop( CPROP_COLOR, obj.color );
                endif
                obj.color := 1281;
              endif
            endif
            SleepMS( 5 );
          endforeach
          inititem.setprop( CPROP_ITEMS, tempitems ); // save filtered serials
          if ( ( !items ) || ( items == {} ) )
            SendSysMessage( who, "Items could not be found. " );
          else
            SendSysMessage( who, items.size() + " Items recognized." );
          endif
        else
          SendSysMessage( who, "Init item not found. " );
          items := RecoverInitItem( tar1 );
        // items:={};
        endif
      elseif ( tar1.getprop( CPROP_ITEMS ) )
        itemserials := tar1.getprop( CPROP_ITEMS );
        foreach item in itemserials
          obj := SystemFindObjectBySerial( item );
          if ( obj )
            if ( CInt( obj.getprop( CPROP_INIT ) ) == CInt( tar1.serial ) ) // it belongs to the same group
              items.append( obj );
              tempitems.append( obj.serial );
              if ( obj.getprop( CPROP_COLOR ).errortext )
                obj.setprop( CPROP_COLOR, obj.color );
              endif
              obj.color := 1281;
            endif
          endif
          SleepMS( 5 );
        endforeach
        tar1.setprop( CPROP_ITEMS, tempitems ); // save filtered serials
        SendSysMessage( who, items.size() + " Items recognized." );
      else
        SendSysMessage( who, "No items recognized." );
      endif
      if ( items <> {} )
        while ( who.connected )
          SendSysMessage( who, "Selects the item to be added / removed." );
          tar1 := Target( who, TGTOPT_NOCHECK_LOS );
          if ( ( !tar1 ) && ( !tar1.isA( POLCLASS_ITEM ) ) )
            SendSysMessage( who, "Abort" );
            break;
          endif
          i := tar1.serial in tempitems;
          if ( i ) // Remove from group
            tempitems.erase( i );
            items.erase( i );
            tar1.eraseprop( CPROP_INIT );
            tar1.eraseprop( CPROP_ITEMS );
            if ( !tar1.getprop( CPROP_COLOR ).errortext )
              tar1.color := CInt( tar1.getprop( CPROP_COLOR ) );
              tar1.eraseprop( CPROP_COLOR );
            endif
          else // Add
            if ( tar1.getprop( CPROP_COLOR ).errortext )
              tar1.setprop( CPROP_COLOR, tar1.color );
            endif
            tar1.color := items[1].color;
            tempitems.append( tar1.serial );
            items.append( tar1 );
          endif
        endwhile

        foreach item in items
          item.setprop( CPROP_INIT, items[1].serial );
          item.eraseprop( CPROP_ITEMS );
        endforeach
        items[1].setprop( CPROP_ITEMS, tempitems );
        foreach item in items
          if ( !item.getprop( CPROP_COLOR ).errortext )
            item.color := CInt( item.getprop( CPROP_COLOR ) );
            item.eraseprop( CPROP_COLOR );
          endif
          SleepMS( 1 );
        endforeach
      endif
    else
      if ( x1 ) // If something has been done, reset the color
        foreach item in ListObjectsInBox( x1, y1, -128, x2, y2, 127, tar2.realm )
          // Freset work
          if ( item.isA( POLCLASS_ITEM ) )
            if ( ( item.getprop( CPROP_ITEMS ) ) && ( !item.getprop( CPROP_COLOR ).errortext ) )
              foreach slaveitem in ( item.getprop( CPROP_ITEMS ) )
                itemref := SystemFindObjectBySerial( slaveitem );
                if ( itemref )
                  if ( !itemref.getprop( CPROP_COLOR ).errortext )
                    itemref.color := CInt( item.getprop( CPROP_COLOR ) );
                    itemref.eraseprop( CPROP_COLOR );
                  endif
                endif
                SleepMS( 5 );
              endforeach
            endif
          endif
          SleepMS( 5 );
        endforeach
      endif
      SendSysMessage( who, "Abort" );
      return;
    endif
  endwhile
endfunction // }}}

///////////////////////////////////
// ModifyItems - Position / color change after creation
///////////////////////////////////

function ModifyItems( who, byref items ) // {{{
  var retmodify, color, temp, dupe := {}, dupeitem, dupeserials := {};

  if ( TypeOfInt( items ) != OT_ARRAY )
    temp := items;
    items := {};
    items.append( temp );
  endif
  while ( who.connected )
    datamodify[COLORDATAPOS] := items[1].color;
    datamodify[XKOORDSPOS] := "<basefont color=" + HTML_WHITE + "><p align=right>" + items[1].x + "</p></basefont>";
    datamodify[YKOORDSPOS] := "<basefont color=" + HTML_WHITE + "><p align=right>" + items[1].y + "</p></basefont>";
    datamodify[ZKOORDSPOS] := "<basefont color=" + HTML_WHITE + "><p align=right>" + items[1].z + "</p></basefont>";
    datamodify[XENTRY] := items[1].x;
    datamodify[YENTRY] := items[1].y;
    datamodify[ZENTRY] := items[1].z;
    retmodify := SendDialogGump( who, layoutmodify, datamodify, 10, 50 );
    if ( retmodify[MODIFY_Y_UP] )
      foreach item in items
        MoveObjectToLocation( item, item.x, item.y + 1, item.z, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_Y_DOWN] )
      foreach item in items
        MoveObjectToLocation( item, item.x, item.y - 1, item.z, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_X_UP] )
      foreach item in items
        MoveObjectToLocation( item, item.x + 1, item.y, item.z, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_X_DOWN] )
      foreach item in items
        MoveObjectToLocation( item, item.x - 1, item.y, item.z, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_XY_MM] )
      foreach item in items
        MoveObjectToLocation( item, item.x - 1, item.y - 1, item.z, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_XY_PM] )
      foreach item in items
        MoveObjectToLocation( item, item.x + 1, item.y - 1, item.z, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_XY_MP] )
      foreach item in items
        MoveObjectToLocation( item, item.x - 1, item.y + 1, item.z, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_XY_PP] )
      foreach item in items
        MoveObjectToLocation( item, item.x + 1, item.y + 1, item.z, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_Z_UP] )
      foreach item in items
        MoveObjectToLocation( item, item.x, item.y, item.z + 1, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_Z_DOWN] )
      foreach item in items
        MoveObjectToLocation( item, item.x, item.y, item.z - 1, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_DESTROY] )
      foreach item in items
        DestroyItem( item );
        SleepMS( 2 );
      endforeach
      break;
    elseif ( retmodify[MODIFY_COLOR] )
      color := retmodify[ITEMCOLOR];
      color[1, 6] := "";
      color := CInt( color );
      foreach item in items
        item.color := color;
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_DUPE] )
      dupe := {};
      dupeserials := {};
      foreach item in items
        dupeitem := CreateItemCopyAtLocation( item.x, item.y, item.z, item, item.realm );
        if ( dupeitem )
          dupe.append( dupeitem );
          dupeserials.append( dupeitem.serial );
        endif
        SleepMS( 2 );
      endforeach
      foreach item in dupe
        item.setprop( CPROP_INIT, dupeserials[1] );
        SleepMS( 2 );
      endforeach
      dupe[1].setprop( CPROP_ITEMS, dupeserials );
      SendSysMessage( who, dupe.size() + " Items successfully duplicated." );
      items := dupe; // Edit copy further
    elseif ( retmodify[MODIFY_X] )
      temp := retmodify[MODIFY_X_ENTRY];
      temp[1, 6] := "";
      temp := CInt( temp ) - items[1].x;
      foreach item in items
        MoveObjectToLocation( item, item.x + temp, item.y, item.z, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_Y] )
      temp := retmodify[MODIFY_Y_ENTRY];
      temp[1, 6] := "";
      temp := CInt( temp ) - items[1].y;
      foreach item in items
        MoveObjectToLocation( item, item.x, item.y + temp, item.z, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_Z] )
      temp := retmodify[MODIFY_Z_ENTRY];
      temp[1, 6] := "";
      temp := CInt( temp ) - items[1].z;
      foreach item in items
        MoveObjectToLocation( item, item.x, item.y, item.z + temp, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[BACKBUTTON] )
      break;
    else
      return ( 0 ); // Abbruch
    endif
  endwhile
  return ( 1 );
endfunction // }}}

///////////////////////////////////
// ChooseRandom - Random determination of the items
///////////////////////////////////

function ChooseRandom( byref liste ) // {{{
  var verteilung := 0, i;
  var rand := RandomInt( 100 ) + 1;
  if ( Find( liste[1], "%", 1 ) ) // Distribution according to Cfg
    for ( i := 1; i <= liste.size(); i += 1 )
      verteilung += CInt( SplitWords( liste[i], "%" )[2] );
      if ( rand <= verteilung )
        return ( SplitWords( liste[i], "%" )[1] );
      endif
    endfor
  else // Gleichverteilt
    verteilung := CInt( 100 / liste.size() );
    for ( i := 1; i <= liste.size(); i += 1 )
      if ( rand <= ( i * verteilung ) ) // within the probability?
        return ( liste[i] ); // Shoo Shoo
      endif
    endfor
  endif
  return ( liste.randomentry() ); // well then just like that
endfunction // }}}

///////////////////////////////////
// MenuBar - Creates the NavBar
///////////////////////////////////

function MenuBar( byref layout, byref data, byref datadict ) // {{{
  var i, page := 1, y := 66, nextpagebreak := MAXBUTTON + 1;
  if ( TypeOfInt( datadict ) == OT_DICTIONARY ) // Data in dictionary or array
    for ( i := 1; i <= datadict.keys().size(); i += 1 )
      if ( i == nextpagebreak )
        nextpagebreak += MAXBUTTON;
        y := 66;
        page += 1;
        layout.append( "button 565 287 5602 5606 0 " + page );
        layout.append( "page " + page );
        layout.append( "button 580 287 5600 5604 0 " + ( page - 1 ) );
      endif
      layout.append( "button 525 " + ( y ) + " 2440 2440 1 0 " + ( MENUSTART + i ) );
      // layout.append("resizepic 525 "+(y)+" 9250 166 25");
      layout.append( "htmlgump 525 " + ( y ) + " 166 25 " + data.size() + " 1 0" );
      if ( ( cfgrandom[datadict.keys()[i]] ) && ( cfgrandom[datadict.keys()[i]].name ) )
        data.append( "<basefont color=" + HTML_DARKGRAY + "><center>" + cfgrandom[datadict.keys()[i]].name + "</center>" );
      elseif ( ( cfgeinzel[datadict.keys()[i]] ) && ( cfgeinzel[datadict.keys()[i]].name ) )
        data.append( "<basefont color=" + HTML_DARKBLUE + "><center>" + cfgeinzel[datadict.keys()[i]].name + "</center>" );
      elseif ( cfgset[datadict.keys()[i]].name )
        data.append( "<basefont color=" + HTML_DARKBLUE + "><center>" + cfgset[datadict.keys()[i]].name + "</center>" );
      else
        data.append( "<basefont color=" + HTML_DARKGRAY + "><center>" + datadict.keys()[i] + "</center>" );
      endif
      y += 30;
    endfor
  else
    for ( i := 1; i <= datadict.size(); i += 1 )
      if ( i == nextpagebreak )
        nextpagebreak += MAXBUTTON;
        y := 66;
        page += 1;
        layout.append( "button 565 287 5602 5606 0 " + page + " 0" );
        layout.append( "page " + page );
        layout.append( "button 580 287 5600 5604 0 " + ( page - 1 ) + " 0" );
      endif
      layout.append( "button 525 " + ( y ) + " 2440 2440 1 0 " + ( MENUSTART + i ) );
      // layout.append("resizepic 525 "+(y)+" 9250 166 25");
      layout.append( "htmlgump 525 " + ( y ) + " 166 25 " + data.size() + " 1 0" );
      if ( TypeOfInt( datadict[i] ) == OT_ARRAY ) // Typebezeichnung im Array
        if ( ( cfgrandom[datadict[i][1]].name ) || ( cfgeinzel[datadict[i][1]].name ) || ( cfgset[datadict[i][1]].name ) )
          case ( datadict[i][2] )
            "Random":
              data.append( "<basefont color=" + HTML_SADDLEBROWN + "><center>" + cfgrandom[datadict[i][1]].name + "</center>" );
            "Einzel":
              data.append( "<basefont color=" + HTML_SADDLEBROWN + "><center>" + cfgeinzel[datadict[i][1]].name + "</center>" );
            "Set":
              data.append( "<basefont color=" + HTML_SADDLEBROWN + "><center>" + cfgset[datadict[i][1]].name + "</center>" );
          endcase
        else
          data.append( "<basefont color=" + HTML_SADDLEBROWN + "><center>" + datadict[i][1] + "</center>" );
        endif
      endif
      y += 30;
    endfor
  endif
endfunction // }}}

///////////////////////////////////
// Init - Generates layout & data in a data file (server restart / hermit)
///////////////////////////////////

function Init() // {{{
  var layoutraw := { "nodispose", "page 0", // "resizepic 500 0 3600 215 390",  // Background
                                                                                              // "resizepic 515 15 5054 185 30",  // title
                                                                                              "resizepic 500 0 9200 215 390", "resizepic 515 15 3000 185 30", "htmlgump 515 22 185 30 0 0 0", // Title text
                                                                                              // "gumppictiled 516 47 183 328 2624",
                                                                                              // "resizepic 516 47 83 183 328",   // Posts
                                                                                              "resizepic 516 47 3000 183 328", // "checkertrans 524 57 168 308",
                                                                                              "htmlgump 610 285 50 20 1 0 0", "button 660 280 9726 9728 1 0 " + BACKBUTTON, "gumppictiled 525 320 166 2 30002", "button 530 330 9721 9724 1 0 " + ITEMMODIFYMANUAL, "htmlgump 572 335 100 30 2 0 0", "page 1" };
  var dataraw := { "", // Titel
                                "<basefont color=" + HTML_DARKBLUE + ">Back", "<basefont color=" + HTML_DARKBLUE + ">Item Modify" };

  SysLog( ".BAUTOOL Datafile begin" );
  SetGlobalProperty( "bautoolinit", 1 );

  var dataelement, layout := {}, data := {}, layoutp := {};
  var element := dictionary;
  var cfgmenu := ReadConfigFile( "bautoolmenues" );

  DFPurgeFile( datafile );

  // Layout to build
  dataelement := datafile.CreateElement( "menu" );

  // Read out the cfgmenu and insert the 3 cfgs
  foreach key in ( GetConfigStringArray( cfgmenu["Rootlist"], "sublist" ) ) // 1. level
    element[key] := dictionary;

    if ( cfgmenu[key].list ) // Items
      foreach itemlist in ( GetConfigStringArray( cfgmenu[key], "list" ) )
        element[key][itemlist] := array;
        foreach itemkey in ( GetConfigStringKeys( cfgrandom ) ) // Insert possible random
          if ( cfgrandom[itemkey].list == itemlist )
            element[key][itemlist].append( { itemkey, "Random", cfgrandom[itemkey].name } );
          endif
          SleepMS( 2 );
        endforeach
        foreach itemkey in ( GetConfigStringKeys( cfgeinzel ) ) // Insert possible single
          if ( cfgeinzel[itemkey].list == itemlist )
            element[key][itemlist].append( { itemkey, "Einzel", cfgeinzel[itemkey].name } );
          endif
          SleepMS( 2 );
        endforeach
        foreach itemkey in ( GetConfigStringKeys( cfgset ) ) // Insert possible sets
          if ( cfgset[itemkey].list == itemlist )
            element[key][itemlist].append( { itemkey, "Set", cfgset[itemkey].name } );
          endif
          SleepMS( 2 );
        endforeach
        element[key][itemlist] := SortArrayABC( element[key][itemlist], 1, 3 );
      endforeach
    endif

    if ( cfgmenu[key].sublist )
      foreach sub1key in ( GetConfigStringArray( cfgmenu[key], "sublist" ) ) // 2. level
        element[key][sub1key] := dictionary;

        if ( cfgmenu[sub1key].list ) // Items
          foreach itemlist in ( GetConfigStringArray( cfgmenu[sub1key], "list" ) )
            element[key][sub1key][itemlist] := array;
            foreach itemkey in ( GetConfigStringKeys( cfgrandom ) ) // Insert possible random
              if ( cfgrandom[itemkey].list == itemlist )
                element[key][sub1key][itemlist].append( { itemkey, "Random", cfgrandom[itemkey].name } );
              endif
              SleepMS( 2 );
            endforeach
            foreach itemkey in ( GetConfigStringKeys( cfgeinzel ) ) // Insert possible single
              if ( cfgeinzel[itemkey].list == itemlist )
                element[key][sub1key][itemlist].append( { itemkey, "Einzel", cfgeinzel[itemkey].name } );
              endif
              SleepMS( 2 );
            endforeach
            foreach itemkey in ( GetConfigStringKeys( cfgset ) ) // Insert possible sets
              if ( cfgset[itemkey].list == itemlist )
                element[key][sub1key][itemlist].append( { itemkey, "Set", cfgset[itemkey].name } );
              endif
              SleepMS( 2 );
            endforeach
            element[key][sub1key][itemlist] := SortArrayABC( element[key][sub1key][itemlist], 1, 3 );
          endforeach
        endif

        if ( cfgmenu[sub1key].sublist )
          foreach sub2key in ( GetConfigStringArray( cfgmenu[sub1key], "sublist" ) ) // 3. level
            element[key][sub1key][sub2key] := dictionary;

            if ( cfgmenu[sub2key].list ) // Items
              foreach itemlist in ( GetConfigStringArray( cfgmenu[sub2key], "list" ) )
                element[key][sub1key][sub2key][itemlist] := array;
                foreach itemkey in ( GetConfigStringKeys( cfgrandom ) ) // Insert possible random
                  if ( cfgrandom[itemkey].list == itemlist )
                    element[key][sub1key][sub2key][itemlist].append( { itemkey, "Random", cfgrandom[itemkey].name } );
                  endif
                  SleepMS( 2 );
                endforeach
                foreach itemkey in ( GetConfigStringKeys( cfgeinzel ) ) // Insert possible single
                  if ( cfgeinzel[itemkey].list == itemlist )
                    element[key][sub1key][sub2key][itemlist].append( { itemkey, "Einzel", cfgeinzel[itemkey].name } );
                  endif
                  SleepMS( 2 );
                endforeach
                foreach itemkey in ( GetConfigStringKeys( cfgset ) ) // Insert possible sets
                  if ( cfgset[itemkey].list == itemlist )
                    element[key][sub1key][sub2key][itemlist].append( { itemkey, "Set", cfgset[itemkey].name } );
                  endif
                  SleepMS( 2 );
                endforeach
                element[key][sub1key][sub2key][itemlist] := SortArrayABC( element[key][sub1key][sub2key][itemlist], 1, 3 );
              endforeach
            endif

            if ( cfgmenu[sub2key].sublist )
              foreach sub3key in ( GetConfigStringArray( cfgmenu[sub2key], "sublist" ) ) // 4. level
                element[key][sub1key][sub2key][sub3key] := dictionary;

                if ( cfgmenu[sub3key].list ) // Items
                  foreach itemlist in ( GetConfigStringArray( cfgmenu[sub3key], "list" ) )
                    element[key][sub1key][sub2key][sub3key][itemlist] := array;
                    foreach itemkey in ( GetConfigStringKeys( cfgrandom ) ) // Insert possible random
                      if ( cfgrandom[itemkey].list == itemlist )
                        element[key][sub1key][sub2key][sub3key][itemlist].append( { itemkey, "Random", cfgrandom[itemkey].name } );
                      endif
                      SleepMS( 2 );
                    endforeach
                    foreach itemkey in ( GetConfigStringKeys( cfgeinzel ) ) // Insert possible single
                      if ( cfgeinzel[itemkey].list == itemlist )
                        element[key][sub1key][sub2key][sub3key][itemlist].append( { itemkey, "Einzel", cfgeinzel[itemkey].name } );
                      endif
                      SleepMS( 2 );
                    endforeach
                    foreach itemkey in ( GetConfigStringKeys( cfgset ) ) // Insert possible sets
                      if ( cfgset[itemkey].list == itemlist )
                        element[key][sub1key][sub2key][sub3key][itemlist].append( { itemkey, "Set", cfgset[itemkey].name } );
                      endif
                      SleepMS( 2 );
                    endforeach
                    element[key][sub1key][sub2key][sub3key][itemlist] := SortArrayABC( element[key][sub1key][sub2key][sub3key][itemlist], 1, 3 );
                  endforeach
                endif
              endforeach
            endif
          endforeach
        endif
      endforeach
    endif
  endforeach

  // Rootlist
  layout := layoutraw;
  data := dataraw;
  MenuBar( layout, data, element );
  data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>BauTool " + VERSION + "</center>";
  // Titel

  dataelement.setprop( "LayoutMenuBar", layout );
  dataelement.setprop( "DataMenuBar", data );

  foreach ebene1 in element // 1. level
    layout := layoutraw;
    data := dataraw;
    MenuBar( layout, data, ebene1 );
    data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene1_iter + "</center>";
    // Titel
    dataelement.setprop( "LayoutMain_" + _ebene1_iter, layout );
    dataelement.setprop( "DataMain_" + _ebene1_iter, data );

    foreach ebene2 in ebene1 // 2.level
      layout := layoutraw;
      data := dataraw;
      MenuBar( layout, data, ebene2 );
      data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene2_iter + "</center>";
      // Titel
      dataelement.setprop( "LayoutSub_" + _ebene1_iter + "_" + _ebene2_iter, layout );
      dataelement.setprop( "DataSub_" + _ebene1_iter + "_" + _ebene2_iter, data );

      if ( TypeOfInt( ebene2 ) <> OT_DICTIONARY ) // Items
        foreach item in ebene2
          InitItems( data, layout, item, _ebene2_iter, layoutraw, dataraw );
          dataelement.setprop( "LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + item[1], layout );
          dataelement.setprop( "DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + item[1], data );
          SleepMS( 2 );
        endforeach
      else
        foreach ebene3 in ebene2 // 3.level
          layout := layoutraw;
          data := dataraw;
          MenuBar( layout, data, ebene3 );
          data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene3_iter + "</center>";
          // Titel
          dataelement.setprop( "LayoutSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter, layout );
          dataelement.setprop( "DataSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter, data );

          if ( TypeOfInt( ebene3 ) <> OT_DICTIONARY ) // Items
            foreach item in ebene3
              InitItems( data, layout, item, _ebene3_iter, layoutraw, dataraw );
              dataelement.setprop( "LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + item[1], layout );
              dataelement.setprop( "DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + item[1], data );
              SleepMS( 2 );
            endforeach
          else
            foreach ebene4 in ebene3 // 4.level
              layout := layoutraw;
              data := dataraw;
              MenuBar( layout, data, ebene4 );
              data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene4_iter + "</center>";
              // Titel
              dataelement.setprop( "LayoutSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter, layout );
              dataelement.setprop( "DataSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter, data );

              if ( TypeOfInt( ebene4 ) <> OT_DICTIONARY ) // Items
                foreach item in ebene4
                  InitItems( data, layout, item, _ebene4_iter, layoutraw, dataraw );
                  dataelement.setprop( "LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + item[1], layout );
                  dataelement.setprop( "DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + item[1], data );
                  SleepMS( 2 );
                endforeach
              else
                foreach ebene5 in ebene4 // 5.level
                  layout := layoutraw;
                  data := dataraw;
                  MenuBar( layout, data, ebene5 );
                  data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene5_iter + "</center>";
                  // Titel
                  dataelement.setprop( "LayoutSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter, layout );
                  dataelement.setprop( "DataSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter, data );

                  if ( TypeOfInt( ebene5 ) <> OT_DICTIONARY ) // Items
                    foreach item in ebene5
                      InitItems( data, layout, item, _ebene5_iter, layoutraw, dataraw );
                      dataelement.setprop( "LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter + "_" + item[1], layout );
                      dataelement.setprop( "DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter + "_" + item[1], data );
                      SleepMS( 2 );
                    endforeach
                  else
                    foreach ebene6 in ebene5 // 6.level
                      InitItems( data, layout, ebene6, _ebene6_iter, layoutraw, dataraw );
                      dataelement.setprop( "LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter + "_" + _ebene6_iter, layout );
                      dataelement.setprop( "DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter + "_" + _ebene6_iter, data );
                      SleepMS( 2 );
                    endforeach
                  endif
                endforeach
              endif
            endforeach
          endif
        endforeach
      endif
    endforeach
  endforeach

  // ModifyItem Menu
  dataelement := datafile.CreateElement( "modify" );
  layout := { "nodispose", "page 0", "resizepic 500 0 3600 215 280", // Background
                                                                                   "resizepic 515 15 5054 185 30", // title
                                                                                   "htmlgump 515 22 185 30 0 0 0", // Title text
                                                                                   "resizepic 515 47 83 185 218", // Posts
                                                                                   "checkertrans 523 57 170 198", "htmlgump 610 225 50 20 1 0 0", // Continue
                                                                                   "htmlgump 555 79 50 20 2 0 0", // X/Y
                                                                                   "htmlgump 624 79 50 20 3 0 0", // Z
                                                                                   "button 660 220 9721 9724 1 0 " + BACKBUTTON, "button 560 60 5600 5604 1 0 " + MODIFY_Y_DOWN, "button 560 100 5602 5606 1 0 " + MODIFY_Y_UP, "button 530 80 5603 5607 1 0 " + MODIFY_X_DOWN, "button 590 80 5601 5605 1 0 " + MODIFY_X_UP, "button 534 60 22406 22407 1 0 " + MODIFY_XY_MM, "button 583 60 22401 22400 1 0 " + MODIFY_XY_PM, "button 534 100 22403 22402 1 0 " + MODIFY_XY_MP, "button 583 100 22404 22405 1 0 " + MODIFY_XY_PP, "button 620 60 5600 5604 1 0 " + MODIFY_Z_UP, "button 620 100 5602 5606 1 0 " + MODIFY_Z_DOWN, "htmlgump 570 165 50 20 4 0 0", "button 530 160 9727 9728 1 0 " + MODIFY_DESTROY, "htmlgump 570 200 50 30 10 0 0", "button 530 195 9727 9728 1 0 " + MODIFY_DUPE, "htmlgump 570 130 50 30 5 0 0", "resizepic 610 125 2620 58 30", "textentry 616 130 40 20 1000 " + ITEMCOLOR + " 6", "button 530 125 9727 9728 1 0 " + MODIFY_COLOR, "htmlgump 630 60 50 20 7 0 0", // x / y / z Coord Specification of the first item
                                                                                   "tooltip 3000561", // Coords.:
                                                                                   "htmlgump 630 80 50 20 8 0 0", "tooltip 3000561", "htmlgump 630 100 50 20 9 0 0", "tooltip 3000561", "button 681 64 2103 2104 0 2 0", "button 681 84 2103 2104 0 3 0", "button 681 104 2103 2104 0 4 0" };

  data := { "<basefont size=8 color=" + HTML_DARKGREEN + "><center>Modify Position</center>", // title
                                                                                                       "<basefont color=" + HTML_DARKBLUE + ">Continue", "<basefont color=" + HTML_DARKBLUE + ">X/Y", "<basefont color=" + HTML_DARKBLUE + ">Z", "<basefont color=" + HTML_DARKBLUE + ">Destroy", "<basefont color=" + HTML_DARKBLUE + ">Color", "0", "<basefont color=" + HTML_DARKBLUE + "><p align=right>x</p></basefont>", "<basefont color=" + HTML_DARKBLUE + "><p align=right>y</p></basefont>", "<basefont color=" + HTML_DARKBLUE + "><p align=right>z</p></basefont>", "<basefont color=" + HTML_DARKBLUE + ">Dupe", "0", "0", "0" };
  layoutp := { "page 2", "resizepic 720 40 3600 100 60", "resizepic 735 55 2620 48 30", "textentrylimited 741 60 30 20 1000 " + MODIFY_X_ENTRY + " 11 4", "button 790 63 2103 2104 1 0 " + MODIFY_X, "page 3", "resizepic 720 60 3600 100 60", "resizepic 735 75 2620 48 30", "textentrylimited 741 80 30 20 1000 " + MODIFY_Y_ENTRY + " 12 4", "button 790 83 2103 2104 1 0 " + MODIFY_Y, "page 4", "resizepic 720 80 3600 100 60", "resizepic 735 95 2620 48 30", "textentrylimited 741 100 30 20 1000 " + MODIFY_Z_ENTRY + " 13 4", "button 790 103 2103 2104 1 0 " + MODIFY_Z };

  dataelement.setprop( "LayoutMenu", layout + layoutp );
  dataelement.setprop( "DataMenu", data );

  // manual Modify
  layout[3] := "resizepic 500 0 3600 215 440"; // Background expand
  layout[6] := "resizepic 516 47 83 183 377";
  layout[7] := "checkertrans 524 57 168 358";
  layout.erase( 8 ); // Next ButtonText
  layout.erase( 10 ); // Next button
  layout.append( "gumppictiled 525 235 165 2 30002" );
  layout.append( "htmlgump 595 255 100 20 1 0 0" );
  layout.append( "button 560 250 9721 9724 1 0 " + MODIFY_START );
  data[2] := "<basefont color=" + HTML_DARKBLUE + ">Choose Items";
  layout.append( "resizepic 530 285 2620 48 30" );
  layout.append( "textentry 536 290 30 20 1000 " + MODIFY_Z_START + " 14" );
  data.append( "-20" );
  layout.append( "resizepic 635 285 2620 48 30" );
  layout.append( "textentry 641 290 30 20 1000 " + MODIFY_Z_END + " 15" );
  data.append( "20" );
  layout.append( "htmlgump 585 290 50 20 16 0 0" );
  data.append( "<basefont color=" + HTML_DARKBLUE + ">Z-Range" );
  layout.append( "checkbox 530 320 9720 9723 0 " + MODIFY_CUSTOM );
  layout.append( "htmlgump 565 325 50 20 17 0 0" );
  data.append( "<basefont color=" + HTML_DARKBLUE + ">Custom" );
  layout.append( "checkbox 616 320 9720 9723 0 " + MODIFY_MARK );
  layout.append( "htmlgump 651 325 50 20 18 0 0" );
  data.append( "<basefont color=" + HTML_DARKBLUE + ">Mark" );
  layout.append( "gumppictiled 525 360 165 2 30002" );
  layout.append( "button 530 375 9721 9724 1 0 " + MODIFY_MARKEDIT );
  layout.append( "htmlgump 570 380 100 20 19 0 0" );
  data.append( "<basefont color=" + HTML_DARKBLUE + ">Mark Edit" );
  dataelement.setprop( "LayoutMenuManual", layout + layoutp );
  dataelement.setprop( "DataMenuManual", data );

  // Mark Edit
  dataelement := datafile.CreateElement( "modifymark" );
  layout := { "nodispose", "page 0", "resizepic 500 0 3600 215 213", // Background
                                                                                   "resizepic 515 15 5054 185 30", // title
                                                                                   "htmlgump 515 22 185 30 0 0 0", // Title text
                                                                                   "resizepic 515 47 83 185 150", // Posts-20
                                                                                   "checkertrans 523 57 170 130", "button 530 70 9721 9724 1 0 " + MARK_SHOW, "htmlgump 570 75 50 20 1 0 0", "button 530 105 9721 9724 1 0 " + MARK_HIDE, "htmlgump 570 110 50 20 2 0 0", "button 530 140 9721 9724 1 0 " + MARK_EDIT, "htmlgump 570 145 50 20 3 0 0" };
  data := { "<basefont size=8 color=" + HTML_DARKGRAY + "><center>Mark Edit</center>", "<basefont color=" + HTML_DARKBLUE + ">Show", "<basefont color=" + HTML_DARKBLUE + ">Hide", "<basefont color=" + HTML_DARKBLUE + ">Edit" };
  dataelement.setprop( "LayoutMenuMark", layout );
  dataelement.setprop( "DataMenuMark", data );

  // Save the dict of the menus / items
  dataelement := datafile.CreateElement( "elemente" );
  dataelement.setprop( "dictionary", element );

  EraseGlobalProperty( "bautoolinit" );
  SysLog( ".BAUTOOL Datafile completed" );

endfunction // }}}

///////////////////////////////////
// InitItems - Outsourcing for the init function
///////////////////////////////////

function InitItems( byref data, byref layout, byref element, name := 0, layoutraw, dataraw ) // {{{
  var tile, nextpagebreak, nextlinebreak, x, y, page, m, itemdesc;
  case ( element[2] )
    "Random": // Random
      layout := layoutraw;
      data := dataraw;
      data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + name + "</center>";
      // TESTTESTTEST
      layout := layout + { "page 0", "resizepic 70 0 3600 404 170", "resizepic 85 15 5054 374 30", "htmlgump 85 22 374 30 " + data.size() + " 0 0", "resizepic 85 47 83 374 108", "checkertrans 93 57 359 88" };
      data.append( "<basefont size=5><center>" + cfgrandom[element[1]].name + "</center>" );
      tile := GetConfigStringArray( cfgrandom[element[1]], "tile" )[1];
      layout.append( "tilepic 95 60 " + CInt( SplitWords( tile, "," )[1] ) );
      layout.append( "htmlgump 160 70 50 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">Color" );
      layout.append( "resizepic 200 65 2620 48 30" );
      layout.append( "textentry 206 70 30 20 1000 " + ITEMCOLOR + " " + data.size() );
      data.append( "0" );
      if ( ( GetConfigString( cfgrandom[element[1]], "n" ) ) // Option necessary for edge parts?
                                                                                                 || ( GetConfigString( cfgrandom[element[1]], "s" ) ) || ( GetConfigString( cfgrandom[element[1]], "e" ) ) || ( GetConfigString( cfgrandom[element[1]], "w" ) ) )
        layout.append( "htmlgump 360 60 50 40 " + data.size() + " 0 0" );
        data.append( "<basefont color=" + HTML_DARKBLUE + ">Produce Random Tiles" );
        layout.append( "checkbox 420 65 9720 9723 0 " + ITEMRAND );
      endif
      layout.append( "htmlgump 260 70 50 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">z-Coord" );
      layout.append( "resizepic 310 65 2620 38 30" );
      layout.append( "textentry 316 70 20 20 1000 " + ITEMPOS + " " + data.size() );
      data.append( "0" );
      layout.append( "checkbox 420 110 9720 9723 1 " + ITEMMODIFY );
      layout.append( "htmlgump 360 105 50 40 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">Modify Position" );
      layout.append( "button 103 116 9721 9724 1 0 " + ITEMCREATE );
      layout.append( "htmlgump 140 121 50 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">Create" );

    "Einzel":
      itemdesc := ReadConfigFile( ":*:itemdesc" ); // Reading of all Itemdesc's for name determination
      layout := layoutraw;
      data := dataraw;
      data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + name + "</center>";
      layout := layout + { "page 0", "resizepic 70 0 3600 425 400", "resizepic 85 15 5054 395 30", "htmlgump 85 22 395 30 " + data.size() + " 0 0", "resizepic 85 47 83 395 343" };
      data.append( "<basefont size=5><center>" + cfgeinzel[element[1]].name + "</center>" );
      layout.append( "htmlgump 530 70 50 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">Color" );
      layout.append( "resizepic 570 65 2620 48 30" );
      layout.append( "textentry 576 70 30 20 1000 " + ITEMCOLOR + " " + data.size() );
      data.append( "0" );
      layout.append( "htmlgump 530 110 50 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">z-Coord" );
      layout.append( "resizepic 580 105 2620 38 30" );
      layout.append( "textentry 586 110 20 20 1000 " + ITEMPOS + " " + data.size() );
      data.append( "0" );
      layout.append( "checkbox 530 150 9720 9723 1 " + ITEMMODIFY );
      layout.append( "htmlgump 572 155 100 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">Modify Position" );
      layout.append( "checkbox 530 185 9720 9723 0 " + ITEMMMULTICREATE );
      layout.append( "htmlgump 572 190 100 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">Mark All" );
      layout.append( "button 570 225 9721 9724 1 0 " + ITEMCREATE );
      layout.append( "htmlgump 612 230 50 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">Create" );

      tile := {};
      // Build an array of items
      foreach tiles in ( GetConfigStringArray( cfgeinzel[element[1]], "tile" ) )
        if ( !tile )
          tile := { tiles };
        else
          tile.append( tiles );
        endif
        SleepMS( 2 );
      endforeach
      // Generate pages of the items
      nextpagebreak := MAXLINEITEM * 2 + 1;
      nextlinebreak := MAXLINEITEM + 1;
      x := 100;
      y := 60;
      page := 1;
      layout.append( "page 1" );
      for ( m := 1; m <= tile.size(); m += 1 )
        if ( m == nextpagebreak )
          nextpagebreak += MAXLINEITEM * 2;
          nextlinebreak += MAXLINEITEM;
          x := 100;
          y := 60;
          if ( page > 1 )
            layout.append( "button 250 360 5603 5607 0 " + ( page - 1 ) + " 0" );
          endif
          page += 1;
          layout.append( "button 280 360 5601 5605 0 " + page + " 0" );
          layout.append( "page " + page );
        endif
        if ( m == nextlinebreak )
          y := 210;
          x := 100;
          nextlinebreak += MAXLINEITEM;
        endif

        layout.append( "radio " + ( x ) + " " + ( y + 35 ) + " 9720 9723 0 " + m );
        layout.append( "tilepic " + ( x + 35 ) + " " + ( y + 35 ) + " " + CInt( SplitWords( tile[m], "," )[1] ) );
        if ( itemdesc[Hex( tile[m] )].desc ) // Insert name .desc or CliLoc entry
          layout.append( "htmlgump " + ( x + 5 ) + " " + ( y ) + " 90 40 " + data.size() + " 0 0" );
          data.append( "<basefont color=" + HTML_GRAY + ">" + itemdesc[Hex( tile[m] )].desc );
        else
          layout.append( "xmfhtmlgumpcolor " + ( x + 5 ) + " " + ( y ) + " 90 40 " + ( 1020000 + CInt( tile[m] ) ) + " 0 0 " + XMFCOLOR_GRAY2 );
        endif
        x += 90;
        SleepMS( 2 );
      endfor
      if ( page > 1 )
        layout.append( "button 250 360 5603 5607 0 " + ( page - 1 ) + " 0" );
      endif

    "Set":
      layout := layoutraw;
      data := dataraw;
      data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + name + "</center>";
      layout.append( "htmlgump 515 60 185 30 " + data.size() + " 0 0" );
      data.append( "<basefont size=5 color=" + HTML_DARKGRAY + "><center>" + cfgset[element[1]].name + "</center>" );
      layout.append( "htmlgump 530 100 50 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">Color" );
      layout.append( "resizepic 570 95 2620 48 30" );
      layout.append( "textentry 576 100 30 20 1000 " + ITEMCOLOR + " " + data.size() );
      data.append( "0" );
      layout.append( "htmlgump 530 140 50 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">z-Coord" );
      layout.append( "resizepic 580 135 2620 38 30" );
      layout.append( "textentry 586 140 20 20 1000 " + ITEMPOS + " " + data.size() );
      data.append( "0" );
      layout.append( "checkbox 530 180 9720 9723 1 " + ITEMMODIFY );
      layout.append( "htmlgump 572 185 100 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">Modify Position" );
      layout.append( "checkbox 530 215 9720 9723 0 " + ITEMMMULTICREATE );
      layout.append( "htmlgump 572 220 100 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">Mark All" );

      layout.append( "button 570 255 9721 9724 1 0 " + ITEMCREATE );
      layout.append( "htmlgump 612 260 50 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">Create" );
  endcase
endfunction // }}}

///////////////////////////////////
// RecoverInitItem - in the event of a non-existent init item attempt to restore
///////////////////////////////////

function RecoverInitItem( newinit ) // {{{
  // Serial of the old, removed init item
  var oldinit := newinit.getprop( CPROP_INIT );

  // List of items found that also include the
  // have entered old serial as init item
  var found := array{ newinit };
  // List of the serials of these items (for a new initiative)
  var serials := array{ newinit.serial };

  // Search region for items ...
  foreach item in ( ListItemsNearLocation( newinit.x, newinit.y, LIST_IGNORE_Z, MAXAREASIZE, newinit.realm ) )
    SleepMs( 2 );
    if ( item.serial == newinit.serial )
      // do not enter twice
      continue;
    endif
    // ... who also entered the old serial
    if ( item.getprop( CPROP_INIT ) == oldinit )
      // pack in lists and ...
      found.append( item );
      serials.append( item.serial );
      // ... Enter new init item
      item.setprop( CPROP_INIT, newinit.serial );
    endif
  endforeach

  // complete new initiative
  newinit.setprop( CPROP_INIT, newinit.serial );
  newinit.setprop( CPROP_ITEMS, serials );

  // return list last
  return found;
endfunction // }}}
// vim: sw=2 sts=2
