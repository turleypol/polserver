EScript Compiler v1.17
Copyright (C) 1993-2024 Eric N. Swanson

Formatting: bautool.src
1
///////////////////////////////////////////////////////////////////////////
full
2
// bautool - bequemes Erzeugen und Verändern von Items und Itemgruppen
clear
3
//
EMPTY
4
// Author: Turley
clear
5
// eMail : michi.at.www@gmx.de
clear
7
// Konfigurationsdateien
clear
8
// - Menustruktur
clear
9
// - bautoolmenues.cfg
clear
10
// - Erstellt Rechtecke mit Tiles (Zufällig oder nur einen)
clear
11
// - bautoolrandom.cfg
clear
12
// - Erstellt einzelne Items
clear
13
// - bautooleinzel.cfg
clear
14
// - Erstellt Sets
clear
15
// - bautoolset.cfg
clear
17
///////////////////////////////////////////////////////////////////////////
full
18
// ToDo:
clear
19
// Zufallsding
clear
20
// - Auswahlliste wie Random/Einzel/Sets
clear
21
// - Wählt aus plus Wahrscheinlichkeiten
clear
22
// - Wenn fertig zusammengestellt Eck-Koords angeben und
clear
23
// createn, immer auf Maphöhe
clear
33
// Include "include/itemnpc";
clear
34
// Include "include/msgs";
clear
35
// Include "include/server";
clear
36
// Include "include/set";
clear
48
// Modify menu for later modification
clear
59
// Back-Button
clear
62
// ModifyItem-Buttons
clear
96
// plane definition
clear
107
// CProps to find the items
clear
109
// Original color for markedit
clear
112
// Start value of the lists / item buttons
clear
114
// Max Buttons in the NavBar
clear
115
// How many items side by side in single create
clear
121
// Load everything you need
clear
139
// Generate datafile via script
clear
151
// Developer can start Init () manually
clear
153
// First remove Ref's so that Unload works properly
clear
179
///////////////////////////////////
full
180
// ShowMenu - Actual main part
clear
181
///////////////////////////////////
full
183
// {{{
clear
192
// Now it can start
clear
201
// Simulated buttone printing
clear
207
// In which display level I am, create a suitable data list
clear
306
// Back
clear
307
// 2 because one was added beforehand
clear
330
// The Interesting Junk Item Creation
clear
333
// So that there is no final lock loop with Create
clear
349
// Manual ItemModify
clear
355
// Winke
clear
358
// }}}
clear
360
///////////////////////////////////
full
361
// BuildItems - get layout / data +
clear
362
// special stuff from Itemcreategumps
clear
363
///////////////////////////////////
full
367
// {{{
clear
392
// Build an array of items
clear
417
// }}}
clear
419
///////////////////////////////////
full
420
// CreateRandom - ...
clear
421
///////////////////////////////////
full
424
// {{{
clear
440
// Sorting the area
clear
461
// Begrenzte Ausdehnung?
clear
468
// Random items are to be generated
clear
471
// NW corner
clear
491
// Create second item
clear
509
// NE corner
clear
529
// Create second item
clear
547
// SE corner
clear
567
// Create second item
clear
585
// SW corner
clear
605
// Create second item
clear
623
// N page
clear
643
// Create second item
clear
661
// E side
clear
681
// Create second item
clear
699
// S side
clear
719
// Create second item
clear
737
// W page
clear
757
// Create second item
clear
775
// centerpiece
clear
793
// Create second item
clear
813
// Boring version without a border
clear
833
// Create second item
clear
853
// Save item series
clear
864
// Change position
clear
875
// }}}
clear
877
///////////////////////////////////
full
878
// Create singles - ...
clear
879
///////////////////////////////////
full
881
// {{{
clear
892
// Objtype
clear
893
// Feste z-Koords
clear
901
// Endless to ESC
clear
907
// Save item series
clear
911
// Change position
clear
928
// Itemserials to save
clear
936
// Postion to change
clear
941
// }}}
clear
943
///////////////////////////////////
full
944
// CreateSet - ...
clear
945
///////////////////////////////////
full
948
1018
///////////////////////////////////
full
1019
// ModifyItemsManual - ...
clear
1020
///////////////////////////////////
full
1022
// {{{
clear
1048
// Search for .bautool items
clear
1061
// it belongs to the same group
clear
1068
// save filtered serials
clear
1077
// items:={};
clear
1086
// it belongs to the same group
clear
1093
// save filtered serials
clear
1102
// Search for any items
clear
1117
// Sorting the area
clear
1134
// Don't take invisible stuff like spawn runes
clear
1143
// Save item series
clear
1155
// Move the selected item to the first position
clear
1177
// Reordering and final check
clear
1294
// Continue working with a copy
clear
1328
// Gump closed
clear
1334
// }}}
clear
1336
///////////////////////////////////
full
1337
// MarkEdit - Possibility to change the groups
clear
1338
///////////////////////////////////
full
1340
// {{{
clear
1354
// Sorting the area
clear
1370
// Items besorgen
clear
1379
// Coloring by groups
clear
1402
// Sorting the area
clear
1418
// Items besorgen
clear
1427
// Coloring by groups
clear
1442
// Freset work
clear
1476
// it belongs to the same group
clear
1487
// save filtered serials
clear
1496
// items:={};
clear
1503
// it belongs to the same group
clear
1514
// save filtered serials
clear
1528
// Remove from group
clear
1537
// Add
clear
1561
// If something has been done, reset the color
clear
1563
// Freset work
clear
1586
// }}}
clear
1588
///////////////////////////////////
full
1589
// ModifyItems - Position / color change after creation
clear
1590
///////////////////////////////////
full
1592
// {{{
clear
1690
// Edit copy further
clear
1718
// Abbruch
clear
1722
// }}}
clear
1724
///////////////////////////////////
full
1725
// ChooseRandom - Random determination of the items
clear
1726
///////////////////////////////////
full
1728
// {{{
clear
1731
// Distribution according to Cfg
clear
1738
// Gleichverteilt
clear
1741
// within the probability?
clear
1742
// Shoo Shoo
clear
1746
// well then just like that
clear
1747
// }}}
clear
1749
///////////////////////////////////
full
1750
// MenuBar - Creates the NavBar
clear
1751
///////////////////////////////////
full
1753
// {{{
clear
1755
// Data in dictionary or array
clear
1766
// layout.append("resizepic 525 "+(y)+" 9250 166 25");
clear
1794
// layout.append("resizepic 525 "+(y)+" 9250 166 25");
clear
1796
// Typebezeichnung im Array
clear
1814
// }}}
clear
1816
///////////////////////////////////
full
1817
// Init - Generates layout & data in a data file (server restart / hermit)
clear
1818
///////////////////////////////////
full
1820
// {{{
clear
1821
// "resizepic 500 0 3600 215 390",  // Background
clear
1822
// "resizepic 515 15 5054 185 30",  // title
clear
1824
// Title text
clear
1825
// "gumppictiled 516 47 183 328 2624",
clear
1826
// "resizepic 516 47 83 183 328",   // Posts
clear
1827
// "checkertrans 524 57 168 308",
clear
1831
// Titel
clear
1843
// Layout to build
clear
1846
// Read out the cfgmenu and insert the 3 cfgs
clear
1847
// 1. level
clear
1850
// Items
clear
1853
// Insert possible random
clear
1860
// Insert possible single
clear
1867
// Insert possible sets
clear
1879
// 2. level
clear
1882
// Items
clear
1886
// Insert possible random
clear
1893
// Insert possible single
clear
1900
// Insert possible sets
clear
1914
// 3. level
clear
1917
// Items
clear
1921
// Insert possible random
clear
1929
// Insert possible single
clear
1937
// Insert possible sets
clear
1952
// 4. level
clear
1955
// Items
clear
1959
// Insert possible random
clear
1970
// Insert possible single
clear
1981
// Insert possible sets
clear
2006
// Rootlist
clear
2011
// Titel
clear
2016
// 1. level
clear
2021
// Titel
clear
2025
// 2.level
clear
2030
// Titel
clear
2034
// Items
clear
2044
// 3.level
clear
2049
// Titel
clear
2055
// Items
clear
2065
// 4.level
clear
2070
// Titel
clear
2076
// Items
clear
2086
// 5.level
clear
2091
// Titel
clear
2097
// Items
clear
2107
// 6.level
clear
2125
// ModifyItem Menu
clear
2127
// Background
clear
2128
// title
clear
2129
// Title text
clear
2130
// Posts
clear
2131
// Continue
clear
2132
// X/Y
clear
2133
// Z
clear
2144
// x / y / z Coord Specification of the first item
clear
2145
// Coords.:
clear
2151
// title
clear
2169
// manual Modify
clear
2170
// Background expand
clear
2173
// Next ButtonText
clear
2174
// Next button
clear
2200
// Mark Edit
clear
2202
// Background
clear
2203
// title
clear
2204
// Title text
clear
2205
// Posts-20
clear
2216
// Save the dict of the menus / items
clear
2223
// }}}
clear
2225
///////////////////////////////////
full
2226
// InitItems - Outsourcing for the init function
clear
2227
///////////////////////////////////
full
2230
// {{{
clear
2233
// Random
clear
2237
// TESTTESTTEST
clear
2250
// Option necessary for edge parts?
clear
2272
// Reading of all Itemdesc's for name determination
clear
2302
// Build an array of items
clear
2311
// Generate pages of the items
clear
2340
// Insert name .desc or CliLoc entry
clear
2385
// }}}
clear
2387
///////////////////////////////////
full
2388
// RecoverInitItem - in the event of a non-existent init item attempt to restore
clear
2389
///////////////////////////////////
full
2391
// {{{
clear
2392
// Serial of the old, removed init item
clear
2395
// List of items found that also include the
clear
2396
// have entered old serial as init item
clear
2398
// List of the serials of these items (for a new initiative)
clear
2401
// Search region for items ...
clear
2406
// do not enter twice
clear
2409
// ... who also entered the old serial
clear
2411
// pack in lists and ...
clear
2414
// ... Enter new init item
clear
2419
// complete new initiative
clear
2423
// return list last
clear
2425
// }}}
clear
2426
// vim: sw=2 sts=2
clear
BREAK 
"use cfgfile; " 0
BREAK 
"use os; " 0
BREAK 
"use uo; " 0
BREAK 
"use util; " 0
BREAK 
"include "client"; " 0
BREAK 
"include ":datafile:datafile"; " 0
BREAK 
"include ":gumps:textConsts"; " 0
BREAK 
"include "string"; " 0
BREAK 
"const VERSION := "<basefont color=" + HTML_DARKBLUE + ">V4.2a"; " 0
BREAK 
"enum TextEntry_Checkboxes " 0
BREAK 
"ITEMCOLOR := 1000, " 0
BREAK 
"ITEMRAND, " 0
BREAK 
"ITEMCREATE, " 0
BREAK 
"ITEMPOS, " 0
BREAK 
"ITEMMODIFY, " 0
BREAK 
"ITEMMMULTICREATE, " 0
BREAK 
"ITEMMODIFYMANUAL, // Modify menu for later modification " 0
BREAK 
"MODIFY_Z_START, " 0
BREAK 
"MODIFY_Z_END, " 0
BREAK 
"MODIFY_CUSTOM, " 0
BREAK 
"MODIFY_MARK, " 0
BREAK 
"MODIFY_X_ENTRY, " 0
BREAK 
"MODIFY_Y_ENTRY, " 0
BREAK 
"MODIFY_Z_ENTRY " 0
BREAK 
"endenum " 0
BREAK 
"enum Buttons " 0
BREAK 
"BACKBUTTON := 2000, // Back-Button " 0
BREAK 
"MODIFY_MARKEDIT, " 0
BREAK 
"MODIFY_START := 3000, " 0
BREAK 
"MODIFY_Y_UP := 3005, // ModifyItem-Buttons " 0
BREAK 
"MODIFY_Y_DOWN, " 0
BREAK 
"MODIFY_X_UP, " 0
BREAK 
"MODIFY_X_DOWN, " 0
BREAK 
"MODIFY_XY_MM, " 0
BREAK 
"MODIFY_XY_MP, " 0
BREAK 
"MODIFY_XY_PM, " 0
BREAK 
"MODIFY_XY_PP, " 0
BREAK 
"MODIFY_Z_UP, " 0
BREAK 
"MODIFY_Z_DOWN, " 0
BREAK 
"MODIFY_DESTROY, " 0
BREAK 
"MODIFY_COLOR, " 0
BREAK 
"MODIFY_DUPE, " 0
BREAK 
"MODIFY_X, " 0
BREAK 
"MODIFY_Y, " 0
BREAK 
"MODIFY_Z, " 0
BREAK 
"MARK_SHOW, " 0
BREAK 
"MARK_HIDE, " 0
BREAK 
"MARK_EDIT " 0
BREAK 
"endenum " 0
BREAK 
"enum dataPositionsAngaben " 0
BREAK 
"COLORDATAPOS := 7, " 0
BREAK 
"ZSTARTPOS := 15, " 0
BREAK 
"ZENDPOS := 16, " 0
BREAK 
"XKOORDSPOS := 8, " 0
BREAK 
"YKOORDSPOS := 9, " 0
BREAK 
"ZKOORDSPOS := 10, " 0
BREAK 
"XENTRY := 12, " 0
BREAK 
"YENTRY, " 0
BREAK 
"ZENTRY " 0
BREAK 
"endenum " 0
BREAK 
"enum Ebenen " 0
BREAK 
"ROOTLIST := 0, // plane definition " 0
BREAK 
"FIRSTLIST, " 0
BREAK 
"SECONDLIST, " 0
BREAK 
"THIRDLIST, " 0
BREAK 
"FOURTHLIST, " 0
BREAK 
"FIFTHLIST, " 0
BREAK 
"ITEMLIST, " 0
BREAK 
"ITEMLISTDUMMY " 0
BREAK 
"endenum " 0
BREAK 
"enum Cprops " 0
BREAK 
"CPROP_INIT := "bautoolinit", // CProps to find the items " 0
BREAK 
"CPROP_ITEMS := "bautoolitems", " 0
BREAK 
"CPROP_COLOR := "bautoolorigcol" // Original color for markedit " 0
BREAK 
"endenum " 0
BREAK 
"const MENUSTART := 4000; " 0
"// Start value of the lists / item buttons " 0
BREAK 
"const MAXBUTTON := 7; " 0
"// Max Buttons in the NavBar " 0
BREAK 
"const MAXLINEITEM := 4; " 0
"// How many items side by side in single create " 0
BREAK 
"const MAXAREASIZE := 50; " 0
BREAK 
"const ITEMMOVEFLAGS := MOVEOBJECT_FORCELOCATION + MOVEITEM_IGNOREMOVABLE; " 0
BREAK 
"var cfgrandom := ReadConfigFile( " 0
""bautoolrandom" ); " 0
BREAK 
"var cfgeinzel := ReadConfigFile( " 0
""bautooleinzel" ); " 0
BREAK 
"var cfgset := ReadConfigFile( " 0
""bautoolset" ); " 0
BREAK 
"var datafile := DFOpenDataFile( " 0
""bautoolcmd", " 0
"DF_CREATE, " 0
"DF_KEYTYPE_STRING ); " 0
BREAK 
"var dataelementMenu := datafile.FindElement( " 0
""menu" ); " 0
BREAK 
"var dataelementModify := datafile.FindElement( " 0
""modify" ); " 0
BREAK 
"var dataelementElement := datafile.FindElement( " 0
""elemente" ); " 0
BREAK 
"var dataelementMark := datafile.FindElement( " 0
""modifymark" ); " 0
BREAK 
"var layoutmodify := dataelementModify.getprop( " 0
""LayoutMenu" ); " 0
BREAK 
"var datamodify := dataelementModify.getprop( " 0
""DataMenu" ); " 0
BREAK 
"var layoutmodify_M := dataelementModify.getprop( " 0
""LayoutMenuManual" ); " 0
BREAK 
"var datamodify_M := dataelementModify.getprop( " 0
""DataMenuManual" ); " 0
BREAK 
"var layoutmark := dataelementMark.getprop( " 0
""LayoutMenuMark" ); " 0
BREAK 
"var datamark := dataelementMark.getprop( " 0
""DataMenuMark" ); " 0
BREAK 
"var datafileelement := dataelementElement.getprop( " 0
""dictionary" ); " 0
BREAK 
"program bautool( " 0
"who, " 0
"param ) " 0
BREAK 
"if ( " 0
"who[1] == "Init" ) // Generate datafile via script " 0
BREAK 
"Init(); " 0
BREAK 
"return; " 0
BREAK 
"endif " 0
BREAK 
"if ( " 0
"!GetGlobalProperty( " 0
""BauServer" ) " 0
") " 0
BREAK 
"if ( " 0
"who.cmdlevel < 3 ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""You are not authorized to use this command!" ); " 0
BREAK 
"return; " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"if ( " 0
"Lower( " 0
"param ) " 0
"== "init" ) // Developer can start Init () manually " 0
BREAK 
"if ( " 0
"who.cmdlevel == 5 ) " 0
BREAK 
"cfgrandom := 0; " 0
"// First remove Ref's so that Unload works properly " 0
BREAK 
"cfgeinzel := 0; " 0
BREAK 
"cfgset := 0; " 0
BREAK 
"UnloadConfigFile( " 0
""bautoolmenues" ); " 0
BREAK 
"UnloadConfigFile( " 0
""bautooleinzel" ); " 0
BREAK 
"UnloadConfigFile( " 0
""bautoolrandom" ); " 0
BREAK 
"UnloadConfigFile( " 0
""bautoolset" ); " 0
BREAK 
"cfgrandom := ReadConfigFile( " 0
"":bautool:bautoolrandom" ); " 0
BREAK 
"cfgeinzel := ReadConfigFile( " 0
"":bautool:bautooleinzel" ); " 0
BREAK 
"cfgset := ReadConfigFile( " 0
"":bautool:bautoolset" ); " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Datafile building..." ); " 0
BREAK 
"Init(); " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Datafile completed" ); " 0
BREAK 
"return; " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"if ( " 0
"GetGlobalProperty( " 0
""bautoolinit" ) " 0
") " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Datafile is still being generated, try again later." ); " 0
BREAK 
"return; " 0
BREAK 
"endif " 0
BREAK 
"ShowMenu( " 0
"who ); " 0
BREAK 
"endprogram " 0
BREAK 
"function ShowMenu( " 0
"who ) " 0
"// {{{ " 0
BREAK 
"var data := {}, " 0
"layout := {}, " 0
"nr, " 0
"ebene; " 0
BREAK 
"var ret, " 0
"tile := {}; " 0
BREAK 
"var element := dictionary, " 0
"back := 0; " 0
BREAK 
"var firstebene, " 0
"secondebene, " 0
"thirdebene, " 0
"fourthebene, " 0
"fifthebene, " 0
"itemebene; " 0
BREAK 
"var color; " 0
BREAK 
"element := datafileelement; " 0
BREAK 
"ebene := FIRSTLIST; " 0
BREAK 
"layout := dataelementMenu.getprop( " 0
""LayoutMenuBar" ); " 0
BREAK 
"data := dataelementMenu.getprop( " 0
""DataMenuBar" ); " 0
BREAK 
"ret := SendDialogGump( " 0
"who, " 0
"layout, " 0
"data, " 0
"10, " 0
"50 ); " 0
BREAK 
"while ( " 0
"who.connected ) " 0
BREAK 
"if ( " 0
"( " 0
"ret.keys[ret.keys.size()] " 0
"> MENUSTART ) || " 0
"( " 0
"back ) ) " 0
BREAK 
"if ( " 0
"back ) // Simulated buttone printing " 0
BREAK 
"nr := back; " 0
BREAK 
"back := 0; " 0
BREAK 
"else " 0
BREAK 
"nr := ret.keys[ret.keys.size()] " 0
"- MENUSTART; " 0
BREAK 
"endif " 0
BREAK 
"case " 0
"( " 0
"ebene ) " 0
"// In which display level I am, create a suitable data list " 0
BREAK 
"ROOTLIST: " 0
BREAK 
"ebene := FIRSTLIST; " 0
BREAK 
"layout := dataelementMenu.getprop( " 0
""LayoutMenuBar" ); " 0
BREAK 
"data := dataelementMenu.getprop( " 0
""DataMenuBar" ); " 0
BREAK 
"FIRSTLIST: " 0
BREAK 
"ebene := SECONDLIST; " 0
BREAK 
"if ( " 0
"TypeOfInt( " 0
"nr ) " 0
"== OT_STRING ) " 0
BREAK 
"firstebene := nr; " 0
BREAK 
"else " 0
BREAK 
"firstebene := element.keys()[" 0
"nr]; " 0
BREAK 
"endif " 0
BREAK 
"layout := dataelementMenu.getprop( " 0
""LayoutMain_" + firstebene ); " 0
BREAK 
"data := dataelementMenu.getprop( " 0
""DataMain_" + firstebene ); " 0
BREAK 
"SECONDLIST: " 0
BREAK 
"ebene := THIRDLIST; " 0
BREAK 
"if ( " 0
"TypeOfInt( " 0
"element[firstebene] ) " 0
"<> OT_DICTIONARY ) " 0
BREAK 
"secondebene := nr; " 0
BREAK 
"tile := BuildItems( " 0
"layout, " 0
"data, " 0
"element[firstebene][nr], " 0
"firstebene ); " 0
BREAK 
"else " 0
BREAK 
"if ( " 0
"TypeOfInt( " 0
"nr ) " 0
"== OT_STRING ) " 0
BREAK 
"secondebene := nr; " 0
BREAK 
"else " 0
BREAK 
"secondebene := element[firstebene].keys()[" 0
"nr]; " 0
BREAK 
"endif " 0
BREAK 
"layout := dataelementMenu.getprop( " 0
""LayoutSub_" + firstebene + "_" + secondebene ); " 0
BREAK 
"data := dataelementMenu.getprop( " 0
""DataSub_" + firstebene + "_" + secondebene ); " 0
BREAK 
"endif " 0
BREAK 
"THIRDLIST: " 0
BREAK 
"ebene := FOURTHLIST; " 0
BREAK 
"if ( " 0
"TypeOfInt( " 0
"element[firstebene][secondebene] ) " 0
"<> OT_DICTIONARY ) " 0
BREAK 
"thirdebene := nr; " 0
BREAK 
"tile := BuildItems( " 0
"layout, " 0
"data, " 0
"element[firstebene][secondebene][nr], " 0
"firstebene, " 0
"secondebene ); " 0
BREAK 
"else " 0
BREAK 
"if ( " 0
"TypeOfInt( " 0
"nr ) " 0
"== OT_STRING ) " 0
BREAK 
"thirdebene := nr; " 0
BREAK 
"else " 0
BREAK 
"thirdebene := element[firstebene][secondebene].keys()[" 0
"nr]; " 0
BREAK 
"endif " 0
BREAK 
"layout := dataelementMenu.getprop( " 0
""LayoutSub_" + firstebene + "_" + secondebene + "_" + thirdebene ); " 0
BREAK 
"data := dataelementMenu.getprop( " 0
""DataSub_" + firstebene + "_" + secondebene + "_" + thirdebene ); " 0
BREAK 
"endif " 0
BREAK 
"FOURTHLIST: " 0
BREAK 
"ebene := FIFTHLIST; " 0
BREAK 
"if ( " 0
"TypeOfInt( " 0
"element[firstebene][secondebene][thirdebene] ) " 0
"<> OT_DICTIONARY ) " 0
BREAK 
"fourthebene := nr; " 0
BREAK 
"tile := BuildItems( " 0
"layout, " 0
"data, " 0
"element[firstebene][secondebene][thirdebene][nr], " 0
"firstebene, " 0
"secondebene, " 0
"thirdebene ); " 0
BREAK 
"else " 0
BREAK 
"ebene := FIFTHLIST; " 0
BREAK 
"if ( " 0
"TypeOfInt( " 0
"nr ) " 0
"== OT_STRING ) " 0
BREAK 
"fourthebene := nr; " 0
BREAK 
"else " 0
BREAK 
"fourthebene := element[firstebene][secondebene][thirdebene].keys()[" 0
"nr]; " 0
BREAK 
"endif " 0
BREAK 
"layout := dataelementMenu.getprop( " 0
""LayoutSub_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene ); " 0
BREAK 
"data := dataelementMenu.getprop( " 0
""DataSub_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene ); " 0
BREAK 
"endif " 0
BREAK 
"FIFTHLIST: " 0
BREAK 
"ebene := ITEMLIST; " 0
BREAK 
"if ( " 0
"TypeOfInt( " 0
"element[firstebene][secondebene][thirdebene][fourthebene] ) " 0
"<> OT_DICTIONARY ) " 0
BREAK 
"fifthebene := nr; " 0
BREAK 
"tile := BuildItems( " 0
"layout, " 0
"data, " 0
"element[firstebene][secondebene][thirdebene][fourthebene][nr], " 0
"firstebene, " 0
"secondebene, " 0
"thirdebene, " 0
"fourthebene ); " 0
BREAK 
"else " 0
BREAK 
"ebene := ITEMLIST; " 0
BREAK 
"if ( " 0
"TypeOfInt( " 0
"nr ) " 0
"== OT_STRING ) " 0
BREAK 
"fifthebene := nr; " 0
BREAK 
"else " 0
BREAK 
"fifthebene := element[firstebene][secondebene][thirdebene][fourthebene].keys()[" 0
"nr]; " 0
BREAK 
"endif " 0
BREAK 
"layout := dataelementMenu.getprop( " 0
""LayoutSub_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene ); " 0
BREAK 
"data := dataelementMenu.getprop( " 0
""DataSub_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene ); " 0
BREAK 
"endif " 0
BREAK 
"ITEMLIST: " 0
BREAK 
"ITEMLISTDUMMY: " 0
BREAK 
"ebene := ITEMLISTDUMMY; " 0
BREAK 
"if ( " 0
"TypeOfInt( " 0
"nr ) " 0
"== OT_STRING ) " 0
BREAK 
"itemebene := nr; " 0
BREAK 
"else " 0
BREAK 
"itemebene := element[firstebene][secondebene][thirdebene][fourthebene][fifthebene][nr]; " 0
BREAK 
"endif " 0
BREAK 
"tile := BuildItems( " 0
"layout, " 0
"data, " 0
"element[firstebene][secondebene][thirdebene][fourthebene][fifthebene][nr], " 0
"firstebene, " 0
"secondebene, " 0
"thirdebene, " 0
"fourthebene, " 0
"fifthebene, " 0
"itemebene[1] ); " 0
BREAK 
"endcase " 0
BREAK 
"ret := SendDialogGump( " 0
"who, " 0
"layout, " 0
"data, " 0
"10, " 0
"50 ); " 0
BREAK 
"elseif ( " 0
"ret[BACKBUTTON] ) // Back " 0
BREAK 
"ebene -= 2; " 0
"// 2 because one was added beforehand " 0
BREAK 
"if ( " 0
"ebene < 0 ) " 0
BREAK 
"ebene := ROOTLIST; " 0
BREAK 
"endif " 0
BREAK 
"case " 0
"( " 0
"ebene ) " 0
BREAK 
"ROOTLIST: " 0
BREAK 
"back := 1; " 0
BREAK 
"FIRSTLIST: " 0
BREAK 
"back := firstebene; " 0
BREAK 
"SECONDLIST: " 0
BREAK 
"back := secondebene; " 0
BREAK 
"THIRDLIST: " 0
BREAK 
"back := thirdebene; " 0
BREAK 
"FOURTHLIST: " 0
BREAK 
"back := fourthebene; " 0
BREAK 
"FIFTHLIST: " 0
BREAK 
"back := fifthebene; " 0
BREAK 
"ITEMLIST: " 0
BREAK 
"back := itemebene; " 0
BREAK 
"ITEMLISTDUMMY: " 0
BREAK 
"back := itemebene; " 0
BREAK 
"endcase " 0
BREAK 
"elseif ( " 0
"ret[ITEMCREATE] ) " 0
BREAK 
"ebene -= 1; " 0
BREAK 
"back := nr; " 0
"// So that there is no final lock loop with Create " 0
BREAK 
"color := ret[ITEMCOLOR]; " 0
BREAK 
"color[1, " 0
"6] := ""; " 0
BREAK 
"color := CInt( " 0
"color ); " 0
BREAK 
"case " 0
"( " 0
"tile[1][2] ) " 0
BREAK 
""Random": " 0
BREAK 
"CreateRandom( " 0
"who, " 0
"ret, " 0
"tile[2], " 0
"tile[3], " 0
"color, " 0
"tile[1][1] ); " 0
BREAK 
""Einzel": " 0
BREAK 
"CreateEinzel( " 0
"who, " 0
"ret, " 0
"tile[2], " 0
"color ); " 0
BREAK 
""Set": " 0
BREAK 
"CreateSet( " 0
"who, " 0
"ret, " 0
"tile[2], " 0
"color ); " 0
BREAK 
"default: " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""error..." ); " 0
BREAK 
"return; " 0
BREAK 
"endcase " 0
BREAK 
"elseif ( " 0
"ret[ITEMMODIFYMANUAL] ) " 0
BREAK 
"ModifyItemsManual( " 0
"who ); " 0
BREAK 
"back := 1; " 0
BREAK 
"ebene := ROOTLIST; " 0
BREAK 
"else " 0
BREAK 
"return; " 0
"// Winke " 0
BREAK 
"endif " 0
BREAK 
"endwhile " 0
BREAK 
"endfunction // }}} " 0
BREAK 
"function BuildItems( " 0
"byref layout, " 0
"byref data, " 0
"byref element, " 0
"firstebene, " 0
"secondebene := 0, " 0
"thirdebene := 0, " 0
"fourthebene := 0, " 0
"fifthebene := 0, " 0
"itemebene := 0 ) " 0
BREAK 
"var tiles := {}; " 0
BREAK 
"var tiles1 := {}; " 0
BREAK 
"var splittiles := {}; " 0
BREAK 
"if ( " 0
"itemebene ) " 0
BREAK 
"layout := dataelementMenu.getprop( " 0
""LayoutItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene + "_" + itemebene ); " 0
BREAK 
"data := dataelementMenu.getprop( " 0
""DataItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene + "_" + itemebene ); " 0
BREAK 
"elseif ( " 0
"fifthebene ) " 0
BREAK 
"layout := dataelementMenu.getprop( " 0
""LayoutItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene ); " 0
BREAK 
"data := dataelementMenu.getprop( " 0
""DataItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene ); " 0
BREAK 
"elseif ( " 0
"fourthebene ) " 0
BREAK 
"layout := dataelementMenu.getprop( " 0
""LayoutItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + element[1] ); " 0
BREAK 
"data := dataelementMenu.getprop( " 0
""DataItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + element[1] ); " 0
BREAK 
"elseif ( " 0
"thirdebene ) " 0
BREAK 
"layout := dataelementMenu.getprop( " 0
""LayoutItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + element[1] ); " 0
BREAK 
"data := dataelementMenu.getprop( " 0
""DataItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + element[1] ); " 0
BREAK 
"elseif ( " 0
"secondebene ) " 0
BREAK 
"layout := dataelementMenu.getprop( " 0
""LayoutItem_" + firstebene + "_" + secondebene + "_" + element[1] ); " 0
BREAK 
"data := dataelementMenu.getprop( " 0
""DataItem_" + firstebene + "_" + secondebene + "_" + element[1] ); " 0
BREAK 
"elseif ( " 0
"firstebene ) " 0
BREAK 
"layout := dataelementMenu.getprop( " 0
""LayoutItem_" + firstebene + "_" + element[1] ); " 0
BREAK 
"data := dataelementMenu.getprop( " 0
""DataItem_" + firstebene + "_" + element[1] ); " 0
BREAK 
"endif " 0
BREAK 
"case " 0
"( " 0
"element[2] ) " 0
BREAK 
""Random": " 0
BREAK 
"foreach tile in ( " 0
"GetConfigStringArray( " 0
"cfgrandom[element[1]], " 0
""tile" ) " 0
") " 0
BREAK 
"splittiles := SplitWords( " 0
"tile ); " 0
BREAK 
"tiles.append( " 0
"splittiles[1] ); " 0
BREAK 
"if ( " 0
"splittiles[2] ) " 0
BREAK 
"tiles1.append( " 0
"splittiles[2] ); " 0
BREAK 
"endif " 0
BREAK 
"endforeach " 0
BREAK 
""Einzel": " 0
BREAK 
"foreach tile in ( " 0
"GetConfigStringArray( " 0
"cfgeinzel[element[1]], " 0
""tile" ) " 0
") " 0
BREAK 
"if ( " 0
"!tiles ) " 0
BREAK 
"tiles := { " 0
"tile }; " 0
BREAK 
"else " 0
BREAK 
"tiles.append( " 0
"tile ); " 0
BREAK 
"endif " 0
BREAK 
"endforeach " 0
BREAK 
""Set": " 0
BREAK 
"tiles := element[1]; " 0
BREAK 
"endcase " 0
BREAK 
"return ( " 0
"{ " 0
"element, " 0
"tiles, " 0
"tiles1 } " 0
"); " 0
BREAK 
"endfunction // }}} " 0
BREAK 
"function CreateRandom( " 0
"who, " 0
"byref ret, " 0
"byref tiles, " 0
"byref tiles1, " 0
"byref color, " 0
"byref element ) " 0
BREAK 
"var tar1, " 0
"tar2, " 0
"item, " 0
"x, " 0
"y, " 0
"z, " 0
"Tarx, " 0
"Tary, " 0
"Tarx2, " 0
"Tary2, " 0
"itemdef, " 0
"items := {}, " 0
"itemserials := {}; " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Target first corner" ); " 0
BREAK 
"tar1 := TargetCoordinates( " 0
"who ); " 0
BREAK 
"if ( " 0
"tar1 ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Target the second corner" ); " 0
BREAK 
"tar2 := TargetCoordinates( " 0
"who ); " 0
BREAK 
"if ( " 0
"tar2 ) " 0
BREAK 
"if ( " 0
"( " 0
"tar1.item ) || " 0
"( " 0
"tar2.item ) ) " 0
BREAK 
"if ( " 0
"( " 0
"tar1.item.container ) || " 0
"( " 0
"tar2.item.container ) ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""cancellation. Item in Container targeted!" ); " 0
BREAK 
"return; " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"if ( " 0
"tar1.x >= tar2.x ) // Sorting the area " 0
BREAK 
"Tarx := tar2.x; " 0
BREAK 
"Tarx2 := tar1.x; " 0
BREAK 
"else " 0
BREAK 
"Tarx := tar1.x; " 0
BREAK 
"Tarx2 := tar2.x; " 0
BREAK 
"endif " 0
BREAK 
"if ( " 0
"tar1.y >= tar2.y ) " 0
BREAK 
"Tary := tar2.y; " 0
BREAK 
"Tary2 := tar1.y; " 0
BREAK 
"else " 0
BREAK 
"Tary := tar1.y; " 0
BREAK 
"Tary2 := tar2.y; " 0
BREAK 
"endif " 0
BREAK 
"if ( " 0
"( " 0
"( " 0
"Tarx2 - Tarx ) > MAXAREASIZE ) || " 0
"( " 0
"( " 0
"Tary2 - Tary ) > MAXAREASIZE ) ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Cancellation.  " + MAXAREASIZE + "x" + MAXAREASIZE + " Generate items!" ); " 0
BREAK 
"return; " 0
BREAK 
"endif " 0
BREAK 
"z := ret[ITEMPOS]; " 0
BREAK 
"z[1, " 0
"6] := ""; " 0
BREAK 
"z := CInt( " 0
"z ); " 0
BREAK 
"if ( " 0
"GetConfigString( " 0
"cfgrandom[element], " 0
""x" ) " 0
") " 0
BREAK 
"Tarx2 := Tarx + CInt( " 0
"GetConfigString( " 0
"cfgrandom[element], " 0
""x" ) " 0
") " 0
"- 1; " 0
BREAK 
"endif " 0
BREAK 
"if ( " 0
"GetConfigString( " 0
"cfgrandom[element], " 0
""y" ) " 0
") " 0
BREAK 
"Tary2 := Tary + CInt( " 0
"GetConfigString( " 0
"cfgrandom[element], " 0
""y" ) " 0
") " 0
"- 1; " 0
BREAK 
"endif " 0
BREAK 
"if ( " 0
"ret[ITEMRAND] ) // Random items are to be generated " 0
BREAK 
"for ( " 0
"x := Tarx; " 0
"x <= Tarx2; " 0
"x += 1 ) " 0
BREAK 
"for ( " 0
"y := Tary; " 0
"y <= Tary2; " 0
"y += 1 ) " 0
BREAK 
"if ( " 0
"( " 0
"x == Tarx ) && " 0
"( " 0
"y == Tary ) ) // NW corner " 0
BREAK 
"itemdef := GetConfigString( " 0
"cfgrandom[element], " 0
""nw" ); " 0
BREAK 
"if ( " 0
"!itemdef ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""NW corner is missing." ); " 0
BREAK 
"else " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( " 0
"itemdef ); " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef, " 0
""," ); " 0
BREAK 
"item := CreateItemAtLocation( " 0
"x, " 0
"y, " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z, " 0
"CInt( " 0
"itemdef[1] ), " 0
"1, " 0
"who.realm ); " 0
BREAK 
"if ( " 0
"item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( " 0
"item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Create Error!  " + x + " " + y + " " + ( " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z ) + " " + Hex( " 0
"itemdef[1] ) " 0
"+ " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"itemdef := GetConfigString( " 0
"cfgrandom[element], " 0
""nw1" ); " 0
BREAK 
"if ( " 0
"( " 0
"itemdef ) && " 0
"( " 0
"itemdef <> {} " 0
") ) " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( " 0
"itemdef ); " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef, " 0
""," ); " 0
BREAK 
"item := CreateItemAtLocation( " 0
"x, " 0
"y, " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z, " 0
"CInt( " 0
"itemdef[1] ), " 0
"1, " 0
"who.realm ); " 0
BREAK 
"if ( " 0
"item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( " 0
"item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Create error! NW-Corner 2nd item" + x + " " + y + " " + ( " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z ) + " " + Hex( " 0
"itemdef[1] ) " 0
"+ " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"elseif ( " 0
"( " 0
"x == Tarx2 ) && " 0
"( " 0
"y == Tary ) ) // NE corner " 0
BREAK 
"itemdef := GetConfigString( " 0
"cfgrandom[element], " 0
""no" ); " 0
BREAK 
"if ( " 0
"!itemdef ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""NE corner missing." ); " 0
BREAK 
"else " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( " 0
"itemdef ); " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef, " 0
""," ); " 0
BREAK 
"item := CreateItemAtLocation( " 0
"x, " 0
"y, " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z, " 0
"CInt( " 0
"itemdef[1] ), " 0
"1, " 0
"who.realm ); " 0
BREAK 
"if ( " 0
"item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( " 0
"item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Create error! NE-corner Item " + x + " " + y + " " + ( " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z ) + " " + Hex( " 0
"itemdef[1] ) " 0
"+ " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"itemdef := GetConfigString( " 0
"cfgrandom[element], " 0
""no1" ); " 0
BREAK 
"if ( " 0
"( " 0
"itemdef ) && " 0
"( " 0
"itemdef <> {} " 0
") ) " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( " 0
"itemdef ); " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef, " 0
""," ); " 0
BREAK 
"item := CreateItemAtLocation( " 0
"x, " 0
"y, " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z, " 0
"CInt( " 0
"itemdef[1] ), " 0
"1, " 0
"who.realm ); " 0
BREAK 
"if ( " 0
"item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( " 0
"item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Create error! NE-Corner 2nd item " + x + " " + y + " " + ( " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z ) + " " + Hex( " 0
"itemdef[1] ) " 0
"+ " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"elseif ( " 0
"( " 0
"x == Tarx2 ) && " 0
"( " 0
"y == Tary2 ) ) // SE corner " 0
BREAK 
"itemdef := GetConfigString( " 0
"cfgrandom[element], " 0
""so" ); " 0
BREAK 
"if ( " 0
"!itemdef ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""SE-Corner is missing." ); " 0
BREAK 
"else " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( " 0
"itemdef ); " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef, " 0
""," ); " 0
BREAK 
"item := CreateItemAtLocation( " 0
"x, " 0
"y, " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z, " 0
"CInt( " 0
"itemdef[1] ), " 0
"1, " 0
"who.realm ); " 0
BREAK 
"if ( " 0
"item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( " 0
"item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Create error! SO-Ecke Item " + x + " " + y + " " + ( " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z ) + " " + Hex( " 0
"itemdef[1] ) " 0
"+ " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"itemdef := GetConfigString( " 0
"cfgrandom[element], " 0
""so1" ); " 0
BREAK 
"if ( " 0
"( " 0
"itemdef ) && " 0
"( " 0
"itemdef <> {} " 0
") ) " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( " 0
"itemdef ); " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef, " 0
""," ); " 0
BREAK 
"item := CreateItemAtLocation( " 0
"x, " 0
"y, " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z, " 0
"CInt( " 0
"itemdef[1] ), " 0
"1, " 0
"who.realm ); " 0
BREAK 
"if ( " 0
"item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( " 0
"item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Create error! SE-Corner 2nd item " + x + " " + y + " " + ( " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z ) + " " + Hex( " 0
"itemdef[1] ) " 0
"+ " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"elseif ( " 0
"( " 0
"x == Tarx ) && " 0
"( " 0
"y == Tary2 ) ) // SW corner " 0
BREAK 
"itemdef := GetConfigString( " 0
"cfgrandom[element], " 0
""sw" ); " 0
BREAK 
"if ( " 0
"!itemdef ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""SW-Corner is missing." ); " 0
BREAK 
"else " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( " 0
"itemdef ); " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef, " 0
""," ); " 0
BREAK 
"item := CreateItemAtLocation( " 0
"x, " 0
"y, " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z, " 0
"CInt( " 0
"itemdef[1] ), " 0
"1, " 0
"who.realm ); " 0
BREAK 
"if ( " 0
"item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( " 0
"item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Create error! SW-corner Item " + x + " " + y + " " + ( " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z ) + " " + Hex( " 0
"itemdef[1] ) " 0
"+ " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"itemdef := GetConfigString( " 0
"cfgrandom[element], " 0
""sw1" ); " 0
BREAK 
"if ( " 0
"( " 0
"itemdef ) && " 0
"( " 0
"itemdef <> {} " 0
") ) " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( " 0
"itemdef ); " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef, " 0
""," ); " 0
BREAK 
"item := CreateItemAtLocation( " 0
"x, " 0
"y, " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z, " 0
"CInt( " 0
"itemdef[1] ), " 0
"1, " 0
"who.realm ); " 0
BREAK 
"if ( " 0
"item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( " 0
"item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Create error! SW-Corner 2nd item " + x + " " + y + " " + ( " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z ) + " " + Hex( " 0
"itemdef[1] ) " 0
"+ " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"elseif ( " 0
"y == Tary ) // N page " 0
BREAK 
"itemdef := GetConfigString( " 0
"cfgrandom[element], " 0
""n" ); " 0
BREAK 
"if ( " 0
"!itemdef ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""N-Page is missing." ); " 0
BREAK 
"else " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( " 0
"itemdef ); " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef, " 0
""," ); " 0
BREAK 
"item := CreateItemAtLocation( " 0
"x, " 0
"y, " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z, " 0
"CInt( " 0
"itemdef[1] ), " 0
"1, " 0
"who.realm ); " 0
BREAK 
"if ( " 0
"item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( " 0
"item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Create error! N-Item page " + x + " " + y + " " + ( " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z ) + " " + Hex( " 0
"itemdef[1] ) " 0
"+ " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"itemdef := GetConfigString( " 0
"cfgrandom[element], " 0
""n1" ); " 0
BREAK 
"if ( " 0
"( " 0
"itemdef ) && " 0
"( " 0
"itemdef <> {} " 0
") ) " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( " 0
"itemdef ); " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef, " 0
""," ); " 0
BREAK 
"item := CreateItemAtLocation( " 0
"x, " 0
"y, " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z, " 0
"CInt( " 0
"itemdef[1] ), " 0
"1, " 0
"who.realm ); " 0
BREAK 
"if ( " 0
"item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( " 0
"item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Create error! N-Page 2nd item " + x + " " + y + " " + ( " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z ) + " " + Hex( " 0
"itemdef[1] ) " 0
"+ " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"elseif ( " 0
"x == Tarx2 ) // E side " 0
BREAK 
"itemdef := GetConfigString( " 0
"cfgrandom[element], " 0
""o" ); " 0
BREAK 
"if ( " 0
"!itemdef ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""E-side is missing." ); " 0
BREAK 
"else " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( " 0
"itemdef ); " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef, " 0
""," ); " 0
BREAK 
"item := CreateItemAtLocation( " 0
"x, " 0
"y, " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z, " 0
"CInt( " 0
"itemdef[1] ), " 0
"1, " 0
"who.realm ); " 0
BREAK 
"if ( " 0
"item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( " 0
"item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Create error! E-side item " + x + " " + y + " " + ( " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z ) + " " + Hex( " 0
"itemdef[1] ) " 0
"+ " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"itemdef := GetConfigString( " 0
"cfgrandom[element], " 0
""o1" ); " 0
BREAK 
"if ( " 0
"( " 0
"itemdef ) && " 0
"( " 0
"itemdef <> {} " 0
") ) " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( " 0
"itemdef ); " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef, " 0
""," ); " 0
BREAK 
"item := CreateItemAtLocation( " 0
"x, " 0
"y, " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z, " 0
"CInt( " 0
"itemdef[1] ), " 0
"1, " 0
"who.realm ); " 0
BREAK 
"if ( " 0
"item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( " 0
"item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Create error! E-side 2nd item " + x + " " + y + " " + ( " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z ) + " " + Hex( " 0
"itemdef[1] ) " 0
"+ " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"elseif ( " 0
"y == Tary2 ) // S side " 0
BREAK 
"itemdef := GetConfigString( " 0
"cfgrandom[element], " 0
""s" ); " 0
BREAK 
"if ( " 0
"!itemdef ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""S side is missing." ); " 0
BREAK 
"else " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( " 0
"itemdef ); " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef, " 0
""," ); " 0
BREAK 
"item := CreateItemAtLocation( " 0
"x, " 0
"y, " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z, " 0
"CInt( " 0
"itemdef[1] ), " 0
"1, " 0
"who.realm ); " 0
BREAK 
"if ( " 0
"item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( " 0
"item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Create error! S-Item page " + x + " " + y + " " + ( " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z ) + " " + Hex( " 0
"itemdef[1] ) " 0
"+ " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"itemdef := GetConfigString( " 0
"cfgrandom[element], " 0
""s1" ); " 0
BREAK 
"if ( " 0
"( " 0
"itemdef ) && " 0
"( " 0
"itemdef <> {} " 0
") ) " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( " 0
"itemdef ); " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef, " 0
""," ); " 0
BREAK 
"item := CreateItemAtLocation( " 0
"x, " 0
"y, " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z, " 0
"CInt( " 0
"itemdef[1] ), " 0
"1, " 0
"who.realm ); " 0
BREAK 
"if ( " 0
"item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( " 0
"item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Create error! S-side 2nd item " + x + " " + y + " " + ( " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z ) + " " + Hex( " 0
"itemdef[1] ) " 0
"+ " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"elseif ( " 0
"x == Tarx ) // W page " 0
BREAK 
"itemdef := GetConfigString( " 0
"cfgrandom[element], " 0
""w" ); " 0
BREAK 
"if ( " 0
"!itemdef ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""W-Page is missing." ); " 0
BREAK 
"else " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( " 0
"itemdef ); " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef, " 0
""," ); " 0
BREAK 
"item := CreateItemAtLocation( " 0
"x, " 0
"y, " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z, " 0
"CInt( " 0
"itemdef[1] ), " 0
"1, " 0
"who.realm ); " 0
BREAK 
"if ( " 0
"item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( " 0
"item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Create error! W side item " + x + " " + y + " " + ( " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z ) + " " + Hex( " 0
"itemdef[1] ) " 0
"+ " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"itemdef := GetConfigString( " 0
"cfgrandom[element], " 0
""w1" ); " 0
BREAK 
"if ( " 0
"( " 0
"itemdef ) && " 0
"( " 0
"itemdef <> {} " 0
") ) " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef ); " 0
BREAK 
"itemdef := ChooseRandom( " 0
"itemdef ); " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef, " 0
""," ); " 0
BREAK 
"item := CreateItemAtLocation( " 0
"x, " 0
"y, " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z, " 0
"CInt( " 0
"itemdef[1] ), " 0
"1, " 0
"who.realm ); " 0
BREAK 
"if ( " 0
"item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( " 0
"item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Create error! W-Page 2nd item " + x + " " + y + " " + ( " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z ) + " " + Hex( " 0
"itemdef[1] ) " 0
"+ " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"else // centerpiece " 0
BREAK 
"itemdef := ChooseRandom( " 0
"tiles ); " 0
BREAK 
"if ( " 0
"!itemdef ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Middle piece is missing." ); " 0
BREAK 
"else " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef, " 0
""," ); " 0
BREAK 
"item := CreateItemAtLocation( " 0
"x, " 0
"y, " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z, " 0
"CInt( " 0
"itemdef[1] ), " 0
"1, " 0
"who.realm ); " 0
BREAK 
"if ( " 0
"item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( " 0
"item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Create error! Midsection item " + x + " " + y + " " + ( " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z ) + " " + Hex( " 0
"itemdef[1] ) " 0
"+ " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"itemdef := tiles1.randomentry(); " 0
BREAK 
"if ( " 0
"( " 0
"itemdef ) && " 0
"( " 0
"itemdef <> {} " 0
") ) " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef, " 0
""," ); " 0
BREAK 
"item := CreateItemAtLocation( " 0
"x, " 0
"y, " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z, " 0
"CInt( " 0
"itemdef[1] ), " 0
"1, " 0
"who.realm ); " 0
BREAK 
"if ( " 0
"item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( " 0
"item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Create error! Middle part 2nd item " + x + " " + y + " " + ( " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z ) + " " + Hex( " 0
"itemdef[1] ) " 0
"+ " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"5 ); " 0
BREAK 
"endfor " 0
BREAK 
"endfor " 0
BREAK 
"else // Boring version without a border " 0
BREAK 
"for ( " 0
"x := Tarx; " 0
"x <= Tarx2; " 0
"x += 1 ) " 0
BREAK 
"for ( " 0
"y := Tary; " 0
"y <= Tary2; " 0
"y += 1 ) " 0
BREAK 
"itemdef := ChooseRandom( " 0
"tiles ); " 0
BREAK 
"if ( " 0
"!itemdef ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Middle piece is missing." ); " 0
BREAK 
"else " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef, " 0
""," ); " 0
BREAK 
"item := CreateItemAtLocation( " 0
"x, " 0
"y, " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z, " 0
"CInt( " 0
"itemdef[1] ), " 0
"1, " 0
"who.realm ); " 0
BREAK 
"if ( " 0
"item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( " 0
"item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Create error! Item " + x + " " + y + " " + ( " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z ) + " " + Hex( " 0
"itemdef[1] ) " 0
"+ " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"itemdef := tiles1.randomentry(); " 0
BREAK 
"if ( " 0
"( " 0
"itemdef ) && " 0
"( " 0
"itemdef <> {} " 0
") ) " 0
BREAK 
"itemdef := SplitWords( " 0
"itemdef, " 0
""," ); " 0
BREAK 
"item := CreateItemAtLocation( " 0
"x, " 0
"y, " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z, " 0
"CInt( " 0
"itemdef[1] ), " 0
"1, " 0
"who.realm ); " 0
BREAK 
"if ( " 0
"item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"items.append( " 0
"item ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Create error! 2nd Item " + x + " " + y + " " + ( " 0
"tar1.z + CInt( " 0
"itemdef[2] ) " 0
"+ z ) + " " + Hex( " 0
"itemdef[1] ) " 0
"+ " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"5 ); " 0
BREAK 
"endfor " 0
BREAK 
"endfor " 0
BREAK 
"endif " 0
BREAK 
"foreach item in items " 0
BREAK 
"item.setprop( " 0
"CPROP_INIT, " 0
"items[1].serial ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"foreach item in items " 0
BREAK 
"itemserials.append( " 0
"item.serial ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"items[1].setprop( " 0
"CPROP_ITEMS, " 0
"itemserials ); " 0
BREAK 
"if ( " 0
"ret[ITEMMODIFY] ) // Change position " 0
BREAK 
"if ( " 0
"!ModifyItems( " 0
"who, " 0
"items ) " 0
") " 0
BREAK 
"return; " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Abort" ); " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Abort" ); " 0
BREAK 
"endif " 0
BREAK 
"endfunction // }}} " 0
BREAK 
"function CreateEinzel( " 0
"who, " 0
"byref ret, " 0
"byref tiles, " 0
"byref color ) " 0
"// {{{ " 0
BREAK 
"var z, " 0
"itemdef := {}, " 0
"iTarget, " 0
"item, " 0
"items := {}, " 0
"itemserials := {}; " 0
BREAK 
"if ( " 0
"!tiles[ret.keys[2]] ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""No item selected" ); " 0
BREAK 
"return; " 0
BREAK 
"endif " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Target position" ); " 0
BREAK 
"z := ret[ITEMPOS]; " 0
BREAK 
"z[1, " 0
"6] := ""; " 0
BREAK 
"z := CInt( " 0
"z ); " 0
BREAK 
"itemdef[1] := CInt( " 0
"SplitWords( " 0
"tiles[ret.keys[2]], " 0
""," )[" 0
"1] ); " 0
"// Objtype " 0
BREAK 
"itemdef[2] := CInt( " 0
"SplitWords( " 0
"tiles[ret.keys[2]], " 0
""," )[" 0
"2] ); " 0
"// Feste z-Koords " 0
BREAK 
"iTarget := TargetCoordinates( " 0
"who ); " 0
BREAK 
"if ( " 0
"iTarget.item ) " 0
BREAK 
"if ( " 0
"iTarget.item.container ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""cancellation. Item in Container targeted!" ); " 0
BREAK 
"return; " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"while ( " 0
"iTarget ) // Endless to ESC " 0
BREAK 
"item := CreateItemAtLocation( " 0
"iTarget.x, " 0
"iTarget.y, " 0
"iTarget.z + itemdef[2] + z, " 0
"itemdef[1], " 0
"1, " 0
"who.realm ); " 0
BREAK 
"if ( " 0
"item ) " 0
BREAK 
"item.color := color; " 0
BREAK 
"item.movable := 0; " 0
BREAK 
"if ( " 0
"!ret[ITEMMMULTICREATE] ) " 0
BREAK 
"item.setprop( " 0
"CPROP_INIT, " 0
"item.serial ); " 0
BREAK 
"item.setprop( " 0
"CPROP_ITEMS, " 0
"{ " 0
"item.serial } " 0
"); " 0
BREAK 
"if ( " 0
"ret[ITEMMODIFY] ) // Change position " 0
BREAK 
"if ( " 0
"!ModifyItems( " 0
"who, " 0
"item ) " 0
") " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Abort" ); " 0
BREAK 
"return; " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"items.append( " 0
"item ); " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Create error! Item " + iTarget.x + " " + iTarget.y + " " + ( " 0
"iTarget.z + itemdef[2] + z ) + " " + Hex( " 0
"tiles[ret.keys[2]] ) " 0
"+ " ErrorText: " + item.errortext ); " 0
BREAK 
"endif " 0
BREAK 
"iTarget := TargetCoordinates( " 0
"who ); " 0
BREAK 
"endwhile " 0
BREAK 
"if ( " 0
"ret[ITEMMMULTICREATE] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"item.setprop( " 0
"CPROP_INIT, " 0
"items[1].serial ); " 0
BREAK 
"endforeach " 0
BREAK 
"foreach item in items " 0
BREAK 
"itemserials.append( " 0
"item.serial ); " 0
BREAK 
"endforeach " 0
BREAK 
"items[1].setprop( " 0
"CPROP_ITEMS, " 0
"itemserials ); " 0
BREAK 
"if ( " 0
"ret[ITEMMODIFY] ) // Postion to change " 0
BREAK 
"ModifyItems( " 0
"who, " 0
"items ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Abort" ); " 0
BREAK 
"endfunction // }}} " 0
BREAK 
"function CreateSet( " 0
"unused who, " 0
"byref unused ret, " 0
"byref unused set, " 0
"byref unused color ) " 0
BREAK 
"endfunction " 0
BREAK 
"function ModifyItemsManual( " 0
"who ) " 0
"// {{{ " 0
BREAK 
"var retmodify, " 0
"tar, " 0
"inititem, " 0
"items := {}, " 0
"itemserials := {}, " 0
"color, " 0
"zstart, " 0
"zend, " 0
"temp, " 0
"i, " 0
"obj, " 0
"tempitems := {}; " 0
BREAK 
"var tar1, " 0
"tar2, " 0
"x1, " 0
"x2, " 0
"y1, " 0
"y2, " 0
"breakflag; " 0
BREAK 
"var dupe := {}, " 0
"dupeitem, " 0
"dupeserials := {}; " 0
BREAK 
"while ( " 0
"who.connected ) " 0
BREAK 
"if ( " 0
"items <> {} " 0
") " 0
BREAK 
"datamodify_M[COLORDATAPOS] := items[1].color; " 0
BREAK 
"datamodify_M[XKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>" + items[1].x + "</p></basefont>"; " 0
BREAK 
"datamodify_M[YKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>" + items[1].y + "</p></basefont>"; " 0
BREAK 
"datamodify_M[ZKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>" + items[1].z + "</p></basefont>"; " 0
BREAK 
"datamodify_M[XENTRY] := items[1].x; " 0
BREAK 
"datamodify_M[YENTRY] := items[1].y; " 0
BREAK 
"datamodify_M[ZENTRY] := items[1].z; " 0
BREAK 
"else " 0
BREAK 
"datamodify_M[COLORDATAPOS] := "0"; " 0
BREAK 
"datamodify_M[XKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>x</p></basefont>"; " 0
BREAK 
"datamodify_M[YKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>y</p></basefont>"; " 0
BREAK 
"datamodify_M[ZKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>z</p></basefont>"; " 0
BREAK 
"datamodify_M[XENTRY] := 0; " 0
BREAK 
"datamodify_M[YENTRY] := 0; " 0
BREAK 
"datamodify_M[ZENTRY] := 0; " 0
BREAK 
"endif " 0
BREAK 
"retmodify := SendDialogGump( " 0
"who, " 0
"layoutmodify_M, " 0
"datamodify_M, " 0
"10, " 0
"50 ); " 0
BREAK 
"if ( " 0
"retmodify[MODIFY_START] ) " 0
BREAK 
"if ( " 0
"!retmodify[MODIFY_CUSTOM] ) // Search for .bautool items " 0
BREAK 
"tar := Target( " 0
"who, " 0
"TGTOPT_NOCHECK_LOS ); " 0
BREAK 
"if ( " 0
"tar ) " 0
BREAK 
"if ( " 0
"( " 0
"!tar.getprop( " 0
"CPROP_ITEMS ) " 0
") && " 0
"( " 0
"tar.getprop( " 0
"CPROP_INIT ) " 0
") ) " 0
BREAK 
"inititem := SystemFindObjectBySerial( " 0
"tar.getprop( " 0
"CPROP_INIT ) " 0
"); " 0
BREAK 
"if ( " 0
"inititem ) " 0
BREAK 
"itemserials := inititem.getprop( " 0
"CPROP_ITEMS ); " 0
BREAK 
"items := {}; " 0
BREAK 
"tempitems := {}; " 0
BREAK 
"foreach item in itemserials " 0
BREAK 
"obj := SystemFindObjectBySerial( " 0
"item ); " 0
BREAK 
"if ( " 0
"obj ) " 0
BREAK 
"if ( " 0
"CInt( " 0
"obj.getprop( " 0
"CPROP_INIT ) " 0
") " 0
"== CInt( " 0
"inititem.serial ) " 0
") // it belongs to the same group " 0
BREAK 
"items.append( " 0
"obj ); " 0
BREAK 
"tempitems.append( " 0
"obj.serial ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"inititem.setprop( " 0
"CPROP_ITEMS, " 0
"tempitems ); " 0
"// save filtered serials " 0
BREAK 
"if ( " 0
"( " 0
"!items ) || " 0
"( " 0
"items == {} " 0
") ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Items could not be found. " ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
"items.size() " 0
"+ " Items recognized." ); " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Init item not found. " ); " 0
BREAK 
"items := RecoverInitItem( " 0
"tar ); " 0
BREAK 
"endif " 0
BREAK 
"elseif ( " 0
"tar.getprop( " 0
"CPROP_ITEMS ) " 0
") " 0
BREAK 
"itemserials := tar.getprop( " 0
"CPROP_ITEMS ); " 0
BREAK 
"items := {}; " 0
BREAK 
"tempitems := {}; " 0
BREAK 
"foreach item in itemserials " 0
BREAK 
"obj := SystemFindObjectBySerial( " 0
"item ); " 0
BREAK 
"if ( " 0
"obj ) " 0
BREAK 
"if ( " 0
"CInt( " 0
"obj.getprop( " 0
"CPROP_INIT ) " 0
") " 0
"== CInt( " 0
"tar.serial ) " 0
") // it belongs to the same group " 0
BREAK 
"items.append( " 0
"obj ); " 0
BREAK 
"tempitems.append( " 0
"obj.serial ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"tar.setprop( " 0
"CPROP_ITEMS, " 0
"tempitems ); " 0
"// save filtered serials " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
"items.size() " 0
"+ " Items recognized." ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Invalid Item selected." ); " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Abort" ); " 0
BREAK 
"items := {}; " 0
BREAK 
"endif " 0
BREAK 
"else // Search for any items " 0
BREAK 
"zstart := retmodify[MODIFY_Z_START]; " 0
BREAK 
"zstart[1, " 0
"6] := ""; " 0
BREAK 
"zstart := CInt( " 0
"zstart ); " 0
BREAK 
"zend := retmodify[MODIFY_Z_END]; " 0
BREAK 
"zend[1, " 0
"6] := ""; " 0
BREAK 
"zend := CInt( " 0
"zend ); " 0
BREAK 
"datamodify_M[ZSTARTPOS] := zstart; " 0
BREAK 
"datamodify_M[ZENDPOS] := zend; " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Target the first corner of the area" ); " 0
BREAK 
"tar1 := TargetCoordinates( " 0
"who ); " 0
BREAK 
"if ( " 0
"tar1 ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Target the second corner of the area" ); " 0
BREAK 
"tar2 := TargetCoordinates( " 0
"who ); " 0
BREAK 
"if ( " 0
"tar2 ) " 0
BREAK 
"if ( " 0
"tar1.x > tar2.x ) // Sorting the area " 0
BREAK 
"x1 := tar2.x; " 0
BREAK 
"x2 := tar1.x; " 0
BREAK 
"else " 0
BREAK 
"x1 := tar1.x; " 0
BREAK 
"x2 := tar2.x; " 0
BREAK 
"endif " 0
BREAK 
"if ( " 0
"tar1.y > tar2.y ) " 0
BREAK 
"y1 := tar2.y; " 0
BREAK 
"y2 := tar1.y; " 0
BREAK 
"else " 0
BREAK 
"y1 := tar1.y; " 0
BREAK 
"y2 := tar2.y; " 0
BREAK 
"endif " 0
BREAK 
"items := {}; " 0
BREAK 
"foreach item in ListObjectsInBox( " 0
"x1, " 0
"y1, " 0
"zstart, " 0
"x2, " 0
"y2, " 0
"zend, " 0
"tar2.realm ) " 0
BREAK 
"if ( " 0
"item.isA( " 0
"POLCLASS_ITEM ) " 0
") " 0
BREAK 
"if ( " 0
"!item.invisible ) // Don't take invisible stuff like spawn runes " 0
BREAK 
"items.append( " 0
"item ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"if ( " 0
"items <> {} " 0
") " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
"items.size() " 0
"+ " Items recognized." ); " 0
BREAK 
"if ( " 0
"retmodify[MODIFY_MARK] ) " 0
BREAK 
"itemserials := {}; " 0
BREAK 
"foreach item in items " 0
BREAK 
"itemserials.append( " 0
"item.serial ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Choose the original item." ); " 0
BREAK 
"breakflag := 0; " 0
BREAK 
"while ( " 0
"who.connected ) " 0
BREAK 
"tar := Target( " 0
"who, " 0
"TGTOPT_NOCHECK_LOS ); " 0
BREAK 
"if ( " 0
"tar ) " 0
BREAK 
"i := tar.serial in itemserials; " 0
BREAK 
"if ( " 0
"i ) // Move the selected item to the first position " 0
BREAK 
"temp := itemserials[1]; " 0
BREAK 
"itemserials[i] := temp; " 0
BREAK 
"itemserials[1] := tar.serial; " 0
BREAK 
"foreach item in items " 0
BREAK 
"item.setprop( " 0
"CPROP_INIT, " 0
"tar.serial ); " 0
BREAK 
"item.eraseprop( " 0
"CPROP_ITEMS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"tar.setprop( " 0
"CPROP_ITEMS, " 0
"itemserials ); " 0
BREAK 
"break;" 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Item is not among those recognized!" ); " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Abort" ); " 0
BREAK 
"breakflag := 1; " 0
BREAK 
"break;" 0
BREAK 
"endif " 0
BREAK 
"endwhile " 0
BREAK 
"items := {}; " 0
BREAK 
"if ( " 0
"!breakflag ) " 0
BREAK 
"foreach item in itemserials // Reordering and final check " 0
BREAK 
"obj := SystemFindObjectBySerial( " 0
"item ); " 0
BREAK 
"if ( " 0
"obj ) " 0
BREAK 
"items.append( " 0
"obj ); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
"".. and branded." ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""No items recognized." ); " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Abort" ); " 0
BREAK 
"items := {}; " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Abort" ); " 0
BREAK 
"items := {}; " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"if ( " 0
"retmodify.keys[retmodify.keys.size()] " 0
"> MODIFY_START ) " 0
BREAK 
"if ( " 0
"items <> {} " 0
") " 0
BREAK 
"if ( " 0
"retmodify[MODIFY_Y_UP] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x, " 0
"item.y + 1, " 0
"item.z, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_Y_DOWN] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x, " 0
"item.y - 1, " 0
"item.z, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_X_UP] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x + 1, " 0
"item.y, " 0
"item.z, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_X_DOWN] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x - 1, " 0
"item.y, " 0
"item.z, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_XY_MM] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x - 1, " 0
"item.y - 1, " 0
"item.z, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_XY_PM] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x + 1, " 0
"item.y - 1, " 0
"item.z, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_XY_MP] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x - 1, " 0
"item.y + 1, " 0
"item.z, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_XY_PP] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x + 1, " 0
"item.y + 1, " 0
"item.z, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_Z_UP] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x, " 0
"item.y, " 0
"item.z + 1, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_Z_DOWN] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x, " 0
"item.y, " 0
"item.z - 1, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_DESTROY] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"DestroyItem( " 0
"item ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"items := {}; " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_COLOR] ) " 0
BREAK 
"color := retmodify[ITEMCOLOR]; " 0
BREAK 
"color[1, " 0
"6] := ""; " 0
BREAK 
"color := CInt( " 0
"color ); " 0
BREAK 
"foreach item in items " 0
BREAK 
"item.color := color; " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_DUPE] ) " 0
BREAK 
"dupe := {}; " 0
BREAK 
"dupeserials := {}; " 0
BREAK 
"foreach item in items " 0
BREAK 
"dupeitem := CreateItemCopyAtLocation( " 0
"item.x, " 0
"item.y, " 0
"item.z, " 0
"item, " 0
"item.realm ); " 0
BREAK 
"if ( " 0
"dupeitem ) " 0
BREAK 
"dupe.append( " 0
"dupeitem ); " 0
BREAK 
"dupeserials.append( " 0
"dupeitem.serial ); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"foreach item in dupe " 0
BREAK 
"item.setprop( " 0
"CPROP_INIT, " 0
"dupeserials[1] ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"dupe[1].setprop( " 0
"CPROP_ITEMS, " 0
"dupeserials ); " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
"dupe.size() " 0
"+ " Items successfully duplicated." ); " 0
BREAK 
"items := dupe; " 0
"// Continue working with a copy " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_X] ) " 0
BREAK 
"temp := retmodify[MODIFY_X_ENTRY]; " 0
BREAK 
"temp[1, " 0
"6] := ""; " 0
BREAK 
"temp := CInt( " 0
"temp ) " 0
"- items[1].x; " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x + temp, " 0
"item.y, " 0
"item.z, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_Y] ) " 0
BREAK 
"temp := retmodify[MODIFY_Y_ENTRY]; " 0
BREAK 
"temp[1, " 0
"6] := ""; " 0
BREAK 
"temp := CInt( " 0
"temp ) " 0
"- items[1].y; " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x, " 0
"item.y + temp, " 0
"item.z, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_Z] ) " 0
BREAK 
"temp := retmodify[MODIFY_Z_ENTRY]; " 0
BREAK 
"temp[1, " 0
"6] := ""; " 0
BREAK 
"temp := CInt( " 0
"temp ) " 0
"- items[1].z; " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x, " 0
"item.y, " 0
"item.z + temp, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""No items selected." ); " 0
BREAK 
"endif " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_MARKEDIT] ) " 0
BREAK 
"MarkEdit( " 0
"who ); " 0
BREAK 
"else // Gump closed " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Abort" ); " 0
BREAK 
"break;" 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"endwhile " 0
BREAK 
"endfunction // }}} " 0
BREAK 
"function MarkEdit( " 0
"who ) " 0
"// {{{ " 0
BREAK 
"var ret, " 0
"tar1, " 0
"tar2, " 0
"x1, " 0
"x2, " 0
"y1, " 0
"y2, " 0
"items := {}, " 0
"itemref, " 0
"inititem, " 0
"itemserials, " 0
"tempitems, " 0
"obj, " 0
"i; " 0
BREAK 
"while ( " 0
"who.connected ) " 0
BREAK 
"ret := SendDialogGump( " 0
"who, " 0
"layoutmark, " 0
"datamark, " 0
"10, " 0
"50 ); " 0
BREAK 
"if ( " 0
"ret[MARK_SHOW] ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Target the first corner of the area" ); " 0
BREAK 
"tar1 := TargetCoordinates( " 0
"who ); " 0
BREAK 
"if ( " 0
"tar1 ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Target the second corner of the area" ); " 0
BREAK 
"tar2 := TargetCoordinates( " 0
"who ); " 0
BREAK 
"if ( " 0
"tar2 ) " 0
BREAK 
"if ( " 0
"tar1.x > tar2.x ) // Sorting the area " 0
BREAK 
"x1 := tar2.x; " 0
BREAK 
"x2 := tar1.x; " 0
BREAK 
"else " 0
BREAK 
"x1 := tar1.x; " 0
BREAK 
"x2 := tar2.x; " 0
BREAK 
"endif " 0
BREAK 
"if ( " 0
"tar1.y > tar2.y ) " 0
BREAK 
"y1 := tar2.y; " 0
BREAK 
"y2 := tar1.y; " 0
BREAK 
"else " 0
BREAK 
"y1 := tar1.y; " 0
BREAK 
"y2 := tar2.y; " 0
BREAK 
"endif " 0
BREAK 
"items := {}; " 0
BREAK 
"foreach item in ListObjectsInBox( " 0
"x1, " 0
"y1, " 0
"-127, " 0
"x2, " 0
"y2, " 0
"128, " 0
"tar2.realm ) " 0
BREAK 
"if ( " 0
"item.isA( " 0
"POLCLASS_ITEM ) " 0
") " 0
BREAK 
"if ( " 0
"item.getprop( " 0
"CPROP_ITEMS ) " 0
") " 0
BREAK 
"items.append( " 0
"item ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"if ( " 0
"items <> {} " 0
") " 0
BREAK 
"foreach item in items // Coloring by groups " 0
BREAK 
"foreach slaveitem in ( " 0
"item.getprop( " 0
"CPROP_ITEMS ) " 0
") " 0
BREAK 
"itemref := SystemFindObjectBySerial( " 0
"slaveitem ); " 0
BREAK 
"if ( " 0
"itemref ) " 0
BREAK 
"if ( " 0
"itemref.getprop( " 0
"CPROP_COLOR )." 0
"errortext ) " 0
BREAK 
"itemref.setprop( " 0
"CPROP_COLOR, " 0
"itemref.color ); " 0
BREAK 
"endif " 0
BREAK 
"itemref.color := _item_iter + 6; " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"elseif ( " 0
"ret[MARK_HIDE] ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Target the first corner of the area" ); " 0
BREAK 
"tar1 := TargetCoordinates( " 0
"who ); " 0
BREAK 
"if ( " 0
"tar1 ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Target the second corner of the area" ); " 0
BREAK 
"tar2 := TargetCoordinates( " 0
"who ); " 0
BREAK 
"if ( " 0
"tar2 ) " 0
BREAK 
"if ( " 0
"tar1.x > tar2.x ) // Sorting the area " 0
BREAK 
"x1 := tar2.x; " 0
BREAK 
"x2 := tar1.x; " 0
BREAK 
"else " 0
BREAK 
"x1 := tar1.x; " 0
BREAK 
"x2 := tar2.x; " 0
BREAK 
"endif " 0
BREAK 
"if ( " 0
"tar1.y > tar2.y ) " 0
BREAK 
"y1 := tar2.y; " 0
BREAK 
"y2 := tar1.y; " 0
BREAK 
"else " 0
BREAK 
"y1 := tar1.y; " 0
BREAK 
"y2 := tar2.y; " 0
BREAK 
"endif " 0
BREAK 
"items := {}; " 0
BREAK 
"foreach item in ListObjectsInBox( " 0
"x1, " 0
"y1, " 0
"-127, " 0
"x2, " 0
"y2, " 0
"128, " 0
"tar2.realm ) " 0
BREAK 
"if ( " 0
"item.isA( " 0
"POLCLASS_ITEM ) " 0
") " 0
BREAK 
"if ( " 0
"item.getprop( " 0
"CPROP_ITEMS ) " 0
") " 0
BREAK 
"items.append( " 0
"item ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"if ( " 0
"items <> {} " 0
") " 0
BREAK 
"foreach item in items // Coloring by groups " 0
BREAK 
"foreach slaveitem in ( " 0
"item.getprop( " 0
"CPROP_ITEMS ) " 0
") " 0
BREAK 
"itemref := SystemFindObjectBySerial( " 0
"slaveitem ); " 0
BREAK 
"if ( " 0
"itemref ) " 0
BREAK 
"if ( " 0
"itemref.getprop( " 0
"CPROP_COLOR )." 0
"errortext ) " 0
BREAK 
"itemref.setprop( " 0
"CPROP_COLOR, " 0
"itemref.color ); " 0
BREAK 
"endif " 0
BREAK 
"itemref.color := _item_iter + 6; " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"foreach item in ListObjectsInBox( " 0
"x1, " 0
"y1, " 0
"-128, " 0
"x2, " 0
"y2, " 0
"127, " 0
"tar2.realm ) " 0
BREAK 
"if ( " 0
"item.isA( " 0
"POLCLASS_ITEM ) " 0
") " 0
BREAK 
"if ( " 0
"( " 0
"item.getprop( " 0
"CPROP_ITEMS ) " 0
") && " 0
"( " 0
"!item.getprop( " 0
"CPROP_COLOR )." 0
"errortext ) ) " 0
BREAK 
"foreach slaveitem in ( " 0
"item.getprop( " 0
"CPROP_ITEMS ) " 0
") " 0
BREAK 
"itemref := SystemFindObjectBySerial( " 0
"slaveitem ); " 0
BREAK 
"if ( " 0
"itemref ) " 0
BREAK 
"if ( " 0
"!itemref.getprop( " 0
"CPROP_COLOR )." 0
"errortext ) " 0
BREAK 
"itemref.color := CInt( " 0
"item.getprop( " 0
"CPROP_COLOR ) " 0
"); " 0
BREAK 
"itemref.eraseprop( " 0
"CPROP_COLOR ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"elseif ( " 0
"ret[MARK_EDIT] ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Selects the item group." ); " 0
BREAK 
"tar1 := Target( " 0
"who, " 0
"TGTOPT_NOCHECK_LOS ); " 0
BREAK 
"items := {}; " 0
BREAK 
"tempitems := {}; " 0
BREAK 
"if ( " 0
"( " 0
"!tar1.getprop( " 0
"CPROP_ITEMS ) " 0
") && " 0
"( " 0
"tar1.getprop( " 0
"CPROP_INIT ) " 0
") ) " 0
BREAK 
"inititem := SystemFindObjectBySerial( " 0
"tar1.getprop( " 0
"CPROP_INIT ) " 0
"); " 0
BREAK 
"if ( " 0
"inititem ) " 0
BREAK 
"itemserials := inititem.getprop( " 0
"CPROP_ITEMS ); " 0
BREAK 
"foreach item in itemserials " 0
BREAK 
"obj := SystemFindObjectBySerial( " 0
"item ); " 0
BREAK 
"if ( " 0
"obj ) " 0
BREAK 
"if ( " 0
"( " 0
"CInt( " 0
"obj.getprop( " 0
"CPROP_INIT ) " 0
") " 0
"== CInt( " 0
"inititem.serial ) " 0
") && " 0
"( " 0
"!( " 0
"obj.serial in tempitems ) ) ) // it belongs to the same group " 0
BREAK 
"items.append( " 0
"obj ); " 0
BREAK 
"tempitems.append( " 0
"obj.serial ); " 0
BREAK 
"if ( " 0
"obj.getprop( " 0
"CPROP_COLOR )." 0
"errortext ) " 0
BREAK 
"obj.setprop( " 0
"CPROP_COLOR, " 0
"obj.color ); " 0
BREAK 
"endif " 0
BREAK 
"obj.color := 1281; " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"inititem.setprop( " 0
"CPROP_ITEMS, " 0
"tempitems ); " 0
"// save filtered serials " 0
BREAK 
"if ( " 0
"( " 0
"!items ) || " 0
"( " 0
"items == {} " 0
") ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Items could not be found. " ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
"items.size() " 0
"+ " Items recognized." ); " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Init item not found. " ); " 0
BREAK 
"items := RecoverInitItem( " 0
"tar1 ); " 0
BREAK 
"endif " 0
BREAK 
"elseif ( " 0
"tar1.getprop( " 0
"CPROP_ITEMS ) " 0
") " 0
BREAK 
"itemserials := tar1.getprop( " 0
"CPROP_ITEMS ); " 0
BREAK 
"foreach item in itemserials " 0
BREAK 
"obj := SystemFindObjectBySerial( " 0
"item ); " 0
BREAK 
"if ( " 0
"obj ) " 0
BREAK 
"if ( " 0
"CInt( " 0
"obj.getprop( " 0
"CPROP_INIT ) " 0
") " 0
"== CInt( " 0
"tar1.serial ) " 0
") // it belongs to the same group " 0
BREAK 
"items.append( " 0
"obj ); " 0
BREAK 
"tempitems.append( " 0
"obj.serial ); " 0
BREAK 
"if ( " 0
"obj.getprop( " 0
"CPROP_COLOR )." 0
"errortext ) " 0
BREAK 
"obj.setprop( " 0
"CPROP_COLOR, " 0
"obj.color ); " 0
BREAK 
"endif " 0
BREAK 
"obj.color := 1281; " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"tar1.setprop( " 0
"CPROP_ITEMS, " 0
"tempitems ); " 0
"// save filtered serials " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
"items.size() " 0
"+ " Items recognized." ); " 0
BREAK 
"else " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""No items recognized." ); " 0
BREAK 
"endif " 0
BREAK 
"if ( " 0
"items <> {} " 0
") " 0
BREAK 
"while ( " 0
"who.connected ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Selects the item to be added / removed." ); " 0
BREAK 
"tar1 := Target( " 0
"who, " 0
"TGTOPT_NOCHECK_LOS ); " 0
BREAK 
"if ( " 0
"( " 0
"!tar1 ) && " 0
"( " 0
"!tar1.isA( " 0
"POLCLASS_ITEM ) " 0
") ) " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Abort" ); " 0
BREAK 
"break;" 0
BREAK 
"endif " 0
BREAK 
"i := tar1.serial in tempitems; " 0
BREAK 
"if ( " 0
"i ) // Remove from group " 0
BREAK 
"tempitems.erase( " 0
"i ); " 0
BREAK 
"items.erase( " 0
"i ); " 0
BREAK 
"tar1.eraseprop( " 0
"CPROP_INIT ); " 0
BREAK 
"tar1.eraseprop( " 0
"CPROP_ITEMS ); " 0
BREAK 
"if ( " 0
"!tar1.getprop( " 0
"CPROP_COLOR )." 0
"errortext ) " 0
BREAK 
"tar1.color := CInt( " 0
"tar1.getprop( " 0
"CPROP_COLOR ) " 0
"); " 0
BREAK 
"tar1.eraseprop( " 0
"CPROP_COLOR ); " 0
BREAK 
"endif " 0
BREAK 
"else // Add " 0
BREAK 
"if ( " 0
"tar1.getprop( " 0
"CPROP_COLOR )." 0
"errortext ) " 0
BREAK 
"tar1.setprop( " 0
"CPROP_COLOR, " 0
"tar1.color ); " 0
BREAK 
"endif " 0
BREAK 
"tar1.color := items[1].color; " 0
BREAK 
"tempitems.append( " 0
"tar1.serial ); " 0
BREAK 
"items.append( " 0
"tar1 ); " 0
BREAK 
"endif " 0
BREAK 
"endwhile " 0
BREAK 
"foreach item in items " 0
BREAK 
"item.setprop( " 0
"CPROP_INIT, " 0
"items[1].serial ); " 0
BREAK 
"item.eraseprop( " 0
"CPROP_ITEMS ); " 0
BREAK 
"endforeach " 0
BREAK 
"items[1].setprop( " 0
"CPROP_ITEMS, " 0
"tempitems ); " 0
BREAK 
"foreach item in items " 0
BREAK 
"if ( " 0
"!item.getprop( " 0
"CPROP_COLOR )." 0
"errortext ) " 0
BREAK 
"item.color := CInt( " 0
"item.getprop( " 0
"CPROP_COLOR ) " 0
"); " 0
BREAK 
"item.eraseprop( " 0
"CPROP_COLOR ); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"1 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"else " 0
BREAK 
"if ( " 0
"x1 ) // If something has been done, reset the color " 0
BREAK 
"foreach item in ListObjectsInBox( " 0
"x1, " 0
"y1, " 0
"-128, " 0
"x2, " 0
"y2, " 0
"127, " 0
"tar2.realm ) " 0
BREAK 
"if ( " 0
"item.isA( " 0
"POLCLASS_ITEM ) " 0
") " 0
BREAK 
"if ( " 0
"( " 0
"item.getprop( " 0
"CPROP_ITEMS ) " 0
") && " 0
"( " 0
"!item.getprop( " 0
"CPROP_COLOR )." 0
"errortext ) ) " 0
BREAK 
"foreach slaveitem in ( " 0
"item.getprop( " 0
"CPROP_ITEMS ) " 0
") " 0
BREAK 
"itemref := SystemFindObjectBySerial( " 0
"slaveitem ); " 0
BREAK 
"if ( " 0
"itemref ) " 0
BREAK 
"if ( " 0
"!itemref.getprop( " 0
"CPROP_COLOR )." 0
"errortext ) " 0
BREAK 
"itemref.color := CInt( " 0
"item.getprop( " 0
"CPROP_COLOR ) " 0
"); " 0
BREAK 
"itemref.eraseprop( " 0
"CPROP_COLOR ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"5 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
""Abort" ); " 0
BREAK 
"return; " 0
BREAK 
"endif " 0
BREAK 
"endwhile " 0
BREAK 
"endfunction // }}} " 0
BREAK 
"function ModifyItems( " 0
"who, " 0
"byref items ) " 0
"// {{{ " 0
BREAK 
"var retmodify, " 0
"color, " 0
"temp, " 0
"dupe := {}, " 0
"dupeitem, " 0
"dupeserials := {}; " 0
BREAK 
"if ( " 0
"TypeOfInt( " 0
"items ) " 0
"!= OT_ARRAY ) " 0
BREAK 
"temp := items; " 0
BREAK 
"items := {}; " 0
BREAK 
"items.append( " 0
"temp ); " 0
BREAK 
"endif " 0
BREAK 
"while ( " 0
"who.connected ) " 0
BREAK 
"datamodify[COLORDATAPOS] := items[1].color; " 0
BREAK 
"datamodify[XKOORDSPOS] := "<basefont color=" + HTML_WHITE + "><p align=right>" + items[1].x + "</p></basefont>"; " 0
BREAK 
"datamodify[YKOORDSPOS] := "<basefont color=" + HTML_WHITE + "><p align=right>" + items[1].y + "</p></basefont>"; " 0
BREAK 
"datamodify[ZKOORDSPOS] := "<basefont color=" + HTML_WHITE + "><p align=right>" + items[1].z + "</p></basefont>"; " 0
BREAK 
"datamodify[XENTRY] := items[1].x; " 0
BREAK 
"datamodify[YENTRY] := items[1].y; " 0
BREAK 
"datamodify[ZENTRY] := items[1].z; " 0
BREAK 
"retmodify := SendDialogGump( " 0
"who, " 0
"layoutmodify, " 0
"datamodify, " 0
"10, " 0
"50 ); " 0
BREAK 
"if ( " 0
"retmodify[MODIFY_Y_UP] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x, " 0
"item.y + 1, " 0
"item.z, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_Y_DOWN] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x, " 0
"item.y - 1, " 0
"item.z, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_X_UP] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x + 1, " 0
"item.y, " 0
"item.z, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_X_DOWN] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x - 1, " 0
"item.y, " 0
"item.z, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_XY_MM] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x - 1, " 0
"item.y - 1, " 0
"item.z, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_XY_PM] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x + 1, " 0
"item.y - 1, " 0
"item.z, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_XY_MP] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x - 1, " 0
"item.y + 1, " 0
"item.z, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_XY_PP] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x + 1, " 0
"item.y + 1, " 0
"item.z, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_Z_UP] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x, " 0
"item.y, " 0
"item.z + 1, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_Z_DOWN] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x, " 0
"item.y, " 0
"item.z - 1, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_DESTROY] ) " 0
BREAK 
"foreach item in items " 0
BREAK 
"DestroyItem( " 0
"item ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"break;" 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_COLOR] ) " 0
BREAK 
"color := retmodify[ITEMCOLOR]; " 0
BREAK 
"color[1, " 0
"6] := ""; " 0
BREAK 
"color := CInt( " 0
"color ); " 0
BREAK 
"foreach item in items " 0
BREAK 
"item.color := color; " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_DUPE] ) " 0
BREAK 
"dupe := {}; " 0
BREAK 
"dupeserials := {}; " 0
BREAK 
"foreach item in items " 0
BREAK 
"dupeitem := CreateItemCopyAtLocation( " 0
"item.x, " 0
"item.y, " 0
"item.z, " 0
"item, " 0
"item.realm ); " 0
BREAK 
"if ( " 0
"dupeitem ) " 0
BREAK 
"dupe.append( " 0
"dupeitem ); " 0
BREAK 
"dupeserials.append( " 0
"dupeitem.serial ); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"foreach item in dupe " 0
BREAK 
"item.setprop( " 0
"CPROP_INIT, " 0
"dupeserials[1] ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"dupe[1].setprop( " 0
"CPROP_ITEMS, " 0
"dupeserials ); " 0
BREAK 
"SendSysMessage( " 0
"who, " 0
"dupe.size() " 0
"+ " Items successfully duplicated." ); " 0
BREAK 
"items := dupe; " 0
"// Edit copy further " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_X] ) " 0
BREAK 
"temp := retmodify[MODIFY_X_ENTRY]; " 0
BREAK 
"temp[1, " 0
"6] := ""; " 0
BREAK 
"temp := CInt( " 0
"temp ) " 0
"- items[1].x; " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x + temp, " 0
"item.y, " 0
"item.z, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_Y] ) " 0
BREAK 
"temp := retmodify[MODIFY_Y_ENTRY]; " 0
BREAK 
"temp[1, " 0
"6] := ""; " 0
BREAK 
"temp := CInt( " 0
"temp ) " 0
"- items[1].y; " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x, " 0
"item.y + temp, " 0
"item.z, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[MODIFY_Z] ) " 0
BREAK 
"temp := retmodify[MODIFY_Z_ENTRY]; " 0
BREAK 
"temp[1, " 0
"6] := ""; " 0
BREAK 
"temp := CInt( " 0
"temp ) " 0
"- items[1].z; " 0
BREAK 
"foreach item in items " 0
BREAK 
"MoveObjectToLocation( " 0
"item, " 0
"item.x, " 0
"item.y, " 0
"item.z + temp, " 0
"item.realm, " 0
"ITEMMOVEFLAGS ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"elseif ( " 0
"retmodify[BACKBUTTON] ) " 0
BREAK 
"break;" 0
BREAK 
"else " 0
BREAK 
"return ( " 0
"0 ); " 0
"// Abbruch " 0
BREAK 
"endif " 0
BREAK 
"endwhile " 0
BREAK 
"return ( " 0
"1 ); " 0
BREAK 
"endfunction // }}} " 0
BREAK 
"function ChooseRandom( " 0
"byref liste ) " 0
"// {{{ " 0
BREAK 
"var verteilung := 0, " 0
"i; " 0
BREAK 
"var rand := RandomInt( " 0
"100 ) " 0
"+ 1; " 0
BREAK 
"if ( " 0
"Find( " 0
"liste[1], " 0
""%", " 0
"1 ) " 0
") // Distribution according to Cfg " 0
BREAK 
"for ( " 0
"i := 1; " 0
"i <= liste.size(); " 0
"i += 1 ) " 0
BREAK 
"verteilung += CInt( " 0
"SplitWords( " 0
"liste[i], " 0
""%" )[" 0
"2] ); " 0
BREAK 
"if ( " 0
"rand <= verteilung ) " 0
BREAK 
"return ( " 0
"SplitWords( " 0
"liste[i], " 0
""%" )[" 0
"1] ); " 0
BREAK 
"endif " 0
BREAK 
"endfor " 0
BREAK 
"else // Gleichverteilt " 0
BREAK 
"verteilung := CInt( " 0
"100 / liste.size() " 0
"); " 0
BREAK 
"for ( " 0
"i := 1; " 0
"i <= liste.size(); " 0
"i += 1 ) " 0
BREAK 
"if ( " 0
"rand <= ( " 0
"i * verteilung ) ) // within the probability? " 0
BREAK 
"return ( " 0
"liste[i] ); " 0
"// Shoo Shoo " 0
BREAK 
"endif " 0
BREAK 
"endfor " 0
BREAK 
"endif " 0
BREAK 
"return ( " 0
"liste.randomentry() " 0
"); " 0
"// well then just like that " 0
BREAK 
"endfunction // }}} " 0
BREAK 
"function MenuBar( " 0
"byref layout, " 0
"byref data, " 0
"byref datadict ) " 0
"// {{{ " 0
BREAK 
"var i, " 0
"page := 1, " 0
"y := 66, " 0
"nextpagebreak := MAXBUTTON + 1; " 0
BREAK 
"if ( " 0
"TypeOfInt( " 0
"datadict ) " 0
"== OT_DICTIONARY ) // Data in dictionary or array " 0
BREAK 
"for ( " 0
"i := 1; " 0
"i <= datadict.keys()." 0
"size(); " 0
"i += 1 ) " 0
BREAK 
"if ( " 0
"i == nextpagebreak ) " 0
BREAK 
"nextpagebreak += MAXBUTTON; " 0
BREAK 
"y := 66; " 0
BREAK 
"page += 1; " 0
BREAK 
"layout.append( " 0
""button 565 287 5602 5606 0 " + page ); " 0
BREAK 
"layout.append( " 0
""page " + page ); " 0
BREAK 
"layout.append( " 0
""button 580 287 5600 5604 0 " + ( " 0
"page - 1 ) ); " 0
BREAK 
"endif " 0
BREAK 
"layout.append( " 0
""button 525 " + ( " 0
"y ) + " 2440 2440 1 0 " + ( " 0
"MENUSTART + i ) ); " 0
BREAK 
"layout.append( " 0
""htmlgump 525 " + ( " 0
"y ) + " 166 25 " + data.size() " 0
"+ " 1 0" ); " 0
BREAK 
"if ( " 0
"( " 0
"cfgrandom[datadict.keys()[" 0
"i]] ) && " 0
"( " 0
"cfgrandom[datadict.keys()[" 0
"i]].name ) ) " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_DARKGRAY + "><center>" + cfgrandom[datadict.keys()[" 0
"i]].name + "</center>" ); " 0
BREAK 
"elseif ( " 0
"( " 0
"cfgeinzel[datadict.keys()[" 0
"i]] ) && " 0
"( " 0
"cfgeinzel[datadict.keys()[" 0
"i]].name ) ) " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_DARKBLUE + "><center>" + cfgeinzel[datadict.keys()[" 0
"i]].name + "</center>" ); " 0
BREAK 
"elseif ( " 0
"cfgset[datadict.keys()[" 0
"i]].name ) " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_DARKBLUE + "><center>" + cfgset[datadict.keys()[" 0
"i]].name + "</center>" ); " 0
BREAK 
"else " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_DARKGRAY + "><center>" + datadict.keys()[" 0
"i] + "</center>" ); " 0
BREAK 
"endif " 0
BREAK 
"y += 30; " 0
BREAK 
"endfor " 0
BREAK 
"else " 0
BREAK 
"for ( " 0
"i := 1; " 0
"i <= datadict.size(); " 0
"i += 1 ) " 0
BREAK 
"if ( " 0
"i == nextpagebreak ) " 0
BREAK 
"nextpagebreak += MAXBUTTON; " 0
BREAK 
"y := 66; " 0
BREAK 
"page += 1; " 0
BREAK 
"layout.append( " 0
""button 565 287 5602 5606 0 " + page + " 0" ); " 0
BREAK 
"layout.append( " 0
""page " + page ); " 0
BREAK 
"layout.append( " 0
""button 580 287 5600 5604 0 " + ( " 0
"page - 1 ) + " 0" ); " 0
BREAK 
"endif " 0
BREAK 
"layout.append( " 0
""button 525 " + ( " 0
"y ) + " 2440 2440 1 0 " + ( " 0
"MENUSTART + i ) ); " 0
BREAK 
"layout.append( " 0
""htmlgump 525 " + ( " 0
"y ) + " 166 25 " + data.size() " 0
"+ " 1 0" ); " 0
BREAK 
"if ( " 0
"TypeOfInt( " 0
"datadict[i] ) " 0
"== OT_ARRAY ) // Typebezeichnung im Array " 0
BREAK 
"if ( " 0
"( " 0
"cfgrandom[datadict[i][1]].name ) || " 0
"( " 0
"cfgeinzel[datadict[i][1]].name ) || " 0
"( " 0
"cfgset[datadict[i][1]].name ) ) " 0
BREAK 
"case " 0
"( " 0
"datadict[i][2] ) " 0
BREAK 
""Random": " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_SADDLEBROWN + "><center>" + cfgrandom[datadict[i][1]].name + "</center>" ); " 0
BREAK 
""Einzel": " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_SADDLEBROWN + "><center>" + cfgeinzel[datadict[i][1]].name + "</center>" ); " 0
BREAK 
""Set": " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_SADDLEBROWN + "><center>" + cfgset[datadict[i][1]].name + "</center>" ); " 0
BREAK 
"endcase " 0
BREAK 
"else " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_SADDLEBROWN + "><center>" + datadict[i][1] + "</center>" ); " 0
BREAK 
"endif " 0
BREAK 
"endif " 0
BREAK 
"y += 30; " 0
BREAK 
"endfor " 0
BREAK 
"endif " 0
BREAK 
"endfunction // }}} " 0
BREAK 
"function Init() " 0
"// {{{ " 0
BREAK 
"var layoutraw := { " 0
""nodispose", " 0
""page 0", " 0
"// "resizepic 500 0 3600 215 390",  // Background " 0
"// "resizepic 515 15 5054 185 30",  // title " 0
""resizepic 500 0 9200 215 390", " 0
""resizepic 515 15 3000 185 30", " 0
""htmlgump 515 22 185 30 0 0 0", " 0
"// Title text " 0
"// "gumppictiled 516 47 183 328 2624", " 0
"// "resizepic 516 47 83 183 328",   // Posts " 0
""resizepic 516 47 3000 183 328", " 0
"// "checkertrans 524 57 168 308", " 0
""htmlgump 610 285 50 20 1 0 0", " 0
""button 660 280 9726 9728 1 0 " + BACKBUTTON, " 0
""gumppictiled 525 320 166 2 30002", " 0
""button 530 330 9721 9724 1 0 " + ITEMMODIFYMANUAL, " 0
""htmlgump 572 335 100 30 2 0 0", " 0
""page 1" }; " 0
BREAK 
"var dataraw := { " 0
""", " 0
"// Titel " 0
""<basefont color=" + HTML_DARKBLUE + ">Back", " 0
""<basefont color=" + HTML_DARKBLUE + ">Item Modify" }; " 0
BREAK 
"SysLog( " 0
"".BAUTOOL Datafile begin" ); " 0
BREAK 
"SetGlobalProperty( " 0
""bautoolinit", " 0
"1 ); " 0
BREAK 
"var dataelement, " 0
"layout := {}, " 0
"data := {}, " 0
"layoutp := {}; " 0
BREAK 
"var element := dictionary; " 0
BREAK 
"var cfgmenu := ReadConfigFile( " 0
""bautoolmenues" ); " 0
BREAK 
"DFPurgeFile( " 0
"datafile ); " 0
BREAK 
"dataelement := datafile.CreateElement( " 0
""menu" ); " 0
BREAK 
"foreach key in ( " 0
"GetConfigStringArray( " 0
"cfgmenu["Rootlist"], " 0
""sublist" ) " 0
") // 1. level " 0
BREAK 
"element[key] := dictionary; " 0
BREAK 
"if ( " 0
"cfgmenu[key].list ) // Items " 0
BREAK 
"foreach itemlist in ( " 0
"GetConfigStringArray( " 0
"cfgmenu[key], " 0
""list" ) " 0
") " 0
BREAK 
"element[key][itemlist] := array; " 0
BREAK 
"foreach itemkey in ( " 0
"GetConfigStringKeys( " 0
"cfgrandom ) " 0
") // Insert possible random " 0
BREAK 
"if ( " 0
"cfgrandom[itemkey].list == itemlist ) " 0
BREAK 
"element[key][itemlist].append( " 0
"{ " 0
"itemkey, " 0
""Random", " 0
"cfgrandom[itemkey].name } " 0
"); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"foreach itemkey in ( " 0
"GetConfigStringKeys( " 0
"cfgeinzel ) " 0
") // Insert possible single " 0
BREAK 
"if ( " 0
"cfgeinzel[itemkey].list == itemlist ) " 0
BREAK 
"element[key][itemlist].append( " 0
"{ " 0
"itemkey, " 0
""Einzel", " 0
"cfgeinzel[itemkey].name } " 0
"); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"foreach itemkey in ( " 0
"GetConfigStringKeys( " 0
"cfgset ) " 0
") // Insert possible sets " 0
BREAK 
"if ( " 0
"cfgset[itemkey].list == itemlist ) " 0
BREAK 
"element[key][itemlist].append( " 0
"{ " 0
"itemkey, " 0
""Set", " 0
"cfgset[itemkey].name } " 0
"); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"element[key][itemlist] := SortArrayABC( " 0
"element[key][itemlist], " 0
"1, " 0
"3 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"if ( " 0
"cfgmenu[key].sublist ) " 0
BREAK 
"foreach sub1key in ( " 0
"GetConfigStringArray( " 0
"cfgmenu[key], " 0
""sublist" ) " 0
") // 2. level " 0
BREAK 
"element[key][sub1key] := dictionary; " 0
BREAK 
"if ( " 0
"cfgmenu[sub1key].list ) // Items " 0
BREAK 
"foreach itemlist in ( " 0
"GetConfigStringArray( " 0
"cfgmenu[sub1key], " 0
""list" ) " 0
") " 0
BREAK 
"element[key][sub1key][itemlist] := array; " 0
BREAK 
"foreach itemkey in ( " 0
"GetConfigStringKeys( " 0
"cfgrandom ) " 0
") // Insert possible random " 0
BREAK 
"if ( " 0
"cfgrandom[itemkey].list == itemlist ) " 0
BREAK 
"element[key][sub1key][itemlist].append( " 0
"{ " 0
"itemkey, " 0
""Random", " 0
"cfgrandom[itemkey].name } " 0
"); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"foreach itemkey in ( " 0
"GetConfigStringKeys( " 0
"cfgeinzel ) " 0
") // Insert possible single " 0
BREAK 
"if ( " 0
"cfgeinzel[itemkey].list == itemlist ) " 0
BREAK 
"element[key][sub1key][itemlist].append( " 0
"{ " 0
"itemkey, " 0
""Einzel", " 0
"cfgeinzel[itemkey].name } " 0
"); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"foreach itemkey in ( " 0
"GetConfigStringKeys( " 0
"cfgset ) " 0
") // Insert possible sets " 0
BREAK 
"if ( " 0
"cfgset[itemkey].list == itemlist ) " 0
BREAK 
"element[key][sub1key][itemlist].append( " 0
"{ " 0
"itemkey, " 0
""Set", " 0
"cfgset[itemkey].name } " 0
"); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"element[key][sub1key][itemlist] := SortArrayABC( " 0
"element[key][sub1key][itemlist], " 0
"1, " 0
"3 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"if ( " 0
"cfgmenu[sub1key].sublist ) " 0
BREAK 
"foreach sub2key in ( " 0
"GetConfigStringArray( " 0
"cfgmenu[sub1key], " 0
""sublist" ) " 0
") // 3. level " 0
BREAK 
"element[key][sub1key][sub2key] := dictionary; " 0
BREAK 
"if ( " 0
"cfgmenu[sub2key].list ) // Items " 0
BREAK 
"foreach itemlist in ( " 0
"GetConfigStringArray( " 0
"cfgmenu[sub2key], " 0
""list" ) " 0
") " 0
BREAK 
"element[key][sub1key][sub2key][itemlist] := array; " 0
BREAK 
"foreach itemkey in ( " 0
"GetConfigStringKeys( " 0
"cfgrandom ) " 0
") // Insert possible random " 0
BREAK 
"if ( " 0
"cfgrandom[itemkey].list == itemlist ) " 0
BREAK 
"element[key][sub1key][sub2key][itemlist].append( " 0
"{ " 0
"itemkey, " 0
""Random", " 0
"cfgrandom[itemkey].name } " 0
"); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"foreach itemkey in ( " 0
"GetConfigStringKeys( " 0
"cfgeinzel ) " 0
") // Insert possible single " 0
BREAK 
"if ( " 0
"cfgeinzel[itemkey].list == itemlist ) " 0
BREAK 
"element[key][sub1key][sub2key][itemlist].append( " 0
"{ " 0
"itemkey, " 0
""Einzel", " 0
"cfgeinzel[itemkey].name } " 0
"); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"foreach itemkey in ( " 0
"GetConfigStringKeys( " 0
"cfgset ) " 0
") // Insert possible sets " 0
BREAK 
"if ( " 0
"cfgset[itemkey].list == itemlist ) " 0
BREAK 
"element[key][sub1key][sub2key][itemlist].append( " 0
"{ " 0
"itemkey, " 0
""Set", " 0
"cfgset[itemkey].name } " 0
"); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"element[key][sub1key][sub2key][itemlist] := SortArrayABC( " 0
"element[key][sub1key][sub2key][itemlist], " 0
"1, " 0
"3 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"if ( " 0
"cfgmenu[sub2key].sublist ) " 0
BREAK 
"foreach sub3key in ( " 0
"GetConfigStringArray( " 0
"cfgmenu[sub2key], " 0
""sublist" ) " 0
") // 4. level " 0
BREAK 
"element[key][sub1key][sub2key][sub3key] := dictionary; " 0
BREAK 
"if ( " 0
"cfgmenu[sub3key].list ) // Items " 0
BREAK 
"foreach itemlist in ( " 0
"GetConfigStringArray( " 0
"cfgmenu[sub3key], " 0
""list" ) " 0
") " 0
BREAK 
"element[key][sub1key][sub2key][sub3key][itemlist] := array; " 0
BREAK 
"foreach itemkey in ( " 0
"GetConfigStringKeys( " 0
"cfgrandom ) " 0
") // Insert possible random " 0
BREAK 
"if ( " 0
"cfgrandom[itemkey].list == itemlist ) " 0
BREAK 
"element[key][sub1key][sub2key][sub3key][itemlist].append( " 0
"{ " 0
"itemkey, " 0
""Random", " 0
"cfgrandom[itemkey].name } " 0
"); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"foreach itemkey in ( " 0
"GetConfigStringKeys( " 0
"cfgeinzel ) " 0
") // Insert possible single " 0
BREAK 
"if ( " 0
"cfgeinzel[itemkey].list == itemlist ) " 0
BREAK 
"element[key][sub1key][sub2key][sub3key][itemlist].append( " 0
"{ " 0
"itemkey, " 0
""Einzel", " 0
"cfgeinzel[itemkey].name } " 0
"); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"foreach itemkey in ( " 0
"GetConfigStringKeys( " 0
"cfgset ) " 0
") // Insert possible sets " 0
BREAK 
"if ( " 0
"cfgset[itemkey].list == itemlist ) " 0
BREAK 
"element[key][sub1key][sub2key][sub3key][itemlist].append( " 0
"{ " 0
"itemkey, " 0
""Set", " 0
"cfgset[itemkey].name } " 0
"); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"element[key][sub1key][sub2key][sub3key][itemlist] := SortArrayABC( " 0
"element[key][sub1key][sub2key][sub3key][itemlist], " 0
"1, " 0
"3 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"endforeach " 0
BREAK 
"layout := layoutraw; " 0
BREAK 
"data := dataraw; " 0
BREAK 
"MenuBar( " 0
"layout, " 0
"data, " 0
"element ); " 0
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>BauTool " + VERSION + "</center>"; " 0
BREAK 
"dataelement.setprop( " 0
""LayoutMenuBar", " 0
"layout ); " 0
BREAK 
"dataelement.setprop( " 0
""DataMenuBar", " 0
"data ); " 0
BREAK 
"foreach ebene1 in element // 1. level " 0
BREAK 
"layout := layoutraw; " 0
BREAK 
"data := dataraw; " 0
BREAK 
"MenuBar( " 0
"layout, " 0
"data, " 0
"ebene1 ); " 0
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene1_iter + "</center>"; " 0
BREAK 
"dataelement.setprop( " 0
""LayoutMain_" + _ebene1_iter, " 0
"layout ); " 0
BREAK 
"dataelement.setprop( " 0
""DataMain_" + _ebene1_iter, " 0
"data ); " 0
BREAK 
"foreach ebene2 in ebene1 // 2.level " 0
BREAK 
"layout := layoutraw; " 0
BREAK 
"data := dataraw; " 0
BREAK 
"MenuBar( " 0
"layout, " 0
"data, " 0
"ebene2 ); " 0
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene2_iter + "</center>"; " 0
BREAK 
"dataelement.setprop( " 0
""LayoutSub_" + _ebene1_iter + "_" + _ebene2_iter, " 0
"layout ); " 0
BREAK 
"dataelement.setprop( " 0
""DataSub_" + _ebene1_iter + "_" + _ebene2_iter, " 0
"data ); " 0
BREAK 
"if ( " 0
"TypeOfInt( " 0
"ebene2 ) " 0
"<> OT_DICTIONARY ) // Items " 0
BREAK 
"foreach item in ebene2 " 0
BREAK 
"InitItems( " 0
"data, " 0
"layout, " 0
"item, " 0
"_ebene2_iter, " 0
"layoutraw, " 0
"dataraw ); " 0
BREAK 
"dataelement.setprop( " 0
""LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + item[1], " 0
"layout ); " 0
BREAK 
"dataelement.setprop( " 0
""DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + item[1], " 0
"data ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"else " 0
BREAK 
"foreach ebene3 in ebene2 // 3.level " 0
BREAK 
"layout := layoutraw; " 0
BREAK 
"data := dataraw; " 0
BREAK 
"MenuBar( " 0
"layout, " 0
"data, " 0
"ebene3 ); " 0
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene3_iter + "</center>"; " 0
BREAK 
"dataelement.setprop( " 0
""LayoutSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter, " 0
"layout ); " 0
BREAK 
"dataelement.setprop( " 0
""DataSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter, " 0
"data ); " 0
BREAK 
"if ( " 0
"TypeOfInt( " 0
"ebene3 ) " 0
"<> OT_DICTIONARY ) // Items " 0
BREAK 
"foreach item in ebene3 " 0
BREAK 
"InitItems( " 0
"data, " 0
"layout, " 0
"item, " 0
"_ebene3_iter, " 0
"layoutraw, " 0
"dataraw ); " 0
BREAK 
"dataelement.setprop( " 0
""LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + item[1], " 0
"layout ); " 0
BREAK 
"dataelement.setprop( " 0
""DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + item[1], " 0
"data ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"else " 0
BREAK 
"foreach ebene4 in ebene3 // 4.level " 0
BREAK 
"layout := layoutraw; " 0
BREAK 
"data := dataraw; " 0
BREAK 
"MenuBar( " 0
"layout, " 0
"data, " 0
"ebene4 ); " 0
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene4_iter + "</center>"; " 0
BREAK 
"dataelement.setprop( " 0
""LayoutSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter, " 0
"layout ); " 0
BREAK 
"dataelement.setprop( " 0
""DataSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter, " 0
"data ); " 0
BREAK 
"if ( " 0
"TypeOfInt( " 0
"ebene4 ) " 0
"<> OT_DICTIONARY ) // Items " 0
BREAK 
"foreach item in ebene4 " 0
BREAK 
"InitItems( " 0
"data, " 0
"layout, " 0
"item, " 0
"_ebene4_iter, " 0
"layoutraw, " 0
"dataraw ); " 0
BREAK 
"dataelement.setprop( " 0
""LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + item[1], " 0
"layout ); " 0
BREAK 
"dataelement.setprop( " 0
""DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + item[1], " 0
"data ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"else " 0
BREAK 
"foreach ebene5 in ebene4 // 5.level " 0
BREAK 
"layout := layoutraw; " 0
BREAK 
"data := dataraw; " 0
BREAK 
"MenuBar( " 0
"layout, " 0
"data, " 0
"ebene5 ); " 0
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene5_iter + "</center>"; " 0
BREAK 
"dataelement.setprop( " 0
""LayoutSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter, " 0
"layout ); " 0
BREAK 
"dataelement.setprop( " 0
""DataSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter, " 0
"data ); " 0
BREAK 
"if ( " 0
"TypeOfInt( " 0
"ebene5 ) " 0
"<> OT_DICTIONARY ) // Items " 0
BREAK 
"foreach item in ebene5 " 0
BREAK 
"InitItems( " 0
"data, " 0
"layout, " 0
"item, " 0
"_ebene5_iter, " 0
"layoutraw, " 0
"dataraw ); " 0
BREAK 
"dataelement.setprop( " 0
""LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter + "_" + item[1], " 0
"layout ); " 0
BREAK 
"dataelement.setprop( " 0
""DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter + "_" + item[1], " 0
"data ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"else " 0
BREAK 
"foreach ebene6 in ebene5 // 6.level " 0
BREAK 
"InitItems( " 0
"data, " 0
"layout, " 0
"ebene6, " 0
"_ebene6_iter, " 0
"layoutraw, " 0
"dataraw ); " 0
BREAK 
"dataelement.setprop( " 0
""LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter + "_" + _ebene6_iter, " 0
"layout ); " 0
BREAK 
"dataelement.setprop( " 0
""DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter + "_" + _ebene6_iter, " 0
"data ); " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"endforeach " 0
BREAK 
"endif " 0
BREAK 
"endforeach " 0
BREAK 
"endforeach " 0
BREAK 
"dataelement := datafile.CreateElement( " 0
""modify" ); " 0
BREAK 
"layout := { " 0
""nodispose", " 0
""page 0", " 0
""resizepic 500 0 3600 215 280", " 0
"// Background " 0
""resizepic 515 15 5054 185 30", " 0
"// title " 0
""htmlgump 515 22 185 30 0 0 0", " 0
"// Title text " 0
""resizepic 515 47 83 185 218", " 0
"// Posts " 0
""checkertrans 523 57 170 198", " 0
""htmlgump 610 225 50 20 1 0 0", " 0
"// Continue " 0
""htmlgump 555 79 50 20 2 0 0", " 0
"// X/Y " 0
""htmlgump 624 79 50 20 3 0 0", " 0
"// Z " 0
""button 660 220 9721 9724 1 0 " + BACKBUTTON, " 0
""button 560 60 5600 5604 1 0 " + MODIFY_Y_DOWN, " 0
""button 560 100 5602 5606 1 0 " + MODIFY_Y_UP, " 0
""button 530 80 5603 5607 1 0 " + MODIFY_X_DOWN, " 0
""button 590 80 5601 5605 1 0 " + MODIFY_X_UP, " 0
""button 534 60 22406 22407 1 0 " + MODIFY_XY_MM, " 0
""button 583 60 22401 22400 1 0 " + MODIFY_XY_PM, " 0
""button 534 100 22403 22402 1 0 " + MODIFY_XY_MP, " 0
""button 583 100 22404 22405 1 0 " + MODIFY_XY_PP, " 0
""button 620 60 5600 5604 1 0 " + MODIFY_Z_UP, " 0
""button 620 100 5602 5606 1 0 " + MODIFY_Z_DOWN, " 0
""htmlgump 570 165 50 20 4 0 0", " 0
""button 530 160 9727 9728 1 0 " + MODIFY_DESTROY, " 0
""htmlgump 570 200 50 30 10 0 0", " 0
""button 530 195 9727 9728 1 0 " + MODIFY_DUPE, " 0
""htmlgump 570 130 50 30 5 0 0", " 0
""resizepic 610 125 2620 58 30", " 0
""textentry 616 130 40 20 1000 " + ITEMCOLOR + " 6", " 0
""button 530 125 9727 9728 1 0 " + MODIFY_COLOR, " 0
""htmlgump 630 60 50 20 7 0 0", " 0
"// x / y / z Coord Specification of the first item " 0
""tooltip 3000561", " 0
"// Coords.: " 0
""htmlgump 630 80 50 20 8 0 0", " 0
""tooltip 3000561", " 0
""htmlgump 630 100 50 20 9 0 0", " 0
""tooltip 3000561", " 0
""button 681 64 2103 2104 0 2 0", " 0
""button 681 84 2103 2104 0 3 0", " 0
""button 681 104 2103 2104 0 4 0" }; " 0
BREAK 
"data := { " 0
""<basefont size=8 color=" + HTML_DARKGREEN + "><center>Modify Position</center>", " 0
"// title " 0
""<basefont color=" + HTML_DARKBLUE + ">Continue", " 0
""<basefont color=" + HTML_DARKBLUE + ">X/Y", " 0
""<basefont color=" + HTML_DARKBLUE + ">Z", " 0
""<basefont color=" + HTML_DARKBLUE + ">Destroy", " 0
""<basefont color=" + HTML_DARKBLUE + ">Color", " 0
""0", " 0
""<basefont color=" + HTML_DARKBLUE + "><p align=right>x</p></basefont>", " 0
""<basefont color=" + HTML_DARKBLUE + "><p align=right>y</p></basefont>", " 0
""<basefont color=" + HTML_DARKBLUE + "><p align=right>z</p></basefont>", " 0
""<basefont color=" + HTML_DARKBLUE + ">Dupe", " 0
""0", " 0
""0", " 0
""0" }; " 0
BREAK 
"layoutp := { " 0
""page 2", " 0
""resizepic 720 40 3600 100 60", " 0
""resizepic 735 55 2620 48 30", " 0
""textentrylimited 741 60 30 20 1000 " + MODIFY_X_ENTRY + " 11 4", " 0
""button 790 63 2103 2104 1 0 " + MODIFY_X, " 0
""page 3", " 0
""resizepic 720 60 3600 100 60", " 0
""resizepic 735 75 2620 48 30", " 0
""textentrylimited 741 80 30 20 1000 " + MODIFY_Y_ENTRY + " 12 4", " 0
""button 790 83 2103 2104 1 0 " + MODIFY_Y, " 0
""page 4", " 0
""resizepic 720 80 3600 100 60", " 0
""resizepic 735 95 2620 48 30", " 0
""textentrylimited 741 100 30 20 1000 " + MODIFY_Z_ENTRY + " 13 4", " 0
""button 790 103 2103 2104 1 0 " + MODIFY_Z }; " 0
BREAK 
"dataelement.setprop( " 0
""LayoutMenu", " 0
"layout + layoutp ); " 0
BREAK 
"dataelement.setprop( " 0
""DataMenu", " 0
"data ); " 0
BREAK 
"layout[3] := "resizepic 500 0 3600 215 440"; " 0
"// Background expand " 0
BREAK 
"layout[6] := "resizepic 516 47 83 183 377"; " 0
BREAK 
"layout[7] := "checkertrans 524 57 168 358"; " 0
BREAK 
"layout.erase( " 0
"8 ); " 0
"// Next ButtonText " 0
BREAK 
"layout.erase( " 0
"10 ); " 0
"// Next button " 0
BREAK 
"layout.append( " 0
""gumppictiled 525 235 165 2 30002" ); " 0
BREAK 
"layout.append( " 0
""htmlgump 595 255 100 20 1 0 0" ); " 0
BREAK 
"layout.append( " 0
""button 560 250 9721 9724 1 0 " + MODIFY_START ); " 0
BREAK 
"data[2] := "<basefont color=" + HTML_DARKBLUE + ">Choose Items"; " 0
BREAK 
"layout.append( " 0
""resizepic 530 285 2620 48 30" ); " 0
BREAK 
"layout.append( " 0
""textentry 536 290 30 20 1000 " + MODIFY_Z_START + " 14" ); " 0
BREAK 
"data.append( " 0
""-20" ); " 0
BREAK 
"layout.append( " 0
""resizepic 635 285 2620 48 30" ); " 0
BREAK 
"layout.append( " 0
""textentry 641 290 30 20 1000 " + MODIFY_Z_END + " 15" ); " 0
BREAK 
"data.append( " 0
""20" ); " 0
BREAK 
"layout.append( " 0
""htmlgump 585 290 50 20 16 0 0" ); " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_DARKBLUE + ">Z-Range" ); " 0
BREAK 
"layout.append( " 0
""checkbox 530 320 9720 9723 0 " + MODIFY_CUSTOM ); " 0
BREAK 
"layout.append( " 0
""htmlgump 565 325 50 20 17 0 0" ); " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_DARKBLUE + ">Custom" ); " 0
BREAK 
"layout.append( " 0
""checkbox 616 320 9720 9723 0 " + MODIFY_MARK ); " 0
BREAK 
"layout.append( " 0
""htmlgump 651 325 50 20 18 0 0" ); " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_DARKBLUE + ">Mark" ); " 0
BREAK 
"layout.append( " 0
""gumppictiled 525 360 165 2 30002" ); " 0
BREAK 
"layout.append( " 0
""button 530 375 9721 9724 1 0 " + MODIFY_MARKEDIT ); " 0
BREAK 
"layout.append( " 0
""htmlgump 570 380 100 20 19 0 0" ); " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_DARKBLUE + ">Mark Edit" ); " 0
BREAK 
"dataelement.setprop( " 0
""LayoutMenuManual", " 0
"layout + layoutp ); " 0
BREAK 
"dataelement.setprop( " 0
""DataMenuManual", " 0
"data ); " 0
BREAK 
"dataelement := datafile.CreateElement( " 0
""modifymark" ); " 0
BREAK 
"layout := { " 0
""nodispose", " 0
""page 0", " 0
""resizepic 500 0 3600 215 213", " 0
"// Background " 0
""resizepic 515 15 5054 185 30", " 0
"// title " 0
""htmlgump 515 22 185 30 0 0 0", " 0
"// Title text " 0
""resizepic 515 47 83 185 150", " 0
"// Posts-20 " 0
""checkertrans 523 57 170 130", " 0
""button 530 70 9721 9724 1 0 " + MARK_SHOW, " 0
""htmlgump 570 75 50 20 1 0 0", " 0
""button 530 105 9721 9724 1 0 " + MARK_HIDE, " 0
""htmlgump 570 110 50 20 2 0 0", " 0
""button 530 140 9721 9724 1 0 " + MARK_EDIT, " 0
""htmlgump 570 145 50 20 3 0 0" }; " 0
BREAK 
"data := { " 0
""<basefont size=8 color=" + HTML_DARKGRAY + "><center>Mark Edit</center>", " 0
""<basefont color=" + HTML_DARKBLUE + ">Show", " 0
""<basefont color=" + HTML_DARKBLUE + ">Hide", " 0
""<basefont color=" + HTML_DARKBLUE + ">Edit" }; " 0
BREAK 
"dataelement.setprop( " 0
""LayoutMenuMark", " 0
"layout ); " 0
BREAK 
"dataelement.setprop( " 0
""DataMenuMark", " 0
"data ); " 0
BREAK 
"dataelement := datafile.CreateElement( " 0
""elemente" ); " 0
BREAK 
"dataelement.setprop( " 0
""dictionary", " 0
"element ); " 0
BREAK 
"EraseGlobalProperty( " 0
""bautoolinit" ); " 0
BREAK 
"SysLog( " 0
"".BAUTOOL Datafile completed" ); " 0
BREAK 
"endfunction // }}} " 0
BREAK 
"function InitItems( " 0
"byref data, " 0
"byref layout, " 0
"byref element, " 0
"name := 0, " 0
"layoutraw, " 0
"dataraw ) " 0
"// {{{ " 0
BREAK 
"var tile, " 0
"nextpagebreak, " 0
"nextlinebreak, " 0
"x, " 0
"y, " 0
"page, " 0
"m, " 0
"itemdesc; " 0
BREAK 
"case " 0
"( " 0
"element[2] ) " 0
BREAK 
""Random": " 0
"// Random " 0
BREAK 
"layout := layoutraw; " 0
BREAK 
"data := dataraw; " 0
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + name + "</center>"; " 0
BREAK 
"layout := layout + { " 0
""page 0", " 0
""resizepic 70 0 3600 404 170", " 0
""resizepic 85 15 5054 374 30", " 0
""htmlgump 85 22 374 30 " + data.size() " 0
"+ " 0 0", " 0
""resizepic 85 47 83 374 108", " 0
""checkertrans 93 57 359 88" }; " 0
BREAK 
"data.append( " 0
""<basefont size=5><center>" + cfgrandom[element[1]].name + "</center>" ); " 0
BREAK 
"tile := GetConfigStringArray( " 0
"cfgrandom[element[1]], " 0
""tile" )[" 0
"1]; " 0
BREAK 
"layout.append( " 0
""tilepic 95 60 " + CInt( " 0
"SplitWords( " 0
"tile, " 0
""," )[" 0
"1] ) " 0
"); " 0
BREAK 
"layout.append( " 0
""htmlgump 160 70 50 30 " + data.size() " 0
"+ " 0 0" ); " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_DARKBLUE + ">Color" ); " 0
BREAK 
"layout.append( " 0
""resizepic 200 65 2620 48 30" ); " 0
BREAK 
"layout.append( " 0
""textentry 206 70 30 20 1000 " + ITEMCOLOR + " " + data.size() " 0
"); " 0
BREAK 
"data.append( " 0
""0" ); " 0
BREAK 
"if ( " 0
"( " 0
"GetConfigString( " 0
"cfgrandom[element[1]], " 0
""n" ) " 0
") // Option necessary for edge parts? " 0
"|| " 0
"( " 0
"GetConfigString( " 0
"cfgrandom[element[1]], " 0
""s" ) " 0
") || " 0
"( " 0
"GetConfigString( " 0
"cfgrandom[element[1]], " 0
""e" ) " 0
") || " 0
"( " 0
"GetConfigString( " 0
"cfgrandom[element[1]], " 0
""w" ) " 0
") ) " 0
BREAK 
"layout.append( " 0
""htmlgump 360 60 50 40 " + data.size() " 0
"+ " 0 0" ); " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_DARKBLUE + ">Produce Random Tiles" ); " 0
BREAK 
"layout.append( " 0
""checkbox 420 65 9720 9723 0 " + ITEMRAND ); " 0
BREAK 
"endif " 0
BREAK 
"layout.append( " 0
""htmlgump 260 70 50 30 " + data.size() " 0
"+ " 0 0" ); " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_DARKBLUE + ">z-Coord" ); " 0
BREAK 
"layout.append( " 0
""resizepic 310 65 2620 38 30" ); " 0
BREAK 
"layout.append( " 0
""textentry 316 70 20 20 1000 " + ITEMPOS + " " + data.size() " 0
"); " 0
BREAK 
"data.append( " 0
""0" ); " 0
BREAK 
"layout.append( " 0
""checkbox 420 110 9720 9723 1 " + ITEMMODIFY ); " 0
BREAK 
"layout.append( " 0
""htmlgump 360 105 50 40 " + data.size() " 0
"+ " 0 0" ); " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_DARKBLUE + ">Modify Position" ); " 0
BREAK 
"layout.append( " 0
""button 103 116 9721 9724 1 0 " + ITEMCREATE ); " 0
BREAK 
"layout.append( " 0
""htmlgump 140 121 50 30 " + data.size() " 0
"+ " 0 0" ); " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_DARKBLUE + ">Create" ); " 0
BREAK 
""Einzel": " 0
BREAK 
"itemdesc := ReadConfigFile( " 0
"":*:itemdesc" ); " 0
"// Reading of all Itemdesc's for name determination " 0
BREAK 
"layout := layoutraw; " 0
BREAK 
"data := dataraw; " 0
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + name + "</center>"; " 0
BREAK 
"layout := layout + { " 0
""page 0", " 0
""resizepic 70 0 3600 425 400", " 0
""resizepic 85 15 5054 395 30", " 0
""htmlgump 85 22 395 30 " + data.size() " 0
"+ " 0 0", " 0
""resizepic 85 47 83 395 343" }; " 0
BREAK 
"data.append( " 0
""<basefont size=5><center>" + cfgeinzel[element[1]].name + "</center>" ); " 0
BREAK 
"layout.append( " 0
""htmlgump 530 70 50 30 " + data.size() " 0
"+ " 0 0" ); " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_DARKBLUE + ">Color" ); " 0
BREAK 
"layout.append( " 0
""resizepic 570 65 2620 48 30" ); " 0
BREAK 
"layout.append( " 0
""textentry 576 70 30 20 1000 " + ITEMCOLOR + " " + data.size() " 0
"); " 0
BREAK 
"data.append( " 0
""0" ); " 0
BREAK 
"layout.append( " 0
""htmlgump 530 110 50 30 " + data.size() " 0
"+ " 0 0" ); " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_DARKBLUE + ">z-Coord" ); " 0
BREAK 
"layout.append( " 0
""resizepic 580 105 2620 38 30" ); " 0
BREAK 
"layout.append( " 0
""textentry 586 110 20 20 1000 " + ITEMPOS + " " + data.size() " 0
"); " 0
BREAK 
"data.append( " 0
""0" ); " 0
BREAK 
"layout.append( " 0
""checkbox 530 150 9720 9723 1 " + ITEMMODIFY ); " 0
BREAK 
"layout.append( " 0
""htmlgump 572 155 100 30 " + data.size() " 0
"+ " 0 0" ); " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_DARKBLUE + ">Modify Position" ); " 0
BREAK 
"layout.append( " 0
""checkbox 530 185 9720 9723 0 " + ITEMMMULTICREATE ); " 0
BREAK 
"layout.append( " 0
""htmlgump 572 190 100 30 " + data.size() " 0
"+ " 0 0" ); " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_DARKBLUE + ">Mark All" ); " 0
BREAK 
"layout.append( " 0
""button 570 225 9721 9724 1 0 " + ITEMCREATE ); " 0
BREAK 
"layout.append( " 0
""htmlgump 612 230 50 30 " + data.size() " 0
"+ " 0 0" ); " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_DARKBLUE + ">Create" ); " 0
BREAK 
"tile := {}; " 0
BREAK 
"foreach tiles in ( " 0
"GetConfigStringArray( " 0
"cfgeinzel[element[1]], " 0
""tile" ) " 0
") " 0
BREAK 
"if ( " 0
"!tile ) " 0
BREAK 
"tile := { " 0
"tiles }; " 0
BREAK 
"else " 0
BREAK 
"tile.append( " 0
"tiles ); " 0
BREAK 
"endif " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endforeach " 0
BREAK 
"nextpagebreak := MAXLINEITEM * 2 + 1; " 0
BREAK 
"nextlinebreak := MAXLINEITEM + 1; " 0
BREAK 
"x := 100; " 0
BREAK 
"y := 60; " 0
BREAK 
"page := 1; " 0
BREAK 
"layout.append( " 0
""page 1" ); " 0
BREAK 
"for ( " 0
"m := 1; " 0
"m <= tile.size(); " 0
"m += 1 ) " 0
BREAK 
"if ( " 0
"m == nextpagebreak ) " 0
BREAK 
"nextpagebreak += MAXLINEITEM * 2; " 0
BREAK 
"nextlinebreak += MAXLINEITEM; " 0
BREAK 
"x := 100; " 0
BREAK 
"y := 60; " 0
BREAK 
"if ( " 0
"page > 1 ) " 0
BREAK 
"layout.append( " 0
""button 250 360 5603 5607 0 " + ( " 0
"page - 1 ) + " 0" ); " 0
BREAK 
"endif " 0
BREAK 
"page += 1; " 0
BREAK 
"layout.append( " 0
""button 280 360 5601 5605 0 " + page + " 0" ); " 0
BREAK 
"layout.append( " 0
""page " + page ); " 0
BREAK 
"endif " 0
BREAK 
"if ( " 0
"m == nextlinebreak ) " 0
BREAK 
"y := 210; " 0
BREAK 
"x := 100; " 0
BREAK 
"nextlinebreak += MAXLINEITEM; " 0
BREAK 
"endif " 0
BREAK 
"layout.append( " 0
""radio " + ( " 0
"x ) + " " + ( " 0
"y + 35 ) + " 9720 9723 0 " + m ); " 0
BREAK 
"layout.append( " 0
""tilepic " + ( " 0
"x + 35 ) + " " + ( " 0
"y + 35 ) + " " + CInt( " 0
"SplitWords( " 0
"tile[m], " 0
""," )[" 0
"1] ) " 0
"); " 0
BREAK 
"if ( " 0
"itemdesc[Hex( " 0
"tile[m] )]." 0
"desc ) // Insert name .desc or CliLoc entry " 0
BREAK 
"layout.append( " 0
""htmlgump " + ( " 0
"x + 5 ) + " " + ( " 0
"y ) + " 90 40 " + data.size() " 0
"+ " 0 0" ); " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_GRAY + ">" + itemdesc[Hex( " 0
"tile[m] )]." 0
"desc ); " 0
BREAK 
"else " 0
BREAK 
"layout.append( " 0
""xmfhtmlgumpcolor " + ( " 0
"x + 5 ) + " " + ( " 0
"y ) + " 90 40 " + ( " 0
"1020000 + CInt( " 0
"tile[m] ) " 0
") + " 0 0 " + XMFCOLOR_GRAY2 ); " 0
BREAK 
"endif " 0
BREAK 
"x += 90; " 0
BREAK 
"SleepMS( " 0
"2 ); " 0
BREAK 
"endfor " 0
BREAK 
"if ( " 0
"page > 1 ) " 0
BREAK 
"layout.append( " 0
""button 250 360 5603 5607 0 " + ( " 0
"page - 1 ) + " 0" ); " 0
BREAK 
"endif " 0
BREAK 
""Set": " 0
BREAK 
"layout := layoutraw; " 0
BREAK 
"data := dataraw; " 0
BREAK 
"data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + name + "</center>"; " 0
BREAK 
"layout.append( " 0
""htmlgump 515 60 185 30 " + data.size() " 0
"+ " 0 0" ); " 0
BREAK 
"data.append( " 0
""<basefont size=5 color=" + HTML_DARKGRAY + "><center>" + cfgset[element[1]].name + "</center>" ); " 0
BREAK 
"layout.append( " 0
""htmlgump 530 100 50 30 " + data.size() " 0
"+ " 0 0" ); " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_DARKBLUE + ">Color" ); " 0
BREAK 
"layout.append( " 0
""resizepic 570 95 2620 48 30" ); " 0
BREAK 
"layout.append( " 0
""textentry 576 100 30 20 1000 " + ITEMCOLOR + " " + data.size() " 0
"); " 0
BREAK 
"data.append( " 0
""0" ); " 0
BREAK 
"layout.append( " 0
""htmlgump 530 140 50 30 " + data.size() " 0
"+ " 0 0" ); " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_DARKBLUE + ">z-Coord" ); " 0
BREAK 
"layout.append( " 0
""resizepic 580 135 2620 38 30" ); " 0
BREAK 
"layout.append( " 0
""textentry 586 140 20 20 1000 " + ITEMPOS + " " + data.size() " 0
"); " 0
BREAK 
"data.append( " 0
""0" ); " 0
BREAK 
"layout.append( " 0
""checkbox 530 180 9720 9723 1 " + ITEMMODIFY ); " 0
BREAK 
"layout.append( " 0
""htmlgump 572 185 100 30 " + data.size() " 0
"+ " 0 0" ); " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_DARKBLUE + ">Modify Position" ); " 0
BREAK 
"layout.append( " 0
""checkbox 530 215 9720 9723 0 " + ITEMMMULTICREATE ); " 0
BREAK 
"layout.append( " 0
""htmlgump 572 220 100 30 " + data.size() " 0
"+ " 0 0" ); " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_DARKBLUE + ">Mark All" ); " 0
BREAK 
"layout.append( " 0
""button 570 255 9721 9724 1 0 " + ITEMCREATE ); " 0
BREAK 
"layout.append( " 0
""htmlgump 612 260 50 30 " + data.size() " 0
"+ " 0 0" ); " 0
BREAK 
"data.append( " 0
""<basefont color=" + HTML_DARKBLUE + ">Create" ); " 0
BREAK 
"endcase " 0
BREAK 
"endfunction // }}} " 0
BREAK 
"function RecoverInitItem( " 0
"newinit ) " 0
"// {{{ " 0
BREAK 
"var oldinit := newinit.getprop( " 0
"CPROP_INIT ); " 0
BREAK 
"var found := array{ " 0
"newinit }; " 0
BREAK 
"var serials := array{ " 0
"newinit.serial }; " 0
BREAK 
"foreach item in ( " 0
"ListItemsNearLocation( " 0
"newinit.x, " 0
"newinit.y, " 0
"LIST_IGNORE_Z, " 0
"MAXAREASIZE, " 0
"newinit.realm ) " 0
") " 0
BREAK 
"SleepMs( " 0
"2 ); " 0
BREAK 
"if ( " 0
"item.serial == newinit.serial ) " 0
BREAK 
"continue;" 0
BREAK 
"endif " 0
BREAK 
"if ( " 0
"item.getprop( " 0
"CPROP_INIT ) " 0
"== oldinit ) " 0
BREAK 
"found.append( " 0
"item ); " 0
BREAK 
"serials.append( " 0
"item.serial ); " 0
BREAK 
"item.setprop( " 0
"CPROP_INIT, " 0
"newinit.serial ); " 0
BREAK 
"endif " 0
BREAK 
"endforeach " 0
BREAK 
"newinit.setprop( " 0
"CPROP_INIT, " 0
"newinit.serial ); " 0
BREAK 
"newinit.setprop( " 0
"CPROP_ITEMS, " 0
"serials ); " 0
BREAK 
"return found; " 0
BREAK 
"endfunction // }}} " 0

FORMATTED:
///////////////////////////////////////////////////////////////////////////
// bautool - bequemes Erzeugen und Verändern von Items und Itemgruppen
//
// Author: Turley
// eMail : michi.at.www@gmx.de

// Konfigurationsdateien
// - Menustruktur
// - bautoolmenues.cfg
// - Erstellt Rechtecke mit Tiles (Zufällig oder nur einen)
// - bautoolrandom.cfg
// - Erstellt einzelne Items
// - bautooleinzel.cfg
// - Erstellt Sets
// - bautoolset.cfg

///////////////////////////////////////////////////////////////////////////
// ToDo:
// Zufallsding
// - Auswahlliste wie Random/Einzel/Sets
// - Wählt aus plus Wahrscheinlichkeiten
// - Wenn fertig zusammengestellt Eck-Koords angeben und
// createn, immer auf Maphöhe

use cfgfile;
use os;
use uo;
use util;

include "client";
include ":datafile:datafile";
include ":gumps:textConsts";
// Include "include/itemnpc";
// Include "include/msgs";
// Include "include/server";
// Include "include/set";
include "string";

const VERSION := "<basefont color=" + HTML_DARKBLUE + ">V4.2a";

enum TextEntry_Checkboxes
  ITEMCOLOR := 1000,
  ITEMRAND,
  ITEMCREATE,
  ITEMPOS,
  ITEMMODIFY,
  ITEMMMULTICREATE,
  ITEMMODIFYMANUAL, // Modify menu for later modification
  MODIFY_Z_START,
  MODIFY_Z_END,
  MODIFY_CUSTOM,
  MODIFY_MARK,
  MODIFY_X_ENTRY,
  MODIFY_Y_ENTRY,
  MODIFY_Z_ENTRY
endenum

enum Buttons
  BACKBUTTON := 2000, // Back-Button
  MODIFY_MARKEDIT,
  MODIFY_START := 3000,
  MODIFY_Y_UP := 3005, // ModifyItem-Buttons
  MODIFY_Y_DOWN,
  MODIFY_X_UP,
  MODIFY_X_DOWN,
  MODIFY_XY_MM,
  MODIFY_XY_MP,
  MODIFY_XY_PM,
  MODIFY_XY_PP,
  MODIFY_Z_UP,
  MODIFY_Z_DOWN,
  MODIFY_DESTROY,
  MODIFY_COLOR,
  MODIFY_DUPE,
  MODIFY_X,
  MODIFY_Y,
  MODIFY_Z,
  MARK_SHOW,
  MARK_HIDE,
  MARK_EDIT
endenum

enum dataPositionsAngaben
  COLORDATAPOS := 7,
  ZSTARTPOS := 15,
  ZENDPOS := 16,
  XKOORDSPOS := 8,
  YKOORDSPOS := 9,
  ZKOORDSPOS := 10,
  XENTRY := 12,
  YENTRY,
  ZENTRY
endenum

enum Ebenen
  ROOTLIST := 0, // plane definition
  FIRSTLIST,
  SECONDLIST,
  THIRDLIST,
  FOURTHLIST,
  FIFTHLIST,
  ITEMLIST,
  ITEMLISTDUMMY
endenum

enum Cprops
  CPROP_INIT := "bautoolinit", // CProps to find the items
  CPROP_ITEMS := "bautoolitems",
  CPROP_COLOR := "bautoolorigcol" // Original color for markedit
endenum

const MENUSTART := 4000; // Start value of the lists / item buttons

const MAXBUTTON := 7; // Max Buttons in the NavBar
const MAXLINEITEM := 4; // How many items side by side in single create

const MAXAREASIZE := 50;

const ITEMMOVEFLAGS := MOVEOBJECT_FORCELOCATION + MOVEITEM_IGNOREMOVABLE;

// Load everything you need
var cfgrandom := ReadConfigFile( "bautoolrandom" );
var cfgeinzel := ReadConfigFile( "bautooleinzel" );
var cfgset := ReadConfigFile( "bautoolset" );
var datafile := DFOpenDataFile( "bautoolcmd", DF_CREATE, DF_KEYTYPE_STRING );
var dataelementMenu := datafile.FindElement( "menu" );
var dataelementModify := datafile.FindElement( "modify" );
var dataelementElement := datafile.FindElement( "elemente" );
var dataelementMark := datafile.FindElement( "modifymark" );
var layoutmodify := dataelementModify.getprop( "LayoutMenu" );
var datamodify := dataelementModify.getprop( "DataMenu" );
var layoutmodify_M := dataelementModify.getprop( "LayoutMenuManual" );
var datamodify_M := dataelementModify.getprop( "DataMenuManual" );
var layoutmark := dataelementMark.getprop( "LayoutMenuMark" );
var datamark := dataelementMark.getprop( "DataMenuMark" );
var datafileelement := dataelementElement.getprop( "dictionary" );

program bautool( who, param )
  if ( who[1] == "Init" ) // Generate datafile via script
    Init();
    return;
  endif

  if ( !GetGlobalProperty( "BauServer" ) )
    if ( who.cmdlevel < 3 )
      SendSysMessage( who, "You are not authorized to use this command!" );
      return;
    endif
  endif

  if ( Lower( param ) == "init" ) // Developer can start Init () manually
    if ( who.cmdlevel == 5 )
      cfgrandom := 0; // First remove Ref's so that Unload works properly
      cfgeinzel := 0;
      cfgset := 0;
      UnloadConfigFile( "bautoolmenues" );
      UnloadConfigFile( "bautooleinzel" );
      UnloadConfigFile( "bautoolrandom" );
      UnloadConfigFile( "bautoolset" );
      cfgrandom := ReadConfigFile( ":bautool:bautoolrandom" );
      cfgeinzel := ReadConfigFile( ":bautool:bautooleinzel" );
      cfgset := ReadConfigFile( ":bautool:bautoolset" );
      SendSysMessage( who, "Datafile building..." );
      Init();
      SendSysMessage( who, "Datafile completed" );
      return;
    endif
  endif

  if ( GetGlobalProperty( "bautoolinit" ) )
    SendSysMessage( who, "Datafile is still being generated, try again later." );
    return;
  endif

  ShowMenu( who );

endprogram

///////////////////////////////////
// ShowMenu - Actual main part
///////////////////////////////////

function ShowMenu( who ) // {{{
  var data := {}, layout := {}, nr, ebene;
  var ret, tile := {};
  var element := dictionary, back := 0;
  var firstebene, secondebene, thirdebene, fourthebene, fifthebene, itemebene;
  var color;

  element := datafileelement;

  // Now it can start
  ebene := FIRSTLIST;
  layout := dataelementMenu.getprop( "LayoutMenuBar" );
  data := dataelementMenu.getprop( "DataMenuBar" );

  ret := SendDialogGump( who, layout, data, 10, 50 );

  while ( who.connected )
    if ( ( ret.keys[ret.keys.size()] > MENUSTART ) || ( back ) )
      if ( back ) // Simulated buttone printing
        nr := back;
        back := 0;
      else
        nr := ret.keys[ret.keys.size()] - MENUSTART;
      endif
      case ( ebene ) // In which display level I am, create a suitable data list
        ROOTLIST:
          ebene := FIRSTLIST;
          layout := dataelementMenu.getprop( "LayoutMenuBar" );
          data := dataelementMenu.getprop( "DataMenuBar" );

        FIRSTLIST:
          ebene := SECONDLIST;
          if ( TypeOfInt( nr ) == OT_STRING )
            firstebene := nr;
          else
            firstebene := element.keys()[nr];
          endif
          layout := dataelementMenu.getprop( "LayoutMain_" + firstebene );
          data := dataelementMenu.getprop( "DataMain_" + firstebene );

        SECONDLIST:
          ebene := THIRDLIST;
          if ( TypeOfInt( element[firstebene] ) <> OT_DICTIONARY )
            secondebene := nr;
            tile := BuildItems( layout, data, element[firstebene][nr], firstebene );
          else
            if ( TypeOfInt( nr ) == OT_STRING )
              secondebene := nr;
            else
              secondebene := element[firstebene].keys()[nr];
            endif
            layout := dataelementMenu.getprop( "LayoutSub_" + firstebene + "_" + secondebene );
            data := dataelementMenu.getprop( "DataSub_" + firstebene + "_" + secondebene );
          endif

        THIRDLIST:
          ebene := FOURTHLIST;
          if ( TypeOfInt( element[firstebene][secondebene] ) <> OT_DICTIONARY )
            thirdebene := nr;
            tile := BuildItems( layout, data, element[firstebene][secondebene][nr],
                                firstebene, secondebene );
          else
            if ( TypeOfInt( nr ) == OT_STRING )
              thirdebene := nr;
            else
              thirdebene := element[firstebene][secondebene].keys()[nr];
            endif
            layout := dataelementMenu.getprop( "LayoutSub_" + firstebene + "_" + secondebene + "_" + thirdebene );
            data := dataelementMenu.getprop( "DataSub_" + firstebene + "_" + secondebene + "_" + thirdebene );
          endif

        FOURTHLIST:
          ebene := FIFTHLIST;
          if ( TypeOfInt( element[firstebene][secondebene][thirdebene] ) <> OT_DICTIONARY )
            fourthebene := nr;
            tile := BuildItems( layout, data, element[firstebene][secondebene][thirdebene][nr],
                                firstebene, secondebene, thirdebene );
          else
            ebene := FIFTHLIST;
            if ( TypeOfInt( nr ) == OT_STRING )
              fourthebene := nr;
            else
              fourthebene := element[firstebene][secondebene][thirdebene].keys()[
                                                                                 nr];
            endif
            layout := dataelementMenu.getprop( "LayoutSub_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene );
            data := dataelementMenu.getprop( "DataSub_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene );
          endif

        FIFTHLIST:
          ebene := ITEMLIST;
          if ( TypeOfInt( element[firstebene][secondebene][thirdebene][fourthebene] )
               <> OT_DICTIONARY )
            fifthebene := nr;
            tile := BuildItems( layout, data, element[firstebene][secondebene][thirdebene][fourthebene][nr],
                                firstebene, secondebene, thirdebene, fourthebene );
          else
            ebene := ITEMLIST;
            if ( TypeOfInt( nr ) == OT_STRING )
              fifthebene := nr;
            else
              fifthebene := element[firstebene][secondebene][thirdebene][fourthebene].keys()[
                                                                                             nr];
            endif
            layout := dataelementMenu.getprop( "LayoutSub_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene );
            data := dataelementMenu.getprop( "DataSub_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene );
          endif

        ITEMLIST:
        ITEMLISTDUMMY:
          ebene := ITEMLISTDUMMY;
          if ( TypeOfInt( nr ) == OT_STRING )
            itemebene := nr;
          else
            itemebene := element[firstebene][secondebene][thirdebene][fourthebene][fifthebene][nr];
          endif
          tile := BuildItems( layout, data, element[firstebene][secondebene][thirdebene][fourthebene][fifthebene][nr],
                              firstebene, secondebene, thirdebene, fourthebene, fifthebene,
                              itemebene[1] );

      endcase
      ret := SendDialogGump( who, layout, data, 10, 50 );

    elseif ( ret[BACKBUTTON] ) // Back
      ebene -= 2; // 2 because one was added beforehand
      if ( ebene < 0 )
        ebene := ROOTLIST;
      endif
      case ( ebene )
        ROOTLIST:
          back := 1;
        FIRSTLIST:
          back := firstebene;
        SECONDLIST:
          back := secondebene;
        THIRDLIST:
          back := thirdebene;
        FOURTHLIST:
          back := fourthebene;
        FIFTHLIST:
          back := fifthebene;
        ITEMLIST:
          back := itemebene;
        ITEMLISTDUMMY:
          back := itemebene;
      endcase

    // The Interesting Junk Item Creation
    elseif ( ret[ITEMCREATE] )
      ebene -= 1;
      back := nr; // So that there is no final lock loop with Create
      color := ret[ITEMCOLOR];
      color[1, 6] := "";
      color := CInt( color );
      case ( tile[1][2] )
        "Random":
          CreateRandom( who, ret, tile[2], tile[3], color, tile[1][1] );
        "Einzel":
          CreateEinzel( who, ret, tile[2], color );
        "Set":
          CreateSet( who, ret, tile[2], color );
        default:
          SendSysMessage( who, "error..." );
          return;
      endcase

    // Manual ItemModify
    elseif ( ret[ITEMMODIFYMANUAL] )
      ModifyItemsManual( who );
      back := 1;
      ebene := ROOTLIST;
    else
      return; // Winke
    endif
  endwhile
endfunction // }}}

///////////////////////////////////
// BuildItems - get layout / data +
// special stuff from Itemcreategumps
///////////////////////////////////

function BuildItems( byref layout, byref data, byref element, firstebene, secondebene := 0,
                     thirdebene := 0, fourthebene := 0, fifthebene := 0, itemebene := 0 )
  // {{{
  var tiles := {};
  var tiles1 := {};
  var splittiles := {};

  if ( itemebene )
    layout := dataelementMenu.getprop( "LayoutItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene + "_" + itemebene );
    data := dataelementMenu.getprop( "DataItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene + "_" + itemebene );
  elseif ( fifthebene )
    layout := dataelementMenu.getprop( "LayoutItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene );
    data := dataelementMenu.getprop( "DataItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + fifthebene );
  elseif ( fourthebene )
    layout := dataelementMenu.getprop( "LayoutItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + element[1] );
    data := dataelementMenu.getprop( "DataItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + fourthebene + "_" + element[1] );
  elseif ( thirdebene )
    layout := dataelementMenu.getprop( "LayoutItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + element[1] );
    data := dataelementMenu.getprop( "DataItem_" + firstebene + "_" + secondebene + "_" + thirdebene + "_" + element[1] );
  elseif ( secondebene )
    layout := dataelementMenu.getprop( "LayoutItem_" + firstebene + "_" + secondebene + "_" + element[1] );
    data := dataelementMenu.getprop( "DataItem_" + firstebene + "_" + secondebene + "_" + element[1] );
  elseif ( firstebene )
    layout := dataelementMenu.getprop( "LayoutItem_" + firstebene + "_" + element[1] );
    data := dataelementMenu.getprop( "DataItem_" + firstebene + "_" + element[1] );
  endif

  // Build an array of items
  case ( element[2] )
    "Random":
      foreach tile in ( GetConfigStringArray( cfgrandom[element[1]], "tile" ) )
        splittiles := SplitWords( tile );
        tiles.append( splittiles[1] );
        if ( splittiles[2] )
          tiles1.append( splittiles[2] );
        endif
      endforeach

    "Einzel":
      foreach tile in ( GetConfigStringArray( cfgeinzel[element[1]], "tile" ) )
        if ( !tiles )
          tiles := { tile };
        else
          tiles.append( tile );
        endif
      endforeach

    "Set":
      tiles := element[1];

  endcase
  return ( { element, tiles, tiles1 } );
endfunction // }}}

///////////////////////////////////
// CreateRandom - ...
///////////////////////////////////

function CreateRandom( who, byref ret, byref tiles, byref tiles1, byref color, byref element )
  // {{{
  var tar1, tar2, item, x, y, z, Tarx, Tary, Tarx2, Tary2, itemdef, items := {},
            itemserials := {};

  SendSysMessage( who, "Target first corner" );
  tar1 := TargetCoordinates( who );
  if ( tar1 )
    SendSysMessage( who, "Target the second corner" );
    tar2 := TargetCoordinates( who );
    if ( tar2 )
      if ( ( tar1.item ) || ( tar2.item ) )
        if ( ( tar1.item.container ) || ( tar2.item.container ) )
          SendSysMessage( who, "cancellation. Item in Container targeted!" );
          return;
        endif
      endif
      if ( tar1.x >= tar2.x ) // Sorting the area
        Tarx := tar2.x;
        Tarx2 := tar1.x;
      else
        Tarx := tar1.x;
        Tarx2 := tar2.x;
      endif
      if ( tar1.y >= tar2.y )
        Tary := tar2.y;
        Tary2 := tar1.y;
      else
        Tary := tar1.y;
        Tary2 := tar2.y;
      endif
      if ( ( ( Tarx2 - Tarx ) > MAXAREASIZE ) || ( ( Tary2 - Tary ) > MAXAREASIZE ) )
        SendSysMessage( who, "Cancellation.  " + MAXAREASIZE + "x" + MAXAREASIZE + " Generate items!" );
        return;
      endif
      z := ret[ITEMPOS];
      z[1, 6] := "";
      z := CInt( z );
      // Begrenzte Ausdehnung?
      if ( GetConfigString( cfgrandom[element], "x" ) )
        Tarx2 := Tarx + CInt( GetConfigString( cfgrandom[element], "x" ) ) - 1;
      endif
      if ( GetConfigString( cfgrandom[element], "y" ) )
        Tary2 := Tary + CInt( GetConfigString( cfgrandom[element], "y" ) ) - 1;
      endif
      if ( ret[ITEMRAND] ) // Random items are to be generated
        for ( x := Tarx; x <= Tarx2; x += 1 )
          for ( y := Tary; y <= Tary2; y += 1 )
            if ( ( x == Tarx ) && ( y == Tary ) ) // NW corner
              itemdef := GetConfigString( cfgrandom[element], "nw" );
              if ( !itemdef )
                SendSysMessage( who, "NW corner is missing." );
              else
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z,
                                              CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create Error!  " + x + " " + y + " " + (
                                  tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex(
                                  itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
              // Create second item
              itemdef := GetConfigString( cfgrandom[element], "nw1" );
              if ( ( itemdef ) && ( itemdef <> {} ) )
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z,
                                              CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! NW-Corner 2nd item" + x + " " + y + " " + (
                                  tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex(
                                  itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
            elseif ( ( x == Tarx2 ) && ( y == Tary ) ) // NE corner
              itemdef := GetConfigString( cfgrandom[element], "no" );
              if ( !itemdef )
                SendSysMessage( who, "NE corner missing." );
              else
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z,
                                              CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! NE-corner Item " + x + " " + y + " " + (
                                  tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex(
                                  itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
              // Create second item
              itemdef := GetConfigString( cfgrandom[element], "no1" );
              if ( ( itemdef ) && ( itemdef <> {} ) )
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z,
                                              CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! NE-Corner 2nd item " + x + " " + y + " " + (
                                  tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex(
                                  itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
            elseif ( ( x == Tarx2 ) && ( y == Tary2 ) ) // SE corner
              itemdef := GetConfigString( cfgrandom[element], "so" );
              if ( !itemdef )
                SendSysMessage( who, "SE-Corner is missing." );
              else
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z,
                                              CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! SO-Ecke Item " + x + " " + y + " " + (
                                  tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex(
                                  itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
              // Create second item
              itemdef := GetConfigString( cfgrandom[element], "so1" );
              if ( ( itemdef ) && ( itemdef <> {} ) )
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z,
                                              CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! SE-Corner 2nd item " + x + " " + y + " " + (
                                  tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex(
                                  itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
            elseif ( ( x == Tarx ) && ( y == Tary2 ) ) // SW corner
              itemdef := GetConfigString( cfgrandom[element], "sw" );
              if ( !itemdef )
                SendSysMessage( who, "SW-Corner is missing." );
              else
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z,
                                              CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! SW-corner Item " + x + " " + y + " " + (
                                  tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex(
                                  itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
              // Create second item
              itemdef := GetConfigString( cfgrandom[element], "sw1" );
              if ( ( itemdef ) && ( itemdef <> {} ) )
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z,
                                              CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! SW-Corner 2nd item " + x + " " + y + " " + (
                                  tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex(
                                  itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
            elseif ( y == Tary ) // N page
              itemdef := GetConfigString( cfgrandom[element], "n" );
              if ( !itemdef )
                SendSysMessage( who, "N-Page is missing." );
              else
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z,
                                              CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! N-Item page " + x + " " + y + " " + (
                                  tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex(
                                  itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
              // Create second item
              itemdef := GetConfigString( cfgrandom[element], "n1" );
              if ( ( itemdef ) && ( itemdef <> {} ) )
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z,
                                              CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! N-Page 2nd item " + x + " " + y + " " + (
                                  tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex(
                                  itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
            elseif ( x == Tarx2 ) // E side
              itemdef := GetConfigString( cfgrandom[element], "o" );
              if ( !itemdef )
                SendSysMessage( who, "E-side is missing." );
              else
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z,
                                              CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! E-side item " + x + " " + y + " " + (
                                  tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex(
                                  itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
              // Create second item
              itemdef := GetConfigString( cfgrandom[element], "o1" );
              if ( ( itemdef ) && ( itemdef <> {} ) )
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z,
                                              CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! E-side 2nd item " + x + " " + y + " " + (
                                  tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex(
                                  itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
            elseif ( y == Tary2 ) // S side
              itemdef := GetConfigString( cfgrandom[element], "s" );
              if ( !itemdef )
                SendSysMessage( who, "S side is missing." );
              else
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z,
                                              CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! S-Item page " + x + " " + y + " " + (
                                  tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex(
                                  itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
              // Create second item
              itemdef := GetConfigString( cfgrandom[element], "s1" );
              if ( ( itemdef ) && ( itemdef <> {} ) )
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z,
                                              CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! S-side 2nd item " + x + " " + y + " " + (
                                  tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex(
                                  itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
            elseif ( x == Tarx ) // W page
              itemdef := GetConfigString( cfgrandom[element], "w" );
              if ( !itemdef )
                SendSysMessage( who, "W-Page is missing." );
              else
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z,
                                              CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! W side item " + x + " " + y + " " + (
                                  tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex(
                                  itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
              // Create second item
              itemdef := GetConfigString( cfgrandom[element], "w1" );
              if ( ( itemdef ) && ( itemdef <> {} ) )
                itemdef := SplitWords( itemdef );
                itemdef := ChooseRandom( itemdef );
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z,
                                              CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! W-Page 2nd item " + x + " " + y + " " + (
                                  tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex(
                                  itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
            else // centerpiece
              itemdef := ChooseRandom( tiles );
              if ( !itemdef )
                SendSysMessage( who, "Middle piece is missing." );
              else
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z,
                                              CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! Midsection item " + x + " " + y + " " + (
                                  tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex(
                                  itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
              // Create second item
              itemdef := tiles1.randomentry();
              if ( ( itemdef ) && ( itemdef <> {} ) )
                itemdef := SplitWords( itemdef, "," );
                item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z,
                                              CInt( itemdef[1] ), 1, who.realm );
                if ( item )
                  item.color := color;
                  item.movable := 0;
                  items.append( item );
                else
                  SendSysMessage( who, "Create error! Middle part 2nd item " + x + " " + y + " " + (
                                  tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex(
                                  itemdef[1] ) + " ErrorText: " + item.errortext );
                endif
              endif
            endif
            SleepMS( 5 );
          endfor
        endfor
      else // Boring version without a border
        for ( x := Tarx; x <= Tarx2; x += 1 )
          for ( y := Tary; y <= Tary2; y += 1 )
            itemdef := ChooseRandom( tiles );
            if ( !itemdef )
              SendSysMessage( who, "Middle piece is missing." );
            else
              itemdef := SplitWords( itemdef, "," );
              item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z,
                                            CInt( itemdef[1] ), 1, who.realm );
              if ( item )
                item.color := color;
                item.movable := 0;
                items.append( item );
              else
                SendSysMessage( who, "Create error! Item " + x + " " + y + " " + (
                                tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] )
                                + " ErrorText: " + item.errortext );
              endif
            endif
            // Create second item
            itemdef := tiles1.randomentry();
            if ( ( itemdef ) && ( itemdef <> {} ) )
              itemdef := SplitWords( itemdef, "," );
              item := CreateItemAtLocation( x, y, tar1.z + CInt( itemdef[2] ) + z,
                                            CInt( itemdef[1] ), 1, who.realm );
              if ( item )
                item.color := color;
                item.movable := 0;
                items.append( item );
              else
                SendSysMessage( who, "Create error! 2nd Item " + x + " " + y + " " + (
                                tar1.z + CInt( itemdef[2] ) + z ) + " " + Hex( itemdef[1] )
                                + " ErrorText: " + item.errortext );
              endif
            endif
            SleepMS( 5 );
          endfor
        endfor
      endif
      // Save item series
      foreach item in items
        item.setprop( CPROP_INIT, items[1].serial );
        SleepMS( 2 );
      endforeach
      foreach item in items
        itemserials.append( item.serial );
        SleepMS( 2 );
      endforeach
      items[1].setprop( CPROP_ITEMS, itemserials );

      if ( ret[ITEMMODIFY] ) // Change position
        if ( !ModifyItems( who, items ) )
          return;
        endif
      endif
    else
      SendSysMessage( who, "Abort" );
    endif
  else
    SendSysMessage( who, "Abort" );
  endif
endfunction // }}}

///////////////////////////////////
// Create singles - ...
///////////////////////////////////

function CreateEinzel( who, byref ret, byref tiles, byref color ) // {{{
  var z, itemdef := {}, iTarget, item, items := {}, itemserials := {};

  if ( !tiles[ret.keys[2]] )
    SendSysMessage( who, "No item selected" );
    return;
  endif
  SendSysMessage( who, "Target position" );
  z := ret[ITEMPOS];
  z[1, 6] := "";
  z := CInt( z );
  itemdef[1] := CInt( SplitWords( tiles[ret.keys[2]], "," )[1] ); // Objtype
  itemdef[2] := CInt( SplitWords( tiles[ret.keys[2]], "," )[2] ); // Feste z-Koords
  iTarget := TargetCoordinates( who );
  if ( iTarget.item )
    if ( iTarget.item.container )
      SendSysMessage( who, "cancellation. Item in Container targeted!" );
      return;
    endif
  endif
  while ( iTarget ) // Endless to ESC
    item := CreateItemAtLocation( iTarget.x, iTarget.y, iTarget.z + itemdef[2] + z,
                                  itemdef[1], 1, who.realm );
    if ( item )
      item.color := color;
      item.movable := 0;
      // Save item series
      if ( !ret[ITEMMMULTICREATE] )
        item.setprop( CPROP_INIT, item.serial );
        item.setprop( CPROP_ITEMS, { item.serial } );
        if ( ret[ITEMMODIFY] ) // Change position
          if ( !ModifyItems( who, item ) )
            SendSysMessage( who, "Abort" );
            return;
          endif
        endif
      else
        items.append( item );
      endif
    else
      SendSysMessage( who, "Create error! Item " + iTarget.x + " " + iTarget.y + " " + (
                      iTarget.z + itemdef[2] + z ) + " " + Hex( tiles[ret.keys[2]] )
                      + " ErrorText: " + item.errortext );
    endif
    iTarget := TargetCoordinates( who );
  endwhile
  if ( ret[ITEMMMULTICREATE] )
    // Itemserials to save
    foreach item in items
      item.setprop( CPROP_INIT, items[1].serial );
    endforeach
    foreach item in items
      itemserials.append( item.serial );
    endforeach
    items[1].setprop( CPROP_ITEMS, itemserials );
    if ( ret[ITEMMODIFY] ) // Postion to change
      ModifyItems( who, items );
    endif
  endif
  SendSysMessage( who, "Abort" );
endfunction // }}}

///////////////////////////////////
// CreateSet - ...
///////////////////////////////////

function CreateSet( unused who, byref unused ret, byref unused set, byref unused color )
/* Var iTarget, items, itemserials:={}, wholeitems:={};
  Var z:=ret[ITEMPOS];
  z[1,6]:="";
  z:=CInt(z);

  iTarget:=TargetCoordinates(who);
  If (iTarget.item)
    If (iTarget.item.container)
      SendSysMessage(who,"cancellation. Item in Container targeted!");
      Return;
    EndIf
  EndIf
  While (iTarget)  // Endless to ESC
    iTarget.z:=iTarget.z+z;
    items:=MakeSet(iTarget, set, 1)[2];
    If (items)
      If (color)
        ForEach item in items
          item.color:=color;
          SleepMS(2);
        EndForEach
      EndIf
      If (!ret[ITEMMMULTICREATE])
        // Save item series
        itemserials:={};
        ForEach item in items
          item.setprop(CPROP_INIT,items[1].serial);
          SleepMS(2);
        EndForEach
        ForEach item in items
          itemserials.append(item.serial);
          SleepMS(2);
        EndForEach
        items[1].setprop(CPROP_ITEMS,itemserials);

        If (ret[ITEMMODIFY])  // Change position
          If (!ModifyItems(who,items))
            Return;
          EndIf
        EndIf
      Else
        ForEach item in items
          wholeitems.append(item);
          SleepMS(2);
        EndForEach
      EndIf
    Else
      SendSysMessage(who,"Something went wrong.");
      Return;
    EndIf
    iTarget:=TargetCoordinates(who);
  EndWhile
  If (ret[ITEMMMULTICREATE])
    // Save item series
    ForEach item in wholeitems
      item.setprop(CPROP_INIT,wholeitems[1].serial);
      SleepMS(2);
    EndForEach
    ForEach item in wholeitems
      itemserials.append(item.serial);
      SleepMS(2);
    EndForEach
    wholeitems[1].setprop(CPROP_ITEMS,itemserials);
    If (ret[ITEMMODIFY])  // Change position
      ModifyItems(who,items);
    EndIf
  EndIf
  SendSysMessage(who, "Abort"); */
endfunction

///////////////////////////////////
// ModifyItemsManual - ...
///////////////////////////////////

function ModifyItemsManual( who ) // {{{
  var retmodify, tar, inititem, items := {}, itemserials := {}, color, zstart, zend,
                 temp, i, obj, tempitems := {};
  var tar1, tar2, x1, x2, y1, y2, breakflag;
  var dupe := {}, dupeitem, dupeserials := {};

  while ( who.connected )
    if ( items <> {} )
      datamodify_M[COLORDATAPOS] := items[1].color;
      datamodify_M[XKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>" + items[1].x + "</p></basefont>";
      datamodify_M[YKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>" + items[1].y + "</p></basefont>";
      datamodify_M[ZKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>" + items[1].z + "</p></basefont>";
      datamodify_M[XENTRY] := items[1].x;
      datamodify_M[YENTRY] := items[1].y;
      datamodify_M[ZENTRY] := items[1].z;
    else
      datamodify_M[COLORDATAPOS] := "0";
      datamodify_M[XKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>x</p></basefont>";
      datamodify_M[YKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>y</p></basefont>";
      datamodify_M[ZKOORDSPOS] := "<basefont color=" + HTML_DARKBLUE + "><p align=right>z</p></basefont>";
      datamodify_M[XENTRY] := 0;
      datamodify_M[YENTRY] := 0;
      datamodify_M[ZENTRY] := 0;
    endif
    retmodify := SendDialogGump( who, layoutmodify_M, datamodify_M, 10, 50 );
    if ( retmodify[MODIFY_START] )
      if ( !retmodify[MODIFY_CUSTOM] ) // Search for .bautool items
        tar := Target( who, TGTOPT_NOCHECK_LOS );
        if ( tar )
          if ( ( !tar.getprop( CPROP_ITEMS ) ) && ( tar.getprop( CPROP_INIT ) ) )
            inititem := SystemFindObjectBySerial( tar.getprop( CPROP_INIT ) );
            if ( inititem )
              itemserials := inititem.getprop( CPROP_ITEMS );
              items := {};
              tempitems := {};
              foreach item in itemserials
                obj := SystemFindObjectBySerial( item );
                if ( obj )
                  if ( CInt( obj.getprop( CPROP_INIT ) ) == CInt( inititem.serial )
                       ) // it belongs to the same group
                    items.append( obj );
                    tempitems.append( obj.serial );
                  endif
                endif
                SleepMS( 5 );
              endforeach
              inititem.setprop( CPROP_ITEMS, tempitems ); // save filtered serials
              if ( ( !items ) || ( items == {} ) )
                SendSysMessage( who, "Items could not be found. " );
              else
                SendSysMessage( who, items.size() + " Items recognized." );
              endif
            else
              SendSysMessage( who, "Init item not found. " );
              items := RecoverInitItem( tar );
            // items:={};
            endif
          elseif ( tar.getprop( CPROP_ITEMS ) )
            itemserials := tar.getprop( CPROP_ITEMS );
            items := {};
            tempitems := {};
            foreach item in itemserials
              obj := SystemFindObjectBySerial( item );
              if ( obj )
                if ( CInt( obj.getprop( CPROP_INIT ) ) == CInt( tar.serial ) ) // it belongs to the same group
                  items.append( obj );
                  tempitems.append( obj.serial );
                endif
              endif
              SleepMS( 5 );
            endforeach
            tar.setprop( CPROP_ITEMS, tempitems ); // save filtered serials
            SendSysMessage( who, items.size() + " Items recognized." );
          else
            SendSysMessage( who, "Invalid Item selected." );
          endif
        else
          SendSysMessage( who, "Abort" );
          items := {};
        endif
      else // Search for any items
        zstart := retmodify[MODIFY_Z_START];
        zstart[1, 6] := "";
        zstart := CInt( zstart );
        zend := retmodify[MODIFY_Z_END];
        zend[1, 6] := "";
        zend := CInt( zend );
        datamodify_M[ZSTARTPOS] := zstart;
        datamodify_M[ZENDPOS] := zend;
        SendSysMessage( who, "Target the first corner of the area" );
        tar1 := TargetCoordinates( who );
        if ( tar1 )
          SendSysMessage( who, "Target the second corner of the area" );
          tar2 := TargetCoordinates( who );
          if ( tar2 )
            if ( tar1.x > tar2.x ) // Sorting the area
              x1 := tar2.x;
              x2 := tar1.x;
            else
              x1 := tar1.x;
              x2 := tar2.x;
            endif
            if ( tar1.y > tar2.y )
              y1 := tar2.y;
              y2 := tar1.y;
            else
              y1 := tar1.y;
              y2 := tar2.y;
            endif
            items := {};
            foreach item in ListObjectsInBox( x1, y1, zstart, x2, y2, zend, tar2.realm )
              if ( item.isA( POLCLASS_ITEM ) )
                if ( !item.invisible ) // Don't take invisible stuff like spawn runes
                  items.append( item );
                endif
              endif
              SleepMS( 5 );
            endforeach
            if ( items <> {} )
              SendSysMessage( who, items.size() + " Items recognized." );
              if ( retmodify[MODIFY_MARK] )
                // Save item series
                itemserials := {};
                foreach item in items
                  itemserials.append( item.serial );
                  SleepMS( 2 );
                endforeach
                SendSysMessage( who, "Choose the original item." );
                breakflag := 0;
                while ( who.connected )
                  tar := Target( who, TGTOPT_NOCHECK_LOS );
                  if ( tar )
                    i := tar.serial in itemserials;
                    if ( i ) // Move the selected item to the first position
                      temp := itemserials[1];
                      itemserials[i] := temp;
                      itemserials[1] := tar.serial;
                      foreach item in items
                        item.setprop( CPROP_INIT, tar.serial );
                        item.eraseprop( CPROP_ITEMS );
                        SleepMS( 2 );
                      endforeach
                      tar.setprop( CPROP_ITEMS, itemserials );
                      break;
                    else
                      SendSysMessage( who, "Item is not among those recognized!" );
                    endif
                  else
                    SendSysMessage( who, "Abort" );
                    breakflag := 1;
                    break;
                  endif
                endwhile
                items := {};
                if ( !breakflag )
                  foreach item in itemserials // Reordering and final check
                    obj := SystemFindObjectBySerial( item );
                    if ( obj )
                      items.append( obj );
                    endif
                    SleepMS( 5 );
                  endforeach
                  SendSysMessage( who, ".. and branded." );
                endif
              endif
            else
              SendSysMessage( who, "No items recognized." );
            endif
          else
            SendSysMessage( who, "Abort" );
            items := {};
          endif
        else
          SendSysMessage( who, "Abort" );
          items := {};
        endif
      endif
    else
      if ( retmodify.keys[retmodify.keys.size()] > MODIFY_START )
        if ( items <> {} )
          if ( retmodify[MODIFY_Y_UP] )
            foreach item in items
              MoveObjectToLocation( item, item.x, item.y + 1, item.z, item.realm,
                                    ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_Y_DOWN] )
            foreach item in items
              MoveObjectToLocation( item, item.x, item.y - 1, item.z, item.realm,
                                    ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_X_UP] )
            foreach item in items
              MoveObjectToLocation( item, item.x + 1, item.y, item.z, item.realm,
                                    ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_X_DOWN] )
            foreach item in items
              MoveObjectToLocation( item, item.x - 1, item.y, item.z, item.realm,
                                    ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_XY_MM] )
            foreach item in items
              MoveObjectToLocation( item, item.x - 1, item.y - 1, item.z, item.realm,
                                    ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_XY_PM] )
            foreach item in items
              MoveObjectToLocation( item, item.x + 1, item.y - 1, item.z, item.realm,
                                    ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_XY_MP] )
            foreach item in items
              MoveObjectToLocation( item, item.x - 1, item.y + 1, item.z, item.realm,
                                    ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_XY_PP] )
            foreach item in items
              MoveObjectToLocation( item, item.x + 1, item.y + 1, item.z, item.realm,
                                    ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_Z_UP] )
            foreach item in items
              MoveObjectToLocation( item, item.x, item.y, item.z + 1, item.realm,
                                    ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_Z_DOWN] )
            foreach item in items
              MoveObjectToLocation( item, item.x, item.y, item.z - 1, item.realm,
                                    ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_DESTROY] )
            foreach item in items
              DestroyItem( item );
              SleepMS( 2 );
            endforeach
            items := {};
          elseif ( retmodify[MODIFY_COLOR] )
            color := retmodify[ITEMCOLOR];
            color[1, 6] := "";
            color := CInt( color );
            foreach item in items
              item.color := color;
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_DUPE] )
            dupe := {};
            dupeserials := {};
            foreach item in items
              dupeitem := CreateItemCopyAtLocation( item.x, item.y, item.z, item,
                                                    item.realm );
              if ( dupeitem )
                dupe.append( dupeitem );
                dupeserials.append( dupeitem.serial );
              endif
              SleepMS( 2 );
            endforeach
            foreach item in dupe
              item.setprop( CPROP_INIT, dupeserials[1] );
              SleepMS( 2 );
            endforeach
            dupe[1].setprop( CPROP_ITEMS, dupeserials );
            SendSysMessage( who, dupe.size() + " Items successfully duplicated." );
            items := dupe; // Continue working with a copy
          elseif ( retmodify[MODIFY_X] )
            temp := retmodify[MODIFY_X_ENTRY];
            temp[1, 6] := "";
            temp := CInt( temp ) - items[1].x;
            foreach item in items
              MoveObjectToLocation( item, item.x + temp, item.y, item.z, item.realm,
                                    ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_Y] )
            temp := retmodify[MODIFY_Y_ENTRY];
            temp[1, 6] := "";
            temp := CInt( temp ) - items[1].y;
            foreach item in items
              MoveObjectToLocation( item, item.x, item.y + temp, item.z, item.realm,
                                    ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          elseif ( retmodify[MODIFY_Z] )
            temp := retmodify[MODIFY_Z_ENTRY];
            temp[1, 6] := "";
            temp := CInt( temp ) - items[1].z;
            foreach item in items
              MoveObjectToLocation( item, item.x, item.y, item.z + temp, item.realm,
                                    ITEMMOVEFLAGS );
              SleepMS( 2 );
            endforeach
          endif
        else
          SendSysMessage( who, "No items selected." );
        endif
      elseif ( retmodify[MODIFY_MARKEDIT] )
        MarkEdit( who );
      else // Gump closed
        SendSysMessage( who, "Abort" );
        break;
      endif
    endif
  endwhile
endfunction // }}}

///////////////////////////////////
// MarkEdit - Possibility to change the groups
///////////////////////////////////

function MarkEdit( who ) // {{{
  var ret, tar1, tar2, x1, x2, y1, y2, items := {}, itemref, inititem, itemserials,
           tempitems, obj, i;

  while ( who.connected )
    ret := SendDialogGump( who, layoutmark, datamark, 10, 50 );

    if ( ret[MARK_SHOW] )
      SendSysMessage( who, "Target the first corner of the area" );
      tar1 := TargetCoordinates( who );
      if ( tar1 )
        SendSysMessage( who, "Target the second corner of the area" );
        tar2 := TargetCoordinates( who );
        if ( tar2 )
          if ( tar1.x > tar2.x ) // Sorting the area
            x1 := tar2.x;
            x2 := tar1.x;
          else
            x1 := tar1.x;
            x2 := tar2.x;
          endif
          if ( tar1.y > tar2.y )
            y1 := tar2.y;
            y2 := tar1.y;
          else
            y1 := tar1.y;
            y2 := tar2.y;
          endif
          items := {};
          foreach item in ListObjectsInBox( x1, y1, -127, x2, y2, 128, tar2.realm )
            // Items besorgen
            if ( item.isA( POLCLASS_ITEM ) )
              if ( item.getprop( CPROP_ITEMS ) )
                items.append( item );
              endif
            endif
            SleepMS( 5 );
          endforeach
          if ( items <> {} )
            foreach item in items // Coloring by groups
              foreach slaveitem in ( item.getprop( CPROP_ITEMS ) )
                itemref := SystemFindObjectBySerial( slaveitem );
                if ( itemref )
                  if ( itemref.getprop( CPROP_COLOR ).errortext )
                    itemref.setprop( CPROP_COLOR, itemref.color );
                  endif
                  itemref.color := _item_iter + 6;
                endif
                SleepMS( 5 );
              endforeach
            endforeach
          endif
        endif
      endif

    elseif ( ret[MARK_HIDE] )
      SendSysMessage( who, "Target the first corner of the area" );
      tar1 := TargetCoordinates( who );
      if ( tar1 )
        SendSysMessage( who, "Target the second corner of the area" );
        tar2 := TargetCoordinates( who );
        if ( tar2 )
          if ( tar1.x > tar2.x ) // Sorting the area
            x1 := tar2.x;
            x2 := tar1.x;
          else
            x1 := tar1.x;
            x2 := tar2.x;
          endif
          if ( tar1.y > tar2.y )
            y1 := tar2.y;
            y2 := tar1.y;
          else
            y1 := tar1.y;
            y2 := tar2.y;
          endif
          items := {};
          foreach item in ListObjectsInBox( x1, y1, -127, x2, y2, 128, tar2.realm )
            // Items besorgen
            if ( item.isA( POLCLASS_ITEM ) )
              if ( item.getprop( CPROP_ITEMS ) )
                items.append( item );
              endif
            endif
            SleepMS( 5 );
          endforeach
          if ( items <> {} )
            foreach item in items // Coloring by groups
              foreach slaveitem in ( item.getprop( CPROP_ITEMS ) )
                itemref := SystemFindObjectBySerial( slaveitem );
                if ( itemref )
                  if ( itemref.getprop( CPROP_COLOR ).errortext )
                    itemref.setprop( CPROP_COLOR, itemref.color );
                  endif
                  itemref.color := _item_iter + 6;
                endif
                SleepMS( 5 );
              endforeach
            endforeach
          endif

          foreach item in ListObjectsInBox( x1, y1, -128, x2, y2, 127, tar2.realm )
            // Freset work
            if ( item.isA( POLCLASS_ITEM ) )
              if ( ( item.getprop( CPROP_ITEMS ) ) && ( !item.getprop( CPROP_COLOR ).
                   errortext ) )
                foreach slaveitem in ( item.getprop( CPROP_ITEMS ) )
                  itemref := SystemFindObjectBySerial( slaveitem );
                  if ( itemref )
                    if ( !itemref.getprop( CPROP_COLOR ).errortext )
                      itemref.color := CInt( item.getprop( CPROP_COLOR ) );
                      itemref.eraseprop( CPROP_COLOR );
                    endif
                  endif
                  SleepMS( 5 );
                endforeach
              endif
            endif
            SleepMS( 5 );
          endforeach
        endif
      endif

    elseif ( ret[MARK_EDIT] )
      SendSysMessage( who, "Selects the item group." );
      tar1 := Target( who, TGTOPT_NOCHECK_LOS );
      items := {};
      tempitems := {};
      if ( ( !tar1.getprop( CPROP_ITEMS ) ) && ( tar1.getprop( CPROP_INIT ) ) )
        inititem := SystemFindObjectBySerial( tar1.getprop( CPROP_INIT ) );
        if ( inititem )
          itemserials := inititem.getprop( CPROP_ITEMS );
          foreach item in itemserials
            obj := SystemFindObjectBySerial( item );
            if ( obj )
              if ( ( CInt( obj.getprop( CPROP_INIT ) ) == CInt( inititem.serial )
                   ) && ( !( obj.serial in tempitems ) ) ) // it belongs to the same group
                items.append( obj );
                tempitems.append( obj.serial );
                if ( obj.getprop( CPROP_COLOR ).errortext )
                  obj.setprop( CPROP_COLOR, obj.color );
                endif
                obj.color := 1281;
              endif
            endif
            SleepMS( 5 );
          endforeach
          inititem.setprop( CPROP_ITEMS, tempitems ); // save filtered serials
          if ( ( !items ) || ( items == {} ) )
            SendSysMessage( who, "Items could not be found. " );
          else
            SendSysMessage( who, items.size() + " Items recognized." );
          endif
        else
          SendSysMessage( who, "Init item not found. " );
          items := RecoverInitItem( tar1 );
        // items:={};
        endif
      elseif ( tar1.getprop( CPROP_ITEMS ) )
        itemserials := tar1.getprop( CPROP_ITEMS );
        foreach item in itemserials
          obj := SystemFindObjectBySerial( item );
          if ( obj )
            if ( CInt( obj.getprop( CPROP_INIT ) ) == CInt( tar1.serial ) ) // it belongs to the same group
              items.append( obj );
              tempitems.append( obj.serial );
              if ( obj.getprop( CPROP_COLOR ).errortext )
                obj.setprop( CPROP_COLOR, obj.color );
              endif
              obj.color := 1281;
            endif
          endif
          SleepMS( 5 );
        endforeach
        tar1.setprop( CPROP_ITEMS, tempitems ); // save filtered serials
        SendSysMessage( who, items.size() + " Items recognized." );
      else
        SendSysMessage( who, "No items recognized." );
      endif
      if ( items <> {} )
        while ( who.connected )
          SendSysMessage( who, "Selects the item to be added / removed." );
          tar1 := Target( who, TGTOPT_NOCHECK_LOS );
          if ( ( !tar1 ) && ( !tar1.isA( POLCLASS_ITEM ) ) )
            SendSysMessage( who, "Abort" );
            break;
          endif
          i := tar1.serial in tempitems;
          if ( i ) // Remove from group
            tempitems.erase( i );
            items.erase( i );
            tar1.eraseprop( CPROP_INIT );
            tar1.eraseprop( CPROP_ITEMS );
            if ( !tar1.getprop( CPROP_COLOR ).errortext )
              tar1.color := CInt( tar1.getprop( CPROP_COLOR ) );
              tar1.eraseprop( CPROP_COLOR );
            endif
          else // Add
            if ( tar1.getprop( CPROP_COLOR ).errortext )
              tar1.setprop( CPROP_COLOR, tar1.color );
            endif
            tar1.color := items[1].color;
            tempitems.append( tar1.serial );
            items.append( tar1 );
          endif
        endwhile

        foreach item in items
          item.setprop( CPROP_INIT, items[1].serial );
          item.eraseprop( CPROP_ITEMS );
        endforeach
        items[1].setprop( CPROP_ITEMS, tempitems );
        foreach item in items
          if ( !item.getprop( CPROP_COLOR ).errortext )
            item.color := CInt( item.getprop( CPROP_COLOR ) );
            item.eraseprop( CPROP_COLOR );
          endif
          SleepMS( 1 );
        endforeach
      endif
    else
      if ( x1 ) // If something has been done, reset the color
        foreach item in ListObjectsInBox( x1, y1, -128, x2, y2, 127, tar2.realm )
          // Freset work
          if ( item.isA( POLCLASS_ITEM ) )
            if ( ( item.getprop( CPROP_ITEMS ) ) && ( !item.getprop( CPROP_COLOR ).
                 errortext ) )
              foreach slaveitem in ( item.getprop( CPROP_ITEMS ) )
                itemref := SystemFindObjectBySerial( slaveitem );
                if ( itemref )
                  if ( !itemref.getprop( CPROP_COLOR ).errortext )
                    itemref.color := CInt( item.getprop( CPROP_COLOR ) );
                    itemref.eraseprop( CPROP_COLOR );
                  endif
                endif
                SleepMS( 5 );
              endforeach
            endif
          endif
          SleepMS( 5 );
        endforeach
      endif
      SendSysMessage( who, "Abort" );
      return;
    endif
  endwhile
endfunction // }}}

///////////////////////////////////
// ModifyItems - Position / color change after creation
///////////////////////////////////

function ModifyItems( who, byref items ) // {{{
  var retmodify, color, temp, dupe := {}, dupeitem, dupeserials := {};

  if ( TypeOfInt( items ) != OT_ARRAY )
    temp := items;
    items := {};
    items.append( temp );
  endif
  while ( who.connected )
    datamodify[COLORDATAPOS] := items[1].color;
    datamodify[XKOORDSPOS] := "<basefont color=" + HTML_WHITE + "><p align=right>" + items[1].x + "</p></basefont>";
    datamodify[YKOORDSPOS] := "<basefont color=" + HTML_WHITE + "><p align=right>" + items[1].y + "</p></basefont>";
    datamodify[ZKOORDSPOS] := "<basefont color=" + HTML_WHITE + "><p align=right>" + items[1].z + "</p></basefont>";
    datamodify[XENTRY] := items[1].x;
    datamodify[YENTRY] := items[1].y;
    datamodify[ZENTRY] := items[1].z;
    retmodify := SendDialogGump( who, layoutmodify, datamodify, 10, 50 );
    if ( retmodify[MODIFY_Y_UP] )
      foreach item in items
        MoveObjectToLocation( item, item.x, item.y + 1, item.z, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_Y_DOWN] )
      foreach item in items
        MoveObjectToLocation( item, item.x, item.y - 1, item.z, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_X_UP] )
      foreach item in items
        MoveObjectToLocation( item, item.x + 1, item.y, item.z, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_X_DOWN] )
      foreach item in items
        MoveObjectToLocation( item, item.x - 1, item.y, item.z, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_XY_MM] )
      foreach item in items
        MoveObjectToLocation( item, item.x - 1, item.y - 1, item.z, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_XY_PM] )
      foreach item in items
        MoveObjectToLocation( item, item.x + 1, item.y - 1, item.z, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_XY_MP] )
      foreach item in items
        MoveObjectToLocation( item, item.x - 1, item.y + 1, item.z, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_XY_PP] )
      foreach item in items
        MoveObjectToLocation( item, item.x + 1, item.y + 1, item.z, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_Z_UP] )
      foreach item in items
        MoveObjectToLocation( item, item.x, item.y, item.z + 1, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_Z_DOWN] )
      foreach item in items
        MoveObjectToLocation( item, item.x, item.y, item.z - 1, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_DESTROY] )
      foreach item in items
        DestroyItem( item );
        SleepMS( 2 );
      endforeach
      break;
    elseif ( retmodify[MODIFY_COLOR] )
      color := retmodify[ITEMCOLOR];
      color[1, 6] := "";
      color := CInt( color );
      foreach item in items
        item.color := color;
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_DUPE] )
      dupe := {};
      dupeserials := {};
      foreach item in items
        dupeitem := CreateItemCopyAtLocation( item.x, item.y, item.z, item, item.realm );
        if ( dupeitem )
          dupe.append( dupeitem );
          dupeserials.append( dupeitem.serial );
        endif
        SleepMS( 2 );
      endforeach
      foreach item in dupe
        item.setprop( CPROP_INIT, dupeserials[1] );
        SleepMS( 2 );
      endforeach
      dupe[1].setprop( CPROP_ITEMS, dupeserials );
      SendSysMessage( who, dupe.size() + " Items successfully duplicated." );
      items := dupe; // Edit copy further
    elseif ( retmodify[MODIFY_X] )
      temp := retmodify[MODIFY_X_ENTRY];
      temp[1, 6] := "";
      temp := CInt( temp ) - items[1].x;
      foreach item in items
        MoveObjectToLocation( item, item.x + temp, item.y, item.z, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_Y] )
      temp := retmodify[MODIFY_Y_ENTRY];
      temp[1, 6] := "";
      temp := CInt( temp ) - items[1].y;
      foreach item in items
        MoveObjectToLocation( item, item.x, item.y + temp, item.z, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[MODIFY_Z] )
      temp := retmodify[MODIFY_Z_ENTRY];
      temp[1, 6] := "";
      temp := CInt( temp ) - items[1].z;
      foreach item in items
        MoveObjectToLocation( item, item.x, item.y, item.z + temp, item.realm, ITEMMOVEFLAGS );
        SleepMS( 2 );
      endforeach
    elseif ( retmodify[BACKBUTTON] )
      break;
    else
      return ( 0 ); // Abbruch
    endif
  endwhile
  return ( 1 );
endfunction // }}}

///////////////////////////////////
// ChooseRandom - Random determination of the items
///////////////////////////////////

function ChooseRandom( byref liste ) // {{{
  var verteilung := 0, i;
  var rand := RandomInt( 100 ) + 1;
  if ( Find( liste[1], "%", 1 ) ) // Distribution according to Cfg
    for ( i := 1; i <= liste.size(); i += 1 )
      verteilung += CInt( SplitWords( liste[i], "%" )[2] );
      if ( rand <= verteilung )
        return ( SplitWords( liste[i], "%" )[1] );
      endif
    endfor
  else // Gleichverteilt
    verteilung := CInt( 100 / liste.size() );
    for ( i := 1; i <= liste.size(); i += 1 )
      if ( rand <= ( i * verteilung ) ) // within the probability?
        return ( liste[i] ); // Shoo Shoo
      endif
    endfor
  endif
  return ( liste.randomentry() ); // well then just like that
endfunction // }}}

///////////////////////////////////
// MenuBar - Creates the NavBar
///////////////////////////////////

function MenuBar( byref layout, byref data, byref datadict ) // {{{
  var i, page := 1, y := 66, nextpagebreak := MAXBUTTON + 1;
  if ( TypeOfInt( datadict ) == OT_DICTIONARY ) // Data in dictionary or array
    for ( i := 1; i <= datadict.keys().size(); i += 1 )
      if ( i == nextpagebreak )
        nextpagebreak += MAXBUTTON;
        y := 66;
        page += 1;
        layout.append( "button 565 287 5602 5606 0 " + page );
        layout.append( "page " + page );
        layout.append( "button 580 287 5600 5604 0 " + ( page - 1 ) );
      endif
      layout.append( "button 525 " + ( y ) + " 2440 2440 1 0 " + ( MENUSTART + i ) );
      // layout.append("resizepic 525 "+(y)+" 9250 166 25");
      layout.append( "htmlgump 525 " + ( y ) + " 166 25 " + data.size() + " 1 0" );
      if ( ( cfgrandom[datadict.keys()[i]] ) && ( cfgrandom[datadict.keys()[i]].name ) )
        data.append( "<basefont color=" + HTML_DARKGRAY + "><center>" + cfgrandom[datadict.keys()[
                     i]].name + "</center>" );
      elseif ( ( cfgeinzel[datadict.keys()[i]] ) && ( cfgeinzel[datadict.keys()[i]].name ) )
        data.append( "<basefont color=" + HTML_DARKBLUE + "><center>" + cfgeinzel[datadict.keys()[
                     i]].name + "</center>" );
      elseif ( cfgset[datadict.keys()[i]].name )
        data.append( "<basefont color=" + HTML_DARKBLUE + "><center>" + cfgset[datadict.keys()[
                     i]].name + "</center>" );
      else
        data.append( "<basefont color=" + HTML_DARKGRAY + "><center>" + datadict.keys()[
                     i] + "</center>" );
      endif
      y += 30;
    endfor
  else
    for ( i := 1; i <= datadict.size(); i += 1 )
      if ( i == nextpagebreak )
        nextpagebreak += MAXBUTTON;
        y := 66;
        page += 1;
        layout.append( "button 565 287 5602 5606 0 " + page + " 0" );
        layout.append( "page " + page );
        layout.append( "button 580 287 5600 5604 0 " + ( page - 1 ) + " 0" );
      endif
      layout.append( "button 525 " + ( y ) + " 2440 2440 1 0 " + ( MENUSTART + i ) );
      // layout.append("resizepic 525 "+(y)+" 9250 166 25");
      layout.append( "htmlgump 525 " + ( y ) + " 166 25 " + data.size() + " 1 0" );
      if ( TypeOfInt( datadict[i] ) == OT_ARRAY ) // Typebezeichnung im Array
        if ( ( cfgrandom[datadict[i][1]].name ) || ( cfgeinzel[datadict[i][1]].name ) ||
             ( cfgset[datadict[i][1]].name ) )
          case ( datadict[i][2] )
            "Random":
              data.append( "<basefont color=" + HTML_SADDLEBROWN + "><center>" + cfgrandom[datadict[i][1]].name + "</center>" );
            "Einzel":
              data.append( "<basefont color=" + HTML_SADDLEBROWN + "><center>" + cfgeinzel[datadict[i][1]].name + "</center>" );
            "Set":
              data.append( "<basefont color=" + HTML_SADDLEBROWN + "><center>" + cfgset[datadict[i][1]].name + "</center>" );
          endcase
        else
          data.append( "<basefont color=" + HTML_SADDLEBROWN + "><center>" + datadict[i][1] + "</center>" );
        endif
      endif
      y += 30;
    endfor
  endif
endfunction // }}}

///////////////////////////////////
// Init - Generates layout & data in a data file (server restart / hermit)
///////////////////////////////////

function Init() // {{{
  var layoutraw := { "nodispose", "page 0", // "resizepic 500 0 3600 215 390",  // Background
                     // "resizepic 515 15 5054 185 30",  // title
                     "resizepic 500 0 9200 215 390", "resizepic 515 15 3000 185 30",
                     "htmlgump 515 22 185 30 0 0 0", // Title text
                     // "gumppictiled 516 47 183 328 2624",
                     // "resizepic 516 47 83 183 328",   // Posts
                     "resizepic 516 47 3000 183 328", // "checkertrans 524 57 168 308",
                     "htmlgump 610 285 50 20 1 0 0", "button 660 280 9726 9728 1 0 " + BACKBUTTON,
                     "gumppictiled 525 320 166 2 30002", "button 530 330 9721 9724 1 0 " + ITEMMODIFYMANUAL,
                     "htmlgump 572 335 100 30 2 0 0", "page 1" };
  var dataraw := { "", // Titel
                   "<basefont color=" + HTML_DARKBLUE + ">Back", "<basefont color=" + HTML_DARKBLUE + ">Item Modify" };

  SysLog( ".BAUTOOL Datafile begin" );
  SetGlobalProperty( "bautoolinit", 1 );

  var dataelement, layout := {}, data := {}, layoutp := {};
  var element := dictionary;
  var cfgmenu := ReadConfigFile( "bautoolmenues" );

  DFPurgeFile( datafile );

  // Layout to build
  dataelement := datafile.CreateElement( "menu" );

  // Read out the cfgmenu and insert the 3 cfgs
  foreach key in ( GetConfigStringArray( cfgmenu["Rootlist"], "sublist" ) ) // 1. level
    element[key] := dictionary;

    if ( cfgmenu[key].list ) // Items
      foreach itemlist in ( GetConfigStringArray( cfgmenu[key], "list" ) )
        element[key][itemlist] := array;
        foreach itemkey in ( GetConfigStringKeys( cfgrandom ) ) // Insert possible random
          if ( cfgrandom[itemkey].list == itemlist )
            element[key][itemlist].append( { itemkey, "Random", cfgrandom[itemkey].name }
                                           );
          endif
          SleepMS( 2 );
        endforeach
        foreach itemkey in ( GetConfigStringKeys( cfgeinzel ) ) // Insert possible single
          if ( cfgeinzel[itemkey].list == itemlist )
            element[key][itemlist].append( { itemkey, "Einzel", cfgeinzel[itemkey].name }
                                           );
          endif
          SleepMS( 2 );
        endforeach
        foreach itemkey in ( GetConfigStringKeys( cfgset ) ) // Insert possible sets
          if ( cfgset[itemkey].list == itemlist )
            element[key][itemlist].append( { itemkey, "Set", cfgset[itemkey].name }
                                           );
          endif
          SleepMS( 2 );
        endforeach
        element[key][itemlist] := SortArrayABC( element[key][itemlist], 1, 3 );
      endforeach
    endif

    if ( cfgmenu[key].sublist )
      foreach sub1key in ( GetConfigStringArray( cfgmenu[key], "sublist" ) ) // 2. level
        element[key][sub1key] := dictionary;

        if ( cfgmenu[sub1key].list ) // Items
          foreach itemlist in ( GetConfigStringArray( cfgmenu[sub1key], "list" )
                                )
            element[key][sub1key][itemlist] := array;
            foreach itemkey in ( GetConfigStringKeys( cfgrandom ) ) // Insert possible random
              if ( cfgrandom[itemkey].list == itemlist )
                element[key][sub1key][itemlist].append( { itemkey, "Random", cfgrandom[itemkey].name }
                                                        );
              endif
              SleepMS( 2 );
            endforeach
            foreach itemkey in ( GetConfigStringKeys( cfgeinzel ) ) // Insert possible single
              if ( cfgeinzel[itemkey].list == itemlist )
                element[key][sub1key][itemlist].append( { itemkey, "Einzel", cfgeinzel[itemkey].name }
                                                        );
              endif
              SleepMS( 2 );
            endforeach
            foreach itemkey in ( GetConfigStringKeys( cfgset ) ) // Insert possible sets
              if ( cfgset[itemkey].list == itemlist )
                element[key][sub1key][itemlist].append( { itemkey, "Set", cfgset[itemkey].name }
                                                        );
              endif
              SleepMS( 2 );
            endforeach
            element[key][sub1key][itemlist] := SortArrayABC( element[key][sub1key][itemlist],
                                                             1, 3 );
          endforeach
        endif

        if ( cfgmenu[sub1key].sublist )
          foreach sub2key in ( GetConfigStringArray( cfgmenu[sub1key], "sublist" )
                               ) // 3. level
            element[key][sub1key][sub2key] := dictionary;

            if ( cfgmenu[sub2key].list ) // Items
              foreach itemlist in ( GetConfigStringArray( cfgmenu[sub2key], "list" )
                                    )
                element[key][sub1key][sub2key][itemlist] := array;
                foreach itemkey in ( GetConfigStringKeys( cfgrandom ) ) // Insert possible random
                  if ( cfgrandom[itemkey].list == itemlist )
                    element[key][sub1key][sub2key][itemlist].append( { itemkey, "Random",
                                                                     cfgrandom[itemkey].name }
                                                                     );
                  endif
                  SleepMS( 2 );
                endforeach
                foreach itemkey in ( GetConfigStringKeys( cfgeinzel ) ) // Insert possible single
                  if ( cfgeinzel[itemkey].list == itemlist )
                    element[key][sub1key][sub2key][itemlist].append( { itemkey, "Einzel",
                                                                     cfgeinzel[itemkey].name }
                                                                     );
                  endif
                  SleepMS( 2 );
                endforeach
                foreach itemkey in ( GetConfigStringKeys( cfgset ) ) // Insert possible sets
                  if ( cfgset[itemkey].list == itemlist )
                    element[key][sub1key][sub2key][itemlist].append( { itemkey, "Set",
                                                                     cfgset[itemkey].name }
                                                                     );
                  endif
                  SleepMS( 2 );
                endforeach
                element[key][sub1key][sub2key][itemlist] := SortArrayABC( element[key][sub1key][sub2key][itemlist],
                                                                          1, 3 );
              endforeach
            endif

            if ( cfgmenu[sub2key].sublist )
              foreach sub3key in ( GetConfigStringArray( cfgmenu[sub2key], "sublist" )
                                   ) // 4. level
                element[key][sub1key][sub2key][sub3key] := dictionary;

                if ( cfgmenu[sub3key].list ) // Items
                  foreach itemlist in ( GetConfigStringArray( cfgmenu[sub3key], "list" )
                                        )
                    element[key][sub1key][sub2key][sub3key][itemlist] := array;
                    foreach itemkey in ( GetConfigStringKeys( cfgrandom ) ) // Insert possible random
                      if ( cfgrandom[itemkey].list == itemlist )
                        element[key][sub1key][sub2key][sub3key][itemlist].append(
                                                                                  {
                                                                                  itemkey,
                                                                                  "Random",
                                                                                  cfgrandom[itemkey].name }
                                                                                  );
                      endif
                      SleepMS( 2 );
                    endforeach
                    foreach itemkey in ( GetConfigStringKeys( cfgeinzel ) ) // Insert possible single
                      if ( cfgeinzel[itemkey].list == itemlist )
                        element[key][sub1key][sub2key][sub3key][itemlist].append(
                                                                                  {
                                                                                  itemkey,
                                                                                  "Einzel",
                                                                                  cfgeinzel[itemkey].name }
                                                                                  );
                      endif
                      SleepMS( 2 );
                    endforeach
                    foreach itemkey in ( GetConfigStringKeys( cfgset ) ) // Insert possible sets
                      if ( cfgset[itemkey].list == itemlist )
                        element[key][sub1key][sub2key][sub3key][itemlist].append(
                                                                                  {
                                                                                  itemkey,
                                                                                  "Set",
                                                                                  cfgset[itemkey].name }
                                                                                  );
                      endif
                      SleepMS( 2 );
                    endforeach
                    element[key][sub1key][sub2key][sub3key][itemlist] := SortArrayABC(
                                                                                       element[key][sub1key][sub2key][sub3key][itemlist],
                                                                                       1,
                                                                                       3 );
                  endforeach
                endif
              endforeach
            endif
          endforeach
        endif
      endforeach
    endif
  endforeach

  // Rootlist
  layout := layoutraw;
  data := dataraw;
  MenuBar( layout, data, element );
  data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>BauTool " + VERSION + "</center>";
  // Titel

  dataelement.setprop( "LayoutMenuBar", layout );
  dataelement.setprop( "DataMenuBar", data );

  foreach ebene1 in element // 1. level
    layout := layoutraw;
    data := dataraw;
    MenuBar( layout, data, ebene1 );
    data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene1_iter + "</center>";
    // Titel
    dataelement.setprop( "LayoutMain_" + _ebene1_iter, layout );
    dataelement.setprop( "DataMain_" + _ebene1_iter, data );

    foreach ebene2 in ebene1 // 2.level
      layout := layoutraw;
      data := dataraw;
      MenuBar( layout, data, ebene2 );
      data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene2_iter + "</center>";
      // Titel
      dataelement.setprop( "LayoutSub_" + _ebene1_iter + "_" + _ebene2_iter, layout );
      dataelement.setprop( "DataSub_" + _ebene1_iter + "_" + _ebene2_iter, data );

      if ( TypeOfInt( ebene2 ) <> OT_DICTIONARY ) // Items
        foreach item in ebene2
          InitItems( data, layout, item, _ebene2_iter, layoutraw, dataraw );
          dataelement.setprop( "LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + item[1],
                               layout );
          dataelement.setprop( "DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + item[1],
                               data );
          SleepMS( 2 );
        endforeach
      else
        foreach ebene3 in ebene2 // 3.level
          layout := layoutraw;
          data := dataraw;
          MenuBar( layout, data, ebene3 );
          data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene3_iter + "</center>";
          // Titel
          dataelement.setprop( "LayoutSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter,
                               layout );
          dataelement.setprop( "DataSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter,
                               data );

          if ( TypeOfInt( ebene3 ) <> OT_DICTIONARY ) // Items
            foreach item in ebene3
              InitItems( data, layout, item, _ebene3_iter, layoutraw, dataraw );
              dataelement.setprop( "LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + item[1],
                                   layout );
              dataelement.setprop( "DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + item[1],
                                   data );
              SleepMS( 2 );
            endforeach
          else
            foreach ebene4 in ebene3 // 4.level
              layout := layoutraw;
              data := dataraw;
              MenuBar( layout, data, ebene4 );
              data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene4_iter + "</center>";
              // Titel
              dataelement.setprop( "LayoutSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter,
                                   layout );
              dataelement.setprop( "DataSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter,
                                   data );

              if ( TypeOfInt( ebene4 ) <> OT_DICTIONARY ) // Items
                foreach item in ebene4
                  InitItems( data, layout, item, _ebene4_iter, layoutraw, dataraw );
                  dataelement.setprop( "LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + item[1],
                                       layout );
                  dataelement.setprop( "DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + item[1],
                                       data );
                  SleepMS( 2 );
                endforeach
              else
                foreach ebene5 in ebene4 // 5.level
                  layout := layoutraw;
                  data := dataraw;
                  MenuBar( layout, data, ebene5 );
                  data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + _ebene5_iter + "</center>";
                  // Titel
                  dataelement.setprop( "LayoutSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter,
                                       layout );
                  dataelement.setprop( "DataSub_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter,
                                       data );

                  if ( TypeOfInt( ebene5 ) <> OT_DICTIONARY ) // Items
                    foreach item in ebene5
                      InitItems( data, layout, item, _ebene5_iter, layoutraw, dataraw );
                      dataelement.setprop( "LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter + "_" + item[1],
                                           layout );
                      dataelement.setprop( "DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter + "_" + item[1],
                                           data );
                      SleepMS( 2 );
                    endforeach
                  else
                    foreach ebene6 in ebene5 // 6.level
                      InitItems( data, layout, ebene6, _ebene6_iter, layoutraw, dataraw );
                      dataelement.setprop( "LayoutItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter + "_" + _ebene6_iter,
                                           layout );
                      dataelement.setprop( "DataItem_" + _ebene1_iter + "_" + _ebene2_iter + "_" + _ebene3_iter + "_" + _ebene4_iter + "_" + _ebene5_iter + "_" + _ebene6_iter,
                                           data );
                      SleepMS( 2 );
                    endforeach
                  endif
                endforeach
              endif
            endforeach
          endif
        endforeach
      endif
    endforeach
  endforeach

  // ModifyItem Menu
  dataelement := datafile.CreateElement( "modify" );
  layout := { "nodispose", "page 0", "resizepic 500 0 3600 215 280", // Background
              "resizepic 515 15 5054 185 30", // title
              "htmlgump 515 22 185 30 0 0 0", // Title text
              "resizepic 515 47 83 185 218", // Posts
              "checkertrans 523 57 170 198", "htmlgump 610 225 50 20 1 0 0", // Continue
              "htmlgump 555 79 50 20 2 0 0", // X/Y
              "htmlgump 624 79 50 20 3 0 0", // Z
              "button 660 220 9721 9724 1 0 " + BACKBUTTON, "button 560 60 5600 5604 1 0 " + MODIFY_Y_DOWN,
              "button 560 100 5602 5606 1 0 " + MODIFY_Y_UP, "button 530 80 5603 5607 1 0 " + MODIFY_X_DOWN,
              "button 590 80 5601 5605 1 0 " + MODIFY_X_UP, "button 534 60 22406 22407 1 0 " + MODIFY_XY_MM,
              "button 583 60 22401 22400 1 0 " + MODIFY_XY_PM, "button 534 100 22403 22402 1 0 " + MODIFY_XY_MP,
              "button 583 100 22404 22405 1 0 " + MODIFY_XY_PP, "button 620 60 5600 5604 1 0 " + MODIFY_Z_UP,
              "button 620 100 5602 5606 1 0 " + MODIFY_Z_DOWN, "htmlgump 570 165 50 20 4 0 0",
              "button 530 160 9727 9728 1 0 " + MODIFY_DESTROY, "htmlgump 570 200 50 30 10 0 0",
              "button 530 195 9727 9728 1 0 " + MODIFY_DUPE, "htmlgump 570 130 50 30 5 0 0",
              "resizepic 610 125 2620 58 30", "textentry 616 130 40 20 1000 " + ITEMCOLOR + " 6",
              "button 530 125 9727 9728 1 0 " + MODIFY_COLOR, "htmlgump 630 60 50 20 7 0 0",
              // x / y / z Coord Specification of the first item
              "tooltip 3000561", // Coords.:
              "htmlgump 630 80 50 20 8 0 0", "tooltip 3000561", "htmlgump 630 100 50 20 9 0 0",
              "tooltip 3000561", "button 681 64 2103 2104 0 2 0", "button 681 84 2103 2104 0 3 0",
              "button 681 104 2103 2104 0 4 0" };

  data := { "<basefont size=8 color=" + HTML_DARKGREEN + "><center>Modify Position</center>",
            // title
            "<basefont color=" + HTML_DARKBLUE + ">Continue", "<basefont color=" + HTML_DARKBLUE + ">X/Y",
            "<basefont color=" + HTML_DARKBLUE + ">Z", "<basefont color=" + HTML_DARKBLUE + ">Destroy",
            "<basefont color=" + HTML_DARKBLUE + ">Color", "0", "<basefont color=" + HTML_DARKBLUE + "><p align=right>x</p></basefont>",
            "<basefont color=" + HTML_DARKBLUE + "><p align=right>y</p></basefont>",
            "<basefont color=" + HTML_DARKBLUE + "><p align=right>z</p></basefont>",
            "<basefont color=" + HTML_DARKBLUE + ">Dupe", "0", "0", "0" };
  layoutp := { "page 2", "resizepic 720 40 3600 100 60", "resizepic 735 55 2620 48 30",
               "textentrylimited 741 60 30 20 1000 " + MODIFY_X_ENTRY + " 11 4",
               "button 790 63 2103 2104 1 0 " + MODIFY_X, "page 3", "resizepic 720 60 3600 100 60",
               "resizepic 735 75 2620 48 30", "textentrylimited 741 80 30 20 1000 " + MODIFY_Y_ENTRY + " 12 4",
               "button 790 83 2103 2104 1 0 " + MODIFY_Y, "page 4", "resizepic 720 80 3600 100 60",
               "resizepic 735 95 2620 48 30", "textentrylimited 741 100 30 20 1000 " + MODIFY_Z_ENTRY + " 13 4",
               "button 790 103 2103 2104 1 0 " + MODIFY_Z };

  dataelement.setprop( "LayoutMenu", layout + layoutp );
  dataelement.setprop( "DataMenu", data );

  // manual Modify
  layout[3] := "resizepic 500 0 3600 215 440"; // Background expand
  layout[6] := "resizepic 516 47 83 183 377";
  layout[7] := "checkertrans 524 57 168 358";
  layout.erase( 8 ); // Next ButtonText
  layout.erase( 10 ); // Next button
  layout.append( "gumppictiled 525 235 165 2 30002" );
  layout.append( "htmlgump 595 255 100 20 1 0 0" );
  layout.append( "button 560 250 9721 9724 1 0 " + MODIFY_START );
  data[2] := "<basefont color=" + HTML_DARKBLUE + ">Choose Items";
  layout.append( "resizepic 530 285 2620 48 30" );
  layout.append( "textentry 536 290 30 20 1000 " + MODIFY_Z_START + " 14" );
  data.append( "-20" );
  layout.append( "resizepic 635 285 2620 48 30" );
  layout.append( "textentry 641 290 30 20 1000 " + MODIFY_Z_END + " 15" );
  data.append( "20" );
  layout.append( "htmlgump 585 290 50 20 16 0 0" );
  data.append( "<basefont color=" + HTML_DARKBLUE + ">Z-Range" );
  layout.append( "checkbox 530 320 9720 9723 0 " + MODIFY_CUSTOM );
  layout.append( "htmlgump 565 325 50 20 17 0 0" );
  data.append( "<basefont color=" + HTML_DARKBLUE + ">Custom" );
  layout.append( "checkbox 616 320 9720 9723 0 " + MODIFY_MARK );
  layout.append( "htmlgump 651 325 50 20 18 0 0" );
  data.append( "<basefont color=" + HTML_DARKBLUE + ">Mark" );
  layout.append( "gumppictiled 525 360 165 2 30002" );
  layout.append( "button 530 375 9721 9724 1 0 " + MODIFY_MARKEDIT );
  layout.append( "htmlgump 570 380 100 20 19 0 0" );
  data.append( "<basefont color=" + HTML_DARKBLUE + ">Mark Edit" );
  dataelement.setprop( "LayoutMenuManual", layout + layoutp );
  dataelement.setprop( "DataMenuManual", data );

  // Mark Edit
  dataelement := datafile.CreateElement( "modifymark" );
  layout := { "nodispose", "page 0", "resizepic 500 0 3600 215 213", // Background
              "resizepic 515 15 5054 185 30", // title
              "htmlgump 515 22 185 30 0 0 0", // Title text
              "resizepic 515 47 83 185 150", // Posts-20
              "checkertrans 523 57 170 130", "button 530 70 9721 9724 1 0 " + MARK_SHOW,
              "htmlgump 570 75 50 20 1 0 0", "button 530 105 9721 9724 1 0 " + MARK_HIDE,
              "htmlgump 570 110 50 20 2 0 0", "button 530 140 9721 9724 1 0 " + MARK_EDIT,
              "htmlgump 570 145 50 20 3 0 0" };
  data := { "<basefont size=8 color=" + HTML_DARKGRAY + "><center>Mark Edit</center>",
            "<basefont color=" + HTML_DARKBLUE + ">Show", "<basefont color=" + HTML_DARKBLUE + ">Hide",
            "<basefont color=" + HTML_DARKBLUE + ">Edit" };
  dataelement.setprop( "LayoutMenuMark", layout );
  dataelement.setprop( "DataMenuMark", data );

  // Save the dict of the menus / items
  dataelement := datafile.CreateElement( "elemente" );
  dataelement.setprop( "dictionary", element );

  EraseGlobalProperty( "bautoolinit" );
  SysLog( ".BAUTOOL Datafile completed" );

endfunction // }}}

///////////////////////////////////
// InitItems - Outsourcing for the init function
///////////////////////////////////

function InitItems( byref data, byref layout, byref element, name := 0, layoutraw,
                    dataraw ) // {{{
  var tile, nextpagebreak, nextlinebreak, x, y, page, m, itemdesc;
  case ( element[2] )
    "Random": // Random
      layout := layoutraw;
      data := dataraw;
      data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + name + "</center>";
      // TESTTESTTEST
      layout := layout + { "page 0", "resizepic 70 0 3600 404 170", "resizepic 85 15 5054 374 30",
                           "htmlgump 85 22 374 30 " + data.size() + " 0 0", "resizepic 85 47 83 374 108",
                           "checkertrans 93 57 359 88" };
      data.append( "<basefont size=5><center>" + cfgrandom[element[1]].name + "</center>" );
      tile := GetConfigStringArray( cfgrandom[element[1]], "tile" )[1];
      layout.append( "tilepic 95 60 " + CInt( SplitWords( tile, "," )[1] ) );
      layout.append( "htmlgump 160 70 50 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">Color" );
      layout.append( "resizepic 200 65 2620 48 30" );
      layout.append( "textentry 206 70 30 20 1000 " + ITEMCOLOR + " " + data.size()
                     );
      data.append( "0" );
      if ( ( GetConfigString( cfgrandom[element[1]], "n" ) ) // Option necessary for edge parts?
           || ( GetConfigString( cfgrandom[element[1]], "s" ) ) || ( GetConfigString(
           cfgrandom[element[1]], "e" ) ) || ( GetConfigString( cfgrandom[element[1]],
           "w" ) ) )
        layout.append( "htmlgump 360 60 50 40 " + data.size() + " 0 0" );
        data.append( "<basefont color=" + HTML_DARKBLUE + ">Produce Random Tiles" );
        layout.append( "checkbox 420 65 9720 9723 0 " + ITEMRAND );
      endif
      layout.append( "htmlgump 260 70 50 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">z-Coord" );
      layout.append( "resizepic 310 65 2620 38 30" );
      layout.append( "textentry 316 70 20 20 1000 " + ITEMPOS + " " + data.size()
                     );
      data.append( "0" );
      layout.append( "checkbox 420 110 9720 9723 1 " + ITEMMODIFY );
      layout.append( "htmlgump 360 105 50 40 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">Modify Position" );
      layout.append( "button 103 116 9721 9724 1 0 " + ITEMCREATE );
      layout.append( "htmlgump 140 121 50 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">Create" );

    "Einzel":
      itemdesc := ReadConfigFile( ":*:itemdesc" ); // Reading of all Itemdesc's for name determination
      layout := layoutraw;
      data := dataraw;
      data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + name + "</center>";
      layout := layout + { "page 0", "resizepic 70 0 3600 425 400", "resizepic 85 15 5054 395 30",
                           "htmlgump 85 22 395 30 " + data.size() + " 0 0", "resizepic 85 47 83 395 343" };
      data.append( "<basefont size=5><center>" + cfgeinzel[element[1]].name + "</center>" );
      layout.append( "htmlgump 530 70 50 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">Color" );
      layout.append( "resizepic 570 65 2620 48 30" );
      layout.append( "textentry 576 70 30 20 1000 " + ITEMCOLOR + " " + data.size()
                     );
      data.append( "0" );
      layout.append( "htmlgump 530 110 50 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">z-Coord" );
      layout.append( "resizepic 580 105 2620 38 30" );
      layout.append( "textentry 586 110 20 20 1000 " + ITEMPOS + " " + data.size()
                     );
      data.append( "0" );
      layout.append( "checkbox 530 150 9720 9723 1 " + ITEMMODIFY );
      layout.append( "htmlgump 572 155 100 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">Modify Position" );
      layout.append( "checkbox 530 185 9720 9723 0 " + ITEMMMULTICREATE );
      layout.append( "htmlgump 572 190 100 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">Mark All" );
      layout.append( "button 570 225 9721 9724 1 0 " + ITEMCREATE );
      layout.append( "htmlgump 612 230 50 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">Create" );

      tile := {};
      // Build an array of items
      foreach tiles in ( GetConfigStringArray( cfgeinzel[element[1]], "tile" ) )
        if ( !tile )
          tile := { tiles };
        else
          tile.append( tiles );
        endif
        SleepMS( 2 );
      endforeach
      // Generate pages of the items
      nextpagebreak := MAXLINEITEM * 2 + 1;
      nextlinebreak := MAXLINEITEM + 1;
      x := 100;
      y := 60;
      page := 1;
      layout.append( "page 1" );
      for ( m := 1; m <= tile.size(); m += 1 )
        if ( m == nextpagebreak )
          nextpagebreak += MAXLINEITEM * 2;
          nextlinebreak += MAXLINEITEM;
          x := 100;
          y := 60;
          if ( page > 1 )
            layout.append( "button 250 360 5603 5607 0 " + ( page - 1 ) + " 0" );
          endif
          page += 1;
          layout.append( "button 280 360 5601 5605 0 " + page + " 0" );
          layout.append( "page " + page );
        endif
        if ( m == nextlinebreak )
          y := 210;
          x := 100;
          nextlinebreak += MAXLINEITEM;
        endif

        layout.append( "radio " + ( x ) + " " + ( y + 35 ) + " 9720 9723 0 " + m );
        layout.append( "tilepic " + ( x + 35 ) + " " + ( y + 35 ) + " " + CInt( SplitWords(
                       tile[m], "," )[1] ) );
        if ( itemdesc[Hex( tile[m] )].desc ) // Insert name .desc or CliLoc entry
          layout.append( "htmlgump " + ( x + 5 ) + " " + ( y ) + " 90 40 " + data.size()
                         + " 0 0" );
          data.append( "<basefont color=" + HTML_GRAY + ">" + itemdesc[Hex( tile[m] )].
                       desc );
        else
          layout.append( "xmfhtmlgumpcolor " + ( x + 5 ) + " " + ( y ) + " 90 40 " + (
                         1020000 + CInt( tile[m] ) ) + " 0 0 " + XMFCOLOR_GRAY2 );
        endif
        x += 90;
        SleepMS( 2 );
      endfor
      if ( page > 1 )
        layout.append( "button 250 360 5603 5607 0 " + ( page - 1 ) + " 0" );
      endif

    "Set":
      layout := layoutraw;
      data := dataraw;
      data[1] := "<basefont size=8 color=" + HTML_DARKGRAY + "><center>" + name + "</center>";
      layout.append( "htmlgump 515 60 185 30 " + data.size() + " 0 0" );
      data.append( "<basefont size=5 color=" + HTML_DARKGRAY + "><center>" + cfgset[element[1]].name + "</center>" );
      layout.append( "htmlgump 530 100 50 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">Color" );
      layout.append( "resizepic 570 95 2620 48 30" );
      layout.append( "textentry 576 100 30 20 1000 " + ITEMCOLOR + " " + data.size()
                     );
      data.append( "0" );
      layout.append( "htmlgump 530 140 50 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">z-Coord" );
      layout.append( "resizepic 580 135 2620 38 30" );
      layout.append( "textentry 586 140 20 20 1000 " + ITEMPOS + " " + data.size()
                     );
      data.append( "0" );
      layout.append( "checkbox 530 180 9720 9723 1 " + ITEMMODIFY );
      layout.append( "htmlgump 572 185 100 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">Modify Position" );
      layout.append( "checkbox 530 215 9720 9723 0 " + ITEMMMULTICREATE );
      layout.append( "htmlgump 572 220 100 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">Mark All" );

      layout.append( "button 570 255 9721 9724 1 0 " + ITEMCREATE );
      layout.append( "htmlgump 612 260 50 30 " + data.size() + " 0 0" );
      data.append( "<basefont color=" + HTML_DARKBLUE + ">Create" );
  endcase
endfunction // }}}

///////////////////////////////////
// RecoverInitItem - in the event of a non-existent init item attempt to restore
///////////////////////////////////

function RecoverInitItem( newinit ) // {{{
  // Serial of the old, removed init item
  var oldinit := newinit.getprop( CPROP_INIT );

  // List of items found that also include the
  // have entered old serial as init item
  var found := array{ newinit };
  // List of the serials of these items (for a new initiative)
  var serials := array{ newinit.serial };

  // Search region for items ...
  foreach item in ( ListItemsNearLocation( newinit.x, newinit.y, LIST_IGNORE_Z, MAXAREASIZE,
                    newinit.realm ) )
    SleepMs( 2 );
    if ( item.serial == newinit.serial )
      // do not enter twice
      continue;
    endif
    // ... who also entered the old serial
    if ( item.getprop( CPROP_INIT ) == oldinit )
      // pack in lists and ...
      found.append( item );
      serials.append( item.serial );
      // ... Enter new init item
      item.setprop( CPROP_INIT, newinit.serial );
    endif
  endforeach

  // complete new initiative
  newinit.setprop( CPROP_INIT, newinit.serial );
  newinit.setprop( CPROP_ITEMS, serials );

  // return list last
  return found;
endfunction // }}}
// vim: sw=2 sts=2
